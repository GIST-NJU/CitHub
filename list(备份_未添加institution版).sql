/*
 Navicat Premium Data Transfer

 Source Server         : CithubLocal
 Source Server Type    : MySQL
 Source Server Version : 80028
 Source Host           : localhost:3306
 Source Schema         : cithub-repo

 Target Server Type    : MySQL
 Target Server Version : 80028
 File Encoding         : 65001

 Date: 18/01/2024 20:38:40
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for list
-- ----------------------------
DROP TABLE IF EXISTS `list`;
CREATE TABLE `list`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `time_stamp` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `year` int(0) NOT NULL,
  `type` varchar(25) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `author` varchar(1000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `title` varchar(1000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `field` varchar(1000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `tag` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `booktitle` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `abbr` varchar(1000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `vol` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `no` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `pages` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `publisher` varchar(1000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `doi` varchar(1000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `Projects` varchar(1000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `paperabstract` varchar(10000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `institution` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 10886 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of list
-- ----------------------------
INSERT INTO `list` VALUES (1, '0000-00-00', 1985, 'article', 'Robert Mandl', 'Orthogonal Latin Squares: An Application of Experimental Design to Compiler Testing', 'Application', '', '1985 Communications of the ACM', 'COMMUN ACM', '28', '10', '1054–1058', '', '10.1145/4372.4375', 'Combinatorial Testing', 'Orthogonal Latin squares—a new method for testing compilers—yields the informational equivalent of exhaustive testing at a fraction of the cost. The method has been used successfully in designing some of the tests in the Ada Compiler Validation Capability (ACVC) test suite.', NULL);
INSERT INTO `list` VALUES (2, '0000-00-00', 1987, 'inproceedings', 'Keizo Tatsumi, S. Watanabe, Y. Takeuchi, H. Shimokawa', 'Conceptual support for test case design', 'Application', 'Constraint', '1987 International Computers, Software & Applications Conference', 'COMPSAC', '', '', '285-290', '', 'not found', 'Combinatorial Testing', 'A system has been developed to support the design of test cases in the black box testing field. Designing test cases for large-scale software requires knowledge, not only of the functions of the tested, but also of the associated software and hardware. In the black box testing, test case designs are based on the external specifications or manuals. However, since not all of the factors influencing program operations (called input conditions) are described in the external specifications, the omission of test cases are liable to occur. Several methodologies of test data selection have been proposed to date, but the problem of how to extract the input conditions of a program remains to be solved. The test case design support system described in this paper attempts to solve this problem by accumulating and utilizing the knowledge needed to design test cases and by generating test cases automatically based on the concepts of experimental design.', NULL);
INSERT INTO `list` VALUES (3, '0000-00-00', 1987, 'inproceedings', 'Keizo Tatsumi', 'Test Case Design Support System', 'Application', 'Constraint', '1987 International Conference on Quality Control', 'ICQC', '', '', '615-620', '', 'not found', 'Combinatorial Testing', 'This paper describes a system which supports the design of software tests from external specifications which is called black-box testing. In the black-box testing, test case designs are based on the external specifications. However, not all of the factors influencing program operations are clearly described in such documents. Furthermore, designing test cases for large-scale software requires knowledge, not only of the functions which are tested, but also of the associated software and hardware. Sometimes, it causes a problem that the quality of testing heavily depends on the scope of knowledge and insight of testing personnel. The test case design support system described in this paper offers the following functions to standardize the quality of testing at higher level without depending on one\'s ability: 1) accumulating and utilizing the knowledge needed to design test cases 2)extracting test factors automatically by analyzing the external specifications 3)generating test cases automatically based on the concepts of the Design of Experiments.', NULL);
INSERT INTO `list` VALUES (4, '0000-00-00', 1988, 'article', 'Gadiel Seroussi, Nader H. Bshouty', 'Vector Sets for Exhaustive Testing of Logic Circuits', 'Application', '', '1988 IEEE Transaction on Information Theory', 'TIT', '34', '3', '513-522', '', '10.1109/18.6031', 'Combinatorial Testing', 'A vector set T⊆{0,1} L is called (L,d)-universal if for every set of indices R={r 1 ,r 2 ,···,r d }⊆{0,1,···,L-1}, the projection of T onto R contains all 2 d binary d- tuples. (L,d)-universal sets are useful for exhaustively testing logic circuits with a large number of functional components, designed so that every functional component depends on at most d inputs. Randomized and deterministic constructions of (L,d)-universal test sets are presented, and lower and upper bounds on the optimal sizes of such sets are proven. It is also proven that the design of an optimal exhaustive test set for an arbitrary logic circuit is an NP-complete problem.', NULL);
INSERT INTO `list` VALUES (5, '0000-00-00', 1989, 'article', 'Charles J. Colbourn, Paul C. van Oorschot', 'Applications of combinatorial designs in computer science', 'Application', 'Survey', '1989 ACM Computing Surveys', 'CSUR', '21', '2', '223-250', '', '10.1145/66443.66446', 'Combinatorial Testing', 'The theory of combinatorial designs has been used in widely different areas of computation concerned with the design and analysis of both algorithms and hardware. Combinatorial designs capture a subtle balancing property that is inherent in many difficult problems and hence can provide a sophisticated tool for addressing these problems. The role of combinatorial designs in solving many problems that are basic to the field of computing is explored in this paper. Case studies of many applications of designs to computation are given; these constitute a first survey, which provides a representative sample of uses of designs. More importantly, they suggest paradigms in which designs can be used profitably in algorithm design and analysis.', NULL);
INSERT INTO `list` VALUES (6, '0000-00-00', 1992, 'article', 'Robert Brownlie, James Prowse, Madhav S. Phadke', 'Robust Testing of AT&T PMX/StarMAIL Using Oats', 'Application', '', '1992 AT&T Technical Journal', 'ATT tech', '71', '3', '41-47', '', '10.1002/j.1538-7305.1992.tb00164.x', 'Combinatorial Testing', 'Robust Testing is a systematic test method that uses the OATS (Orthogonal Array Testing System) tool to convert information from product requirements or specifications into a concise set of tests. We found Robust Testing more than twice as productive as conventional testing practices for testing PMX/StarMAIL Release 2.2, a complex private mail exchange (PMX) local area network (LAN)-based electronic mail product that works with several types and versions of LAN software, operating systems, and personal computers (PCs). Robust Testing required less time, enabling us to complete testing on schedule. It found more potentially user-affecting faults, and inspired greater confidence in the quality of the delivered product.', NULL);
INSERT INTO `list` VALUES (8, '0000-00-00', 1994, 'inproceedings', 'Kirk Burroughs, Aridaman Jain, Robert L. Erickson', 'Improved Quality of Protocol Testing Through Techniques of Experimental Design', 'Application', '', '1994 IEEE International Conference on Communications', 'ICC', '', '', '745-752', '', '10.1109/ICC.1994.368821', 'Combinatorial Testing', 'This paper describes how both the quality and efficiency of protocol testing were improved by using a new Bellcore tool called the Automatic Efficient Test Generator (AETG). The AETG tool is based on ideas from experimental design and it creates a test set that contains all possible pairs of involved factors. Two examples are given to illustrate this technique and compare it with traditional approaches. The improved quality of testing leads to a faster detection of nonconformances and a higher quality of products in a shorter development interval. Although the application discussed in this paper covers protocol conformance testing, the techniques for improving the quality of testing can be applied to other types of testing such as feature testing and testing between two different network elements', NULL);
INSERT INTO `list` VALUES (9, '0000-00-00', 1994, 'inproceedings', 'David M. Cohen, Siddhartha R. Dalal, A. Kajla, Gardner C. Patton', 'The Automatic Efficient Tests Generator (AETG) System', 'Generation', '', '1994 International Conference on Software Reliability Engineering', 'ISSRE', '', '', '303 - 309', '', '10.1109/ISSRE.1994.341392', 'Combinatorial Testing', 'Software testing is expensive, tedious and time consuming. Thus, the problem of making testing more efficient and mechanical, without losing its effectiveness, is very important. The Automatic Efficient Test Generator (AETG) is a new tool that mechanically generates efficient test sets from user defined test requirements. It is based on algorithms that use ideas from statistical experimental design theory to minimize the number of tests needed for a specific level of test coverage of the input test space. The savings due to AETG are substantial when compared to exhaustive testing or other methods of testing. AETG has been used in Bellcore for screen testing, interoperability testing and for protocol conformance testing. The paper describes the current system and it constructs and reports some preliminary results obtained during initial trials', NULL);
INSERT INTO `list` VALUES (10, '0000-00-00', 1994, 'inproceedings', 'George Sherwood', 'Effective Testing of Factor Combinations', 'Generation', 'Constraint, Tool', '1994 International Conference on Software Testing, Analysis & Review', 'STAREAST', '', '', '1--16', '', 'not found', 'Combinatorial Testing', 'not found', NULL);
INSERT INTO `list` VALUES (11, '0000-00-00', 1995, 'article', 'P.W.M. John, M.E. Johnson, L.M. Moore, D. Ylvisaker', 'Minimax Distance Designs in Two-level Factorial Experiments', 'Generation', '', '1995 Journal of Society of Technical Analysts', 'STA', '44', '2', '249-263', '', '10.1016/0378-3758(94)00047-Y', 'Combinatorial Testing', 'A minimax distance criterion was set forth in Johnson et al. (1990) for the purpose of selection among experimental designs. Unlike the usual design criteria such as D-, E- or G-optimality, minimax distance presumes no underlying model and, in turn, is not concerned with the rank of an associated design matrix. In situations where either the model is unknown or it is not possible to run enough experiments to estimate all parameters of an assumed model, this criterion is considered as a viable tool in the task of design selection. This paper deals with the design space associated with n factors, each of which can take two levels. We exhibit minimax distance designs that compare favorably with designs chosen to do well on classical grounds.', NULL);
INSERT INTO `list` VALUES (12, '0000-00-00', 1996, 'article', 'David M. Cohen, Siddhartha R. Dalal, Jesse Parelius, Gardner C. Patton', 'The Combinatorial Design Approach to Automatic Test Generation', 'Generation', '', '1996 IEEE Software', 'Software', '13', '5', '83-87', '', '10.1109/52.536462', 'Combinatorial Testing', 'The combinatorial design method substantially reduces testing costs. The authors describe an application in which the method reduced test plan development from one month to less than a week. In several experiments, the method demonstrated good code coverage and fault detection ability', NULL);
INSERT INTO `list` VALUES (13, '0000-00-00', 1996, 'inproceedings', 'Alan W. Williams, Robert L. Probert', 'A Practical Strategy for Testing Pair-wise Coverage of Network Interfaces', 'Generation', 'Constraint', '1996 International Conference on Software Reliability Engineering', 'ISSRE', '', '', '246-254', '', '10.1109/ISSRE.1996.558835', 'Combinatorial Testing', 'Distributed systems consist of a number of network elements that interact with each other. As the number of network elements and interchangeable components for each network element increases, the trade-off that the system tester faces is the thoroughness of test configuration coverage vs. limited resources of time and expense that are available. An approach to resolving this trade-off is to determine a set of test configurations that test each pair-wise combination of network components. This goal gives a well-defined level of test coverage, with a reduced number of system configurations. To select such a set of test configurations, we show how to apply the method of orthogonal Latin squares, from the design of balanced statistical experiments. Since the theoretical treatment assumes constraints that may not be satisfied in practice, we then show how to adapt this approach to realistic application constraints.', NULL);
INSERT INTO `list` VALUES (14, '0000-00-00', 1997, 'article', 'David M. Cohen, Siddhartha R. Dalal, Michael L. Fredman, Gardner C. Patton', 'The AETG System: An Approach to Testing Based on Combinatorial Design', 'Generation', '', '1997 IEEE Transactions on Software Engineering', 'TSE', '23', '7', '437-444', '', '10.1109/32.605761', 'Combinatorial Testing', 'This paper describes a new approach to testing that uses combinatorial designs to generate tests that cover the pairwise, triple, or n-way combinations of a system\'s test parameters. These are the parameters that determine the system\'s test scenarios. Examples are system configuration parameters, user inputs and other external events. We implemented this new method in the AETG system. The AETG system uses new combinatorial algorithms to generate test sets that cover all valid n-way parameter combinations. The size of an AETG test set grows logarithmically in the number of test parameters. This allows testers to define test models with dozens of parameters. The AETG system is used in a variety of applications for unit, system, and interoperability testing. It has generated both high-level test plans and detailed test cases. In several applications, it greatly reduced the cost of test plan development.', NULL);
INSERT INTO `list` VALUES (15, '0000-00-00', 1997, 'inproceedings', 'I.S. Dunietz, W.K. Ehrlich, B.D. Szablak, Colin L. Mallows, A. Iannino', 'Applying Design of Experiments to Software Testing', 'Application', '', '1997 International Conference on Software Engineering', 'ICSE', '', '', '205-215', '', '10.1145/253228.253271', 'Combinatorial Testing', 'Recently, a class of experimental designs has been devised that guarantee input domain coverage up to all combinations of k test factors taken t at a time. With such designs, all pair-wise combinations (or triplets or quadruplets, etc.) are selected at least once. To evaluate their applicability to software testing, we analyzed the extent to which software coverage (i.e., code execution) achieved by these designs for r = 1,...,k is representative of that achieved by exhaustively testing all factor combinations. The block coverage obtained for t≤2 was comparable with that achieved by exhaustively testing all factor combinations but higher-order values of t were required for path coverage. Implications of these results for software testing are discussed.', NULL);
INSERT INTO `list` VALUES (16, '0000-00-00', 1998, 'inproceedings', 'Siddhartha R. Dalal, Aridaman Jain, N. Karunanithi, J.M. Leaton, C.M. Lott', 'Model-Based Testing of a Highly Programmable System', 'Application', '', '1998 International Conference on Software Reliability Engineering', 'ISSRE', '', '', '174-178', '', '10.1109/ISSRE.1998.730876', 'Combinatorial Testing', 'The paradigm of model based testing shifts the focus of testing from writing individual test cases to developing a model from which a test suite can be generated automatically. We report on our experience with model based testing of a highly programmable system that implements intelligent telephony services in the US telephone network. Our approach used automatic test case generation technology to develop sets of self checking test cases based on a machine readable specification of the messages in the protocol under test. The AETG<sup>TM</sup> software system selected a minimal number of test data tuples that covered pairwise combinations of tuple elements. We found the combinatorial approach of covering pairwise interactions between input fields to be highly effective. Our tests revealed failures that would have been difficult to detect using traditional test designs. However, transferring this technology to the testing organization was difficult. Automatic generation of cases represents a significant departure from conventional testing practice due to the large number of tests and the amount of software development involved', NULL);
INSERT INTO `list` VALUES (17, '0000-00-00', 1998, 'inproceedings', 'Kevin Burr, William Young', 'Combinatorial Test Techniques: Table-based Automation, Test Generation and Code Coverage', 'Application', '', '1998 International Conference on Software Testing Analysis and Review', 'STAREAST', '', '', '503-513', '', 'not found', 'Combinatorial Testing', 'Model-based testing relies on the assumption that effective adequacy criteria can be defined in terms of model coverage achieved by a set of test paths. However, such test paths are only abstract test cases and input test data must be specified to make them concrete. We propose a novel approach that combines model-based and combinatorial testing in order to generate executable and effective test cases from a model. Our approach starts from a finite state model and applies model-based testing to generate test paths that represent sequences of events to be executed against the system under test. Such paths are transformed to classification trees, enriched with domain input specifications such as data types and partitions. Finally, executable test cases are generated from those trees using t-way combinatorial criteria.\r\n\r\nWhile test cases that satisfy a combinatorial criterion can be generated for each individual test path obtained from the model, we introduce a post-optimization algorithm that can guarantee the combinatorial criterion of choice on the whole set of test paths extracted from the model. The resulting test suite is smaller, but it still satisfies the same adequacy criterion. We developed a tool and used it to evaluate our approach on 6 subject systems of various types and sizes, to study the effectiveness of the generated test suites, the reduction achieved by the post-optimization algorithm, as well as the effort required to produce them.', NULL);
INSERT INTO `list` VALUES (18, '0000-00-00', 1998, 'inproceedings', 'Yu Lei, Kuo-Chung Tai', 'In-Parameter-Order: A Test Generation Strategy for Pairwise Testing', 'Generation', '', '1998 International High-Assurance Systems Engineering Symposium', 'HASE', '', '', '254-261', '', '10.1109/HASE.1998.731623', 'Combinatorial Testing', 'Pairwise testing (or 2-way testing) is a specification-based testing criterion, which requires that for each pair of input parameters of a system, every combination of valid values of these two parameters be covered by at least one test case. Empirical results show that pairwise testing is practical and effective for various types of software systems. We show that the problem of generating a minimum test set for pairwise testing is NP-complete. We propose a test generation strategy, called in-parameter-order (or IPO), for pairwise testing. For a system with two or more input parameters, the IPO strategy generates a pairwise test set for the first two parameters, extends the test set to generate a pairwise test set for the first three parameters, and continues to do so for each additional parameter. The IPO strategy allows the use of local optimization techniques for test generation and the reuse of existing tests when a system is extended with new parameters or new values of existing parameters. We present practical, IPO-based test generation algorithms. We describe the implementation of an IPO-based test generation tool and show some empirical results.', NULL);
INSERT INTO `list` VALUES (19, '0000-00-00', 1998, 'article', 'V.N. Nair, D.A. James, W.K. Ehrlich, J. Zevallos', 'A Statistical Assessment of Some Software Testing Strategies and Application of Experimental Design Techniques', 'Evaluation', '', '1998 Statistica Sinica', 'Stat Sin', '8', '1', '165-184', '', 'not found', 'Combinatorial Testing', 'An important problem in software testing is the efficient generation of test cases. Two classes of strategies, random and partition testing, have been dis- cussed extensively in the software testing literature. In this paper, we provide a systematic statistical comparison of these two classes of strategies and demonstrate the usefulness of partition testing. We also show that some of the previous con- clusions in the software testing literature about the inefficiency of partition testing are incorrect. The applicability of experimental design methods for partition test- ing is also discussed. A real application is used to illustrate the various concepts and to demonstrate the usefulness of experimental design methods for generating partitions', NULL);
INSERT INTO `list` VALUES (20, '0000-00-00', 1998, 'article', 'Siddhartha R. Dalal, Colin L. Mallows', 'Factor-Covering Designs for Testing Software', 'Generation', '', '1998 Technometrics', 'Technometrics', '40', '3', '234-243', '', '10.1080/00401706.1998.10485524', 'Combinatorial Testing', 'Testing is a critical component of modern software development. The problem of designing a suite of test cases is superficially similar to that of designing an experiment to estimate main effects and interactions, but there are crucial differences. Additive models are unhelpful, and classical design criteria are also. We propose a new class of models and new measures of effectiveness. We compare several designs.', NULL);
INSERT INTO `list` VALUES (21, '0000-00-00', 1999, 'inproceedings', 'Siddhartha R. Dalal, Aridaman Jain, N. Karunanithi, J.M. Leaton, C.M. Lott, Gardner C. Patton, B.M. Horowitz', 'Model-based Testing in Practice', 'Application', '', '1999 International Conference on Software Engineering', 'ICSE', '', '', '285-294', '', '10.1145/302405.302640', 'Combinatorial Testing', 'Model-based testing is a new and evolving technique for generating a suite of test cases from requirements. Testers using this approach concentrate on a data model and generation infrastructure instead of hand-crafting individual tests. Several relatively small studies have demonstrated how combinatorial test generation techniques allow testers to achieve broad coverage of the input domain with a small number of tests. We have conducted several relatively large projects in which we applied these techniques to systems with millions of lines of code. Given the complexity of testing, the model-based testing approach was used in conjunction with test automation harnesses. Since no large empirical study has been conducted to measure efficacy of this new approach, we report on our experience with developing tools and methods in support of model-based testing. The four case studies presented here offer details and results of applying combinatorial test-generation techniques on a large scale to diverse applications. Based on the four projects, we offer our insights into what works in practice and our thoughts about obstacles to transferring this technology into testing organizations.', NULL);
INSERT INTO `list` VALUES (22, '0000-00-00', 1999, 'article', 'Charles J. Colbourn, Jeff H. Dinitz, D.R. Stinson', 'Applications of Combinatorial Designs to Communications, Cryptography, and Networking', 'Application', '', '1999 Surveys in Combinatorics', 'Book', '', '', '37-100', '', 'not found', 'Combinatorial Testing', 'Applications of Combinatorial Designs to Communications, Cryptography, and Networking', NULL);
INSERT INTO `list` VALUES (23, '0000-00-00', 2000, 'inproceedings', 'Yu-Wen Tung, Wafa S. Aldiwan', 'Automating Test Case Generation for the New Generation Mission Software System', 'Generation', '', '2000 IEEE Arospace Conference', 'AESS', '', '', '431-437', '', '10.1109/AERO.2000.879426', 'Combinatorial Testing', 'The significant expansion of autonomous control and information processing capabilities in the coming generation of mission software systems results in a qualitatively larger space of behaviors that needs to be \"covered\" during testing, not only at the system level but also at subsystem and unit levels. A major challenge in this area is to automatically generate a relatively small set of test cases that, collectively, guarantees a selected degree of coverage of the behavior space. This paper describes an algorithm for a parametric test case generation tool that applies a combinatorial design approach to the selection of candidate test cases. Evaluation of this algorithm on test parameters from the Deep Space One mission reveals a valuable reduction in the number of test cases, when compared to an earlier home-brewed generator.', NULL);
INSERT INTO `list` VALUES (24, '0000-00-00', 2000, 'inproceedings', 'Alan W. Williams', 'Determination of Test Configurations for Pair-wise Interaction Coverage', 'Generation', '', '2000 International Conference on Testing of Communicating Systems', 'ICTSS', '', '', '59-74', '', '10.1007/978-0-387-35516-0_4', 'Combinatorial Testing', 'Systems constructed from components, including distributed systems, consist of a number of elements that interact with each other. As the number of network elements or interchangeable components for each network element increases, the trade off that the system tester faces is the thoroughness of test configuration coverage, versus availability of limited resources (time and budget). An approach to resolving this trade off is to determine a minimal set of test configurations that test each pair-wise combination of components. This goal gives a well-defined, cost-effective level of test coverage, with a reduced number of system configurations. To select such a set of test configurations, we show how to apply the method of covering arrays, and improve on previous results.', NULL);
INSERT INTO `list` VALUES (25, '0000-00-00', 2000, 'inproceedings', 'Jerry Huller', 'Reducing Time to Market with Combinatorial Design Method Testing', 'Application', '', '2000 International Council on Systems', 'INCOSE', '', '', '16-20', '', 'not found', 'Combinatorial Testing', 'Reducing Time to Market with Combinatorial Design Method Testing', NULL);
INSERT INTO `list` VALUES (26, '0000-00-00', 2000, 'inproceedings', 'Patrick J. Schroeder, Bogdan Korel', 'Black-Box Test Reduction Using Input-Output Analysis', 'Generation', '', '2000 International Symposium on Software Testing and Analysis', 'ISSTA', '', '', '173-177', '', '10.1145/347324.349042', 'Combinatorial Testing', 'Test reduction is an important issue in black-box testing. The number of possible black-box tests for any non-trivial software application is extremely large. For the class of programs with multiple inputs and outputs, the number of possible tests grows very rapidly as combinations of input test data are considered. In this paper, we introduce an approach to test reduction that uses automated input-output analysis to identify relationships between program inputs and outputs. Our initial experience with the approach has shown that it can significantly reduce the number of black-box tests.', NULL);
INSERT INTO `list` VALUES (27, '0000-00-00', 2001, 'phdthesis', 'Patrick J. Schroeder', 'Black-box Test Reduction Using Input-output Analysis', 'Generation', '', '2001 Department of Computer Science, Illinois Institute of Technology, USA', 'Phd', '', '', 'not found', '', 'not found', 'Combinatorial Testing', 'Test reduction is an important issue in black-box testing. The number of possible black-box tests for any non-trivial software application is extremely large. For the class of programs with multiple inputs and outputs, the number of possible tests grows very rapidly as combinations of input test data are considered. In this paper, we introduce an approach to test reduction that uses automated input-output analysis to identify relationships between program inputs and outputs. Our initial experience with the approach has shown that it can significantly reduce the number of black-box tests.', NULL);
INSERT INTO `list` VALUES (28, '0000-00-00', 2001, 'phdthesis', 'Ahmed M. Salem', 'A Software Testing Model: Using Design of Experiments (DOE) and Logistic Regression', 'Application', '', '2001 Florida Institute of Technology', 'Phd', '', '', 'not found', '', 'not found', 'Combinatorial Testing', 'Not found', NULL);
INSERT INTO `list` VALUES (29, '0000-00-00', 2001, 'inproceedings', 'Alan W. Williams, Robert L. Probert', 'A Measure for Component Interaction Test Coverage', 'Evaluation', '', '2001 International Computers, Software & Applications Conference', 'COMPSAC', '', '', '304-311', '', '10.1109/AICCSA.2001.934001', 'Combinatorial Testing', 'A trend in software development is to assemble a system from a number of components. These may be either available commercially off-the-shelf, or by the use of network-based resources. In many cases, the system is expected to function for multiple configurations of interchangeable components. The trade off that a system tester faces is the thoroughness of test component configuration coverage, versus limited resources of time and expense. This paper presents a metric that can be used to measure component interaction coverage of a set of system test configurations. It also provides a formal definition of the system test interaction problem.', NULL);
INSERT INTO `list` VALUES (30, '0000-00-00', 2001, 'article', 'Dolores R. Wallace, D. Richard Kuhn', 'Failure Modes in Medical Device Software: an Analysis of 15 Years of Recall Data', 'Evaluation', '', '2001 International Journal of Reliability, Quality and Safety Engineering', 'IJRQSE', '8', '4', '351-371', '', '10.1142/S021853930100058X', 'Combinatorial Testing', 'Most complex systems today contain software, and systems failures activated by software faults can provide lessons for software development practices and software quality assurance. This paper presents an analysis of software-related failures of medical devices that caused no death or injury but led to recalls by the manufacturers. The analysis categorizes the failures by their symptoms and faults, and discusses methods of preventing and detecting faults in each category. The nature of the faults provides lessons about the value of generally accepted quality practices for prevention and detection methods applied prior to system release. It also provides some insight into the need for formal requirements specification and for improved testing of complex hardware-software systems.', NULL);
INSERT INTO `list` VALUES (32, '0000-00-00', 2002, 'article', 'Hongquan Xu', 'An Algorithm for Constructing Orthogonal and Nearly Orthogonal Arrays With Mixed Levels and Small Runs', 'Generation', '', '2002 American Statistical Association and the American Society for Quality', 'ASQ', '44', '4', '356-368', '', '10.1198/004017002188618554', 'Combinatorial Testing', 'An Algorithm for Constructing Orthogonal and Nearly Orthogonal Arrays With Mixed Levels and Small Runs', NULL);
INSERT INTO `list` VALUES (33, '0000-00-00', 2004, 'incollection', 'Andreas Blass, Yuri Gurevich', 'Pairwise Testing', 'Generation', '', '2004 Current Trends in Theoretical Computer Science: The Challenge of the New Century', 'Book', '', '', '237-266', '', '10.1142/9789812562494_0049', 'Combinatorial Testing', 'We discuss the following problem, which arises in software testing. Given some independent parameters (of a program to be tested), each having a certain finite set of possible values, we intend to test the program by running it several times. For each test, we give the parameters some (intelligently chosen) values. We want to ensure that for each pair of distinct parameters, every pair of possible values is used in at least one of the tests. And we want to do this with as few tests as possible.', NULL);
INSERT INTO `list` VALUES (34, '0000-00-00', 2002, 'phdthesis', 'Noritaka Kobayashi', 'Design and Evaluation of Automatic Test Generation Strategies', 'Generation', '', '2002 Graduate School of Engineering Science, Osaka University', 'Phd', '', '', 'not found', '', 'not found', 'Combinatorial Testing', 'Software testing plays an important role in the process of software development. It often\r\nconsumes up to half of the overall software development cost. Even for simple software,\r\nexhaustive testing is infeasible because the number of possible test cases is typically prohibitively large. Therefore, much research has been aimed at simultaneously achieving\r\nhigh efficacy and reducing the cost of testing by selecting test cases appropriately.\r\nIn this dissertation, we discuss three issues on test case generation. First, we discuss\r\nspecification-based testing of an implementation that is intended to satisfy a given specification that is a Boolean formula. Since many portions of the behavior of software systems\r\ncan be represented as a Boolean formula, this type of testing is considered fundamental\r\nand should be developed so as to achieve more effectiveness.\r\nWe propose a new specification-based test case generation strategy, which we refer to\r\nas EMIS (Extended Meaningful Impact Strategy), that guarantees the detection of faults\r\nin most of the classes previously proposed. We examine the costs and effectiveness of\r\nEMIS and the previous ones. Experimental results show that EMIS can achieve a high\r\nerror detection rate with relatively low cost.\r\nSecond, we examine the applicability of non-specification-based test case generation\r\nstrategies for testing software that can be modeled as Boolean formulas. In this dissertation, we use the term non-specification-based approaches to refer to test case generation\r\nstrategies that only use information available in black-box environment other than specifications.\r\nA problem with specification-based testing is that specifications used for automatic\r\ntest case generation are not always available to testers in practice. However, little researchhas been done on the applicability of non-specification-based testing for software modeled\r\nas Boolean formulas.\r\nIn this issue, we examine three non-specification-based testing techniques: combinatorial testing, random testing, and antirandom testing. We compare these three testing\r\ntechniques with EMIS. The result of the comparison analysis shows that combinatorial\r\ntesting is often comparable to EMIS and is always much superior to both random testing\r\nand antirandom testing.\r\nLastly, as the third issue, we discuss constructing 2-factor covering designs, which are\r\nused as test sets in combinatorial testing. In the literature, it has been reported that testing\r\nbased on 2-factor covering designs is effective in various industrial applications including\r\nsoftware testing. For these applications, even a small reduction in the size of a design is\r\nsignificant, because it directly reduces testing costs. Therefore, much research has been\r\naimed at reducing the size of test sets.\r\nIn this dissertation, we propose new constructions and apply them to two cases that\r\noccurred in actual testing of an ATM network monitoring system. The results show that\r\nthe proposed construction can generate very small 2-factor covering designs, compared\r\nto the previously proposed algorithms.\r\nIn addition, we address the problem of constructing small 2-factor covering designs\r\nfor the case where all parameters have three values. This problem is called the ternary\r\nSpernery problem. We have obtained 10 new 2-factor covering designs, which improve\r\non previously known results, by making use of the proposed constructions.\r\nThis dissertation is organized as follows. In Chapter 1, we briefly summarize related\r\nprogress and topics in software testing, present main results we obtained and describe the\r\noutline of the dissertation. In Chapter 2, we describe some basic concepts of software\r\ntesting techniques. In this chapter, we first briefly explain code-based testing with an\r\nexample and then describe specification-based testing in detail.\r\nIn Chapter 3, we explain the proposed specification-based test generation strategy\r\nfor testing Boolean specifications. We first present a brief explanation of the work by\r\nWeyuker et al. Then we propose a new specification-based test generation strategy that\r\nii\r\nachieves the same effectiveness with relatively low cost.\r\nIn Chapter 4, we investigate the applicability of three non-specification-based strategies: random testing, antirandom testing, and combinatorial testing, for testing software\r\nthat can be modeled as Boolean formulas.\r\nIn Chapter 5, we present new constructions of 2-factor covering designs and the results\r\nof applying them to the ATM monitoring test example and the ternary Spernery problem.\r\nFinally, in Chapter 6, we conclude this dissertation with a summary and directions for\r\nfuture work.', NULL);
INSERT INTO `list` VALUES (35, '0000-00-00', 2002, 'inbook', 'James A. Whittaker', 'Testing from the User Interface: Inputs and Outputs', 'Generation', '', '2002 How to Break Software, A Practical Guide to Testing with W/CD', 'Book', '', '', 'not found', 'Pearson Addison Wesley', 'not found', 'Combinatorial Testing', 'Not found', NULL);
INSERT INTO `list` VALUES (36, '0000-00-00', 2002, 'article', 'Kuo-Chung Tai, Yu Lei', 'A Test Generation Strategy for Pairwise Testing', 'Generation', '', '2002 IEEE Transactions on Software Engineering', 'TSE', '28', '1', '109-111', '', '10.1109/32.979992', 'Combinatorial Testing', 'Pairwise testing is a specification-based testing criterion which requires that for each pair of input parameters of a system, every combination of valid values of these two parameters be covered by at least one test case. The authors propose a novel test generation strategy for pairwise testing. ', NULL);
INSERT INTO `list` VALUES (37, '0000-00-00', 2002, 'inproceedings', 'D. Richard Kuhn, Michael J. Reilly', 'An Investigation of the Applicability of Design of Experiments to Software Testing', 'Evaluation', '', '2002 IEEE/NASA Software Engineering Workshop', 'SEW', '', '', '91-95', '', '10.1109/SEW.2002.1199454', 'Combinatorial Testing', 'Approaches to software testing based on methods from the field of design of experiments have been advocated as a means of providing high coverage at relatively low cost. Tools to generate all pairs, or higher n-degree combinations, of input values have been developed and demonstrated in a few applications, but little empirical evidence is available to aid developers in evaluating the effectiveness of these tools for particular problems. We investigate error reports from two large open-source software projects, a browser and Web server, to provide preliminary answers to three questions: Is there a point of diminishing returns at which generating all n-degree combinations is nearly as effective as all n+1-degree combinations? What is the appropriate value of n for particular classes of software? Does this value differ for different types of software, and by how much? Our findings suggest that more than 95% of errors in the software studied would be detected by test cases that cover all 4-way combinations of values, and that the browser and server software were similar in the percentage of errors detectable by combinations of degree 2 through 6.', NULL);
INSERT INTO `list` VALUES (38, '0000-00-00', 2002, 'article', 'Noritaka Kobayashi, Tsuchiya Tsuchiya, Kikuno Tohru', 'A New Method for Constructing Pair-wise Covering Designs for Software Testing', 'Generation', '', '2002 Information Processing Letters', 'Inf Process Lett', '81', '2', '85-91', '', '10.1016/S0020-0190(01)00195-8', 'Combinatorial Testing', 'Not found', NULL);
INSERT INTO `list` VALUES (39, '0000-00-00', 2002, 'inproceedings', 'Patrick J. Schroeder, Pat Faherty, Bogdan Korel', 'Generating Expected Results for Automated Black-Box Testing', 'Other', 'Oracle', '2002 International Conference on Automated Software Engineering', 'ASE', '', '', '139-148', '', '10.1109/ASE.2002.1115005', 'Combinatorial Testing', 'In this paper we describe a technique for generating expected results for automated black-box testing. Generating expected results allows larger automated test suites to be created, moving us toward continuous product testing. Our technique uses a program\'s Input-Output (IO) relationships to identify unique combinations of program inputs that influence program outputs. With this information, a small set of test cases is executed and checked for correctness. Given the correctness of this set, the expected results for the larger combinatorial test set can be generated automatically. Included in the paper is an experimental study in which checking the results of 384 test cases allows us to generate expected results and fully automate nearly 600,000 test cases.', NULL);
INSERT INTO `list` VALUES (40, '0000-00-00', 2002, 'inproceedings', 'Alan W. Williams, Robert L. Probert', 'Formulation of the Interaction Test Coverage Problem as an Integer Program', 'Generation', '', '2002 International Conference on the Testing of Communicating Systems', 'ICTCS', '', '', '283-298', '', '10.1007/978-0-387-35497-2_21', 'Combinatorial Testing', 'A trend in software development is to assemble a system from a number of components. In many cases, the system is expected to function for multiple configurations of interchangeable components, leading to the problem of determining a set of system test configurations to fit a reasonable budget. One approach is to test all configurations that cover, for example, all two-way interactions. We investigate the feasibility of using an integer programming approach to solve the interaction test coverage problem exactly. We also examine the formulation to see if it provides insight into the NP-completeness of the interaction problem.', NULL);
INSERT INTO `list` VALUES (41, '0000-00-00', 2002, 'phdthesis', 'Alan W. Williams', 'Software Component Interaction Testing: Coverage Measurement and Generation of Configurations', 'Generation', '', '2002 School of Information Technology and Engineering, University of Ottawa, Canada', 'Phd', '', '', 'not found', '', 'not found', 'Combinatorial Testing', 'Systems constructed from components, including distributed systems, consist of a number of elements that interact with each other. When a system is integrated, there may be undesired interactions among those components that cause system failures. There are two complementary problems in testing a software system. The first problem is to create a test suite, given a description of the expected behaviour of a system configuration. The second problem is to deal with a large number of distinct test configurations. We investigate the second problem in this thesis: the situation when there are various system parameters, each of which can take on a value from a discrete set. The trade-off that the system tester faces is the thoroughness of test configuration coverage, versus availability of limited resources. We introduce a coverage measure that can provide a basis for determining a set of configurations with \"sufficient\" coverage, or for evaluation of a set of test configurations that already exists. This thesis addresses the problem of testing interactions among components of a software system: the \"interaction test coverage\" problem. We formally define this problem, and give it a set-theoretic framework. This is done through the introduction of an \"interaction element,\" which becomes the unit of test coverage. The problem is compared to, and distinguished from, the minimum set cover problem and the {0,1} integer programming problem. As a result, the status of the NP-completeness of this problem remains open. Methods from statistical experimental design are introduced, and applied to the problem of generating a set of configurations that achieve coverage of all pair-wise combinations of parameter values. We present a fast, deterministic algorithm to generate such a set of test configurations. The method is compared with other methods, and shown to produce fewer configurations in most situations. The number of configurations generated is logarithmic in the number of parameters, and polynomial in the number of values per parameter. As a result, the number of configurations is usually feasible in practice, and is a significant reduction from the number of possible configurations.', NULL);
INSERT INTO `list` VALUES (42, '0000-00-00', 2003, 'inbook', 'Lee Copeland', 'Pairwise Testing', 'Application', '', '2003 A Practitioner\'s Guide to Software Test Design', 'Book', '', '', 'not found', 'Artech House', 'not found', 'Combinatorial Testing', 'not found', NULL);
INSERT INTO `list` VALUES (43, '0000-00-00', 2003, 'inproceedings', 'Gregory T. Daich', 'Testing Combinations of Parameters Made Easy', 'Model', '', '2003 Conference on Systems Readiness Technology ', 'CSRT', '', '', '397-384', '', '10.1109/AUTEST.2003.1243601', 'Combinatorial Testing', 'Given a set of application or system-specific parameters that may interact incorrectly, do not rely on guesswork in selecting which combinations of those parameters to test. This paper describes a technique and free tool called ReduceArray2 that simplify the process of identifying a minimal or near-minimal set of tests to exercise all pairs of parameters. ', NULL);
INSERT INTO `list` VALUES (44, '0000-00-00', 2003, 'inproceedings', 'Syed A. Ghazi, Moataz A. Ahmed', 'Pair-wise Test Coverage using Genetic Algorithms', 'Generation', 'Search Based', '2003 Congress on Evolutionary Computation', 'CEC', '', '', '1402-1424', '', '\n\n10.1109/CEC.2003.1299837', 'Combinatorial Testing', 'There has been an emerging trend to develop software using different components. In this way the cost of the software reduces and the developer is able to complete the system efficiently. The components\' code may or may not be visible to the developer. Testing, in this case, requires the development of a set of test configurations that can be applied on the software. However, for software that comprises a large number of components, it is infeasible to test each and every test configuration within the limited testing budget and time. In this paper we propose a GA-based technique that identifies a set of test configurations that are expected to maximize pair-wise coverage, with the constraint that the number of test configurations is predefined. Although the paper primarily focuses on the interaction between software components, the idea can be applied to single code component testing. We performed some experiments using our proposed approach. The results were promising.', NULL);
INSERT INTO `list` VALUES (45, '0000-00-00', 2003, 'article', 'Tomas Berling, Per Runeson', 'Efficient evaluation of multifactor dependent system performance using fractional factorial design', 'Application', '', '2003 IEEE Transactions on Software Engineering', 'TSE', '29', '9', '769-781', '', '10.1109/TSE.2003.1232283 ', 'Combinatorial Testing', 'Performance of computer-based systems may depend on many different factors, internal and external. In order to design a system to have the desired performance or to validate that the system has the required performance, the effect of the influencing factors must be known. Common methods give no or little guidance on how to vary the factors during prototyping or validation. Varying the factors in all possible combinations would be too expensive and too time-consuming. This paper introduces a systematic approach to the prototyping and the validation of a system\'s performance, by treating the prototyping or validation as an experiment, in which the fractional factorial design methodology is commonly used. To show that this is possible, a case study evaluating the influencing factors of the false and real target rate of a radar system is described. Our findings show that prototyping and validation of system performance become structured and effective when using the fractional factorial design. The methodology enables planning, performance, structured analysis, and gives guidance for appropriate test cases. The methodology yields not only main factors, but also interacting factors. The effort is minimized for finding the results, due to the methodology. The case study shows that after 112 test Cases, of 1,024 possible, the knowledge gained was enough to draw conclusions on the effects and interactions of 10 factors. This is a reduction with a factor 5-9 compared to alternative methods', NULL);
INSERT INTO `list` VALUES (46, '0000-00-00', 2003, 'inproceedings', 'Myra B. Cohen, Peter B. Gibbons, Warwick B. Mugridge, Charles J. Colbourn, James S. Collofello', 'A Variable Strength Interaction Testing of Components', 'Generation', '', '2003 Annual International Computer Software and Applications Conference', 'COMPSAC', '', '', '413-418', '', '10.1109/CMPSAC.2003.1245373', 'Combinatorial Testing', 'Complete interaction testing of components is too costly in all but the smallest systems. Yet component interactions are likely to cause unexpected faults. Recently, design of experiment techniques have been applied to software testing to guarantee a minimum coverage of all t-way interactions across components. However, t is always fixed. This paper examines the need to vary the size of t in an individual test suite and defines a new object, the variable strength covering array that has this property. We present some computational methods to find variable strength arrays and provide initial bounds for a group of these objects.', NULL);
INSERT INTO `list` VALUES (47, '0000-00-00', 2003, 'inproceedings', 'Christine T. Cheng, Adrian Dumitrescu, Patrick J. Schroeder', 'Generating Small Combinatorial Test Suites to Cover Input-Output Relationships', 'Generation', '', '2003 International Conference on Quality Software', 'QSIC', '', '', '76-82', '', '10.1109/QSIC.2003.1319088', 'Combinatorial Testing', 'In this paper, we consider a problem that arises in black box testing: generating small test suites (i.e., sets of test cases) where the combinations that have to be covered are specified by input-output parameter relationships of a software system. That is, we only consider combinations of input parameters that affect an output parameter. We also do not assume that the input parameters have the same number of values. To solve this problem, we revisit the greedy algorithm for test generation and show that the size of the test suite it generates is within a logarithmic factor of the optimal. Unfortunately, the algorithm\'s main weaknesses are its time and space requirements for construction. To address this issue, we present a problem reduction technique that makes the greedy algorithm or any other test suite generation method more efficient if the reduction in size is significant.', NULL);
INSERT INTO `list` VALUES (48, '0000-00-00', 2003, 'inproceedings', 'Myra B. Cohen, Peter B. Gibbons, Warwick B. Mugridge, Charles J. Colbourn', 'Constructing Test Suites for Interaction Testing', 'Generation', '', '2003 International Conference on Software Engineering', 'ICSE', '', '', '38-48', '', '10.1109/ICSE.2003.1201186', 'Combinatorial Testing', 'A Browser Compatibility Testing Method Based on Combinatorial Testing', NULL);
INSERT INTO `list` VALUES (49, '0000-00-00', 2003, 'inproceedings', 'Baowen Xu, Changhai Nie, Liang Shi, William C. Chu, Hongji Yang, Huowang Chen', 'Test Plan Design for Software Configuration Testing', 'Model', '', '2003 International Conference on Software Engineering Research and Practice', 'ICSERP', '', '', '686-692', '', 'not found', 'Combinatorial Testing', 'Configuration testing is an important step in software testing, which is a procedure to test the software with all kinds of hardware to ensure it can run on them. This paper proposes to design configuration testing plan with several common method used in the other fields and analysis their merits, to improve the orthogonal design method with pairwise testing, to decrease the testing risk with multiple factors covering., and presents simple factor cover method which can cover all the factors and pairwise combinations to the greatest degree. All these methods have good merits. At last we make some comparison at the aspects of test suit scale, coverage, usability and etc.', NULL);
INSERT INTO `list` VALUES (50, '0000-00-00', 2003, 'inproceedings', 'Lei Xu, Changhai Nie', 'A Browser Compatibility Testing Method Based on Combinatorial Testing', 'Application', '', '2003 International Conference on Web Engineering', 'ICWE', '', '', '310-313', '', '10.1007/3-540-45068-8_60', 'Combinatorial Testing', 'For ensuring the displaying effects of Web applications, it is important to perform compatibility testing for browsers under the different configurations and it is a hard task to test all. So this paper focused on the improvements for browser compatibility testing. Firstly, we introduced the related work. Then we analysed the functional speciality of the current popular browsers, and provided the preconditions to simplify problems. Next we gave an instance and brought forward the single factor covering method and the pair-wise covering design to gain testing suits. Finally, we introduced the assistant tools we have developed and the future work.', NULL);
INSERT INTO `list` VALUES (51, '0000-00-00', 2003, 'inproceedings', 'Adrian Dumitrescu', 'Efficient Algorithms for Generation of Combinatorial Covering Suites', 'Generation', '', '2003 International Symposium on Algorithms and Computation', 'ISAC', '', '', '300-308', '', '10.1007/978-3-540-24587-2_32', 'Combinatorial Testing', 'In this note we describe efficient algorithms for generating tests that cover a prescribed set of combinations of a software system&apos;s input parameters. Our methods for obtaining uniform t-wise coverage are based on repeatedly coloring the vertices of a graph such that the vertices in each t-subset have dierent colors in at least one of the colorings. The resulting algorithm is compared to other known algorithms for uniform coverage, a greedy algorithm and a randomized algorithm, in particular. The size of ots output..', NULL);
INSERT INTO `list` VALUES (52, '0000-00-00', 2003, 'inproceedings', 'Myra B. Cohen, Charles J. Colbourn, Alan C.H. Ling', 'Augmenting Simulated Annealing to Build Interaction Test Suites', 'Generation', '', '2003 International Symposium on Software Reliability Engineering', 'ISSRE', '', '', '394-405', '', '10.1109/ISSRE.2003.1251061', 'Combinatorial Testing', 'Component based software development is prone to unexpected interaction faults. The goal is to test as many\r\npotential interactions as is feasible within time and budget constraints. Two combinatorial objects, the orthogonal\r\narray and the covering array, can be used to generate test\r\nsuites that provide a guarantee for coverage of all ', NULL);
INSERT INTO `list` VALUES (54, '0000-00-00', 2004, 'inproceedings', 'Dean S. Hoskins, Renée C. Turnban, Charles J. Colbourn', 'Experimental designs in software engineering: d-optimal designs and covering arrays', 'Generation', '', '2004 ACM workshop on Interdisciplinary Software Engineering Research', 'WISER', '', '', '55-66', '', '10.1145/1029997.1030009', 'Combinatorial Testing', 'For over a century, Design of Experiment (DOE) techniques have been applied to testing in large problem domains such as agriculture, chemistry, medicine, and industrial design. Recently, the application of DOE has appeared in component-based software testing. This is a natural extension, as software testing is a complex problem that suffers from a combinatorial explosion. Exhaustive testing is not possible in most systems. In this paper, we focus on three areas: (1) the application of DOE techniques to software testing, (2) improved algorithms for screening tests involving categorical factors, and (3) construction methods for generating covering arrays', NULL);
INSERT INTO `list` VALUES (55, '0000-00-00', 2004, 'techreport', 'Mats Grindal, Birgitta Lindström, Jeff Offutt, Sten F. Andler', 'An Evaluation of Combination Strategies for Test Case Selection', 'Evaluation', '', '2004 Department of Computer Science, University of Skovde', 'Tech', '', 'HS-IDA-TR-03-001', '583–611', '', 'https://doi.org/10.1007/s10664-006-9024-2', 'Combinatorial Testing', 'This paper presents results from a comparative evaluation of five combination strategies. Combination strategies are test case selection methods that combine “interesting” values of the input parameters of a test subject to form test cases. This research comparatively evaluated five combination strategies; the All Combination strategy (AC), the Each Choice strategy (EC), the Base Choice strategy (BC), Orthogonal Arrays (OA) and the algorithm from the Automatic Efficient Test Generator (AETG). AC satisfies n-wise coverage, EC and BC satisfy 1-wise coverage, and OA and AETG satisfy pair-wise coverage. The All Combinations strategy was used as a “gold standard” strategy; it subsumes the others but is usually too expensive for practical use. The others were used in an experiment that used five programs seeded with 128 faults. The combination strategies were evaluated with respect to the number of test cases, the number of faults found, failure size, and number of decisions covered. The strategy that requires the least number of tests, Each Choice, found the smallest number of faults. Although the Base Choice strategy requires fewer test cases than Orthogonal Arrays and AETG, it found as many faults. Analysis also shows some properties of the combination strategies that appear significant. The two most important results are that the Each Choice strategy is unpredictable in terms of which faults will be revealed, possibly indicating that faults are found by chance, and that the Base Choice and the pair-wise combination strategies to some extent target different types of faults', NULL);
INSERT INTO `list` VALUES (58, '0000-00-00', 2004, 'inproceedings', 'Charles J. Colbourn, Myra B. Cohen, Renée C. Turnban', 'A Deterministic Density Algorithm for Pairwise Interaction Coverage', 'Generation', '', '2004 IASTED International Conference on Software Engineering', 'IASTED', '', '', '345-352', '', 'not found', 'Combinatorial Testing', 'Pairwise coverage of factors affecting software has been proposed to screen for potential errors. Techniques to generate test suites for pairwise coverage are evaluated according to many criteria. A small number of tests is a main criterion, as this dictates the time for test execution. Randomness has been exploited to search for small test suites, but variation occurs in the test suite produced. A worst-case guarantee on test suite size is desired; repeatable generation is often necessary. The time to construct the test suite is also important. Finally, testers must be able to include certain tests, and to exclude others. The main approaches to generating test suites for pairwise coverage are examined; these are exemplified by AETG, IPO, TCG, TConfig, simulated annealing, and combinatorial design techniques. A greedy variant of AETG and TCG is developed. It is deterministic, guaranteeing reproducibility. It generates only one candidate test at a time, providing faster test suite development. It is shown to provide a logarithmic worst-case guarantee on the test suite size. It permits users to “seed” the test suite with specified tests. Finally, comparisons with other greedy approaches demonstrate that it often yields the smallest test suite.', NULL);
INSERT INTO `list` VALUES (59, '0000-00-00', 2004, 'article', 'D. Richard Kuhn, Dolores R. Wallace', 'Software Fault Interactions and Implications for Software Testing', 'Evaluation', '', '2004 IEEE Transactions on Software Engineering', 'TSE', '30', '6', '418-421', '', '10.1109/TSE.2004.24', 'Combinatorial Testing', 'Exhaustive testing of computer software is intractable, but empirical studies of \r\nsoftware failures suggest that testing can in some cases be effectively exhaustive. Data \r\nreported in this study and others show that software failures in a variety of domains were \r\ncaused by combinations of relatively few conditions. These results have important \r\nimplications for testing. If all faults in a system can be triggered by a combination of n or \r\nfewer parameters, then testing all n-tuples of parameters is effectively equivalent to \r\nexhaustive testing, if software behavior is not dependent on complex event sequences and \r\nvariables have a small set of discrete values.', NULL);
INSERT INTO `list` VALUES (60, '0000-00-00', 2004, 'article', 'Ahmed M. Salem, Kamel Rekab, James A. Whittaker', 'Prediction of Software Failures through Logistic Regression', 'Evaluation', '', '2004 Information and Software Technology', 'IST', '46', '12', '781-789', '', '10.1016/j.infsof.2003.10.008', 'Combinatorial Testing', 'The quality of software has been a main concern since the inception of computer software. To be able to produce high quality software, software developers and software testers alike need continuous improvements in their developing and testing methodologies. These improvements should result in better coverage of the input domain, efficient test cases, and in spending fewer testing resources. In this paper we focus on an approach for generating efficient test cases based on the special properties of Design of Experiments and developing a logistic regression model of predicting test case outcomes. Design of Experiments will be utilized to efficiently minimize the number of test cases and the logistic regression model will be used to predict software failures. This approach, in turn, would provide the software tester with a model that reduces the number of test cases, predicts test case outcomes, reduces cost, and allows better forecast of release readiness. We demonstrate our approach using two case studies (TI Interactive software and Microsoft\'s Pocket PC operating system).', NULL);
INSERT INTO `list` VALUES (61, '0000-00-00', 2004, 'inproceedings', 'Toshiaki Shiba, Tatsuhiro Tsuchiya, Tohru Kikuno', 'Using Artificial Life Techniques to Generate Test Cases for Combinatorial Testing', 'Generation', 'Search Based', '2004 International Computers, Software & Applications Conference', 'COMPSAC', '', '', '72-78', '', '10.1109/CMPSAC.2004.1342808 \n', 'Combinatorial Testing', 'Filtering TOBIAS Combinatorial Test Suites', NULL);
INSERT INTO `list` VALUES (62, '0000-00-00', 2004, 'inproceedings', 'Yves Ledru, Lydie du Bousquet, Olivier Maury, Pierre Bontron', 'Filtering TOBIAS Combinatorial Test Suites', 'Application', '', '2004 International Conference on Fundamental Approaches to Software Engineering', 'ICFASE', '', '', '281-294', '', '10.1007/978-3-540-24721-0_21', 'Combinatorial Testing', 'TOBIAS is a combinatorial testing tool, aimed at the production of large test suites. In this paper, TOBIAS is applied to conformance tests for model-based specifications (expressed with assertions, pre and post-conditions) and associated implementations. The tool takes advantage of the executable character of VDM or JML assertions which provide an oracle for the testing process. Executing large test suites may require a lot of time. This paper shows how assertions can be exploited at generation time to filter the set of test cases, and at execution time to detect inconclusive test cases', NULL);
INSERT INTO `list` VALUES (63, '0000-00-00', 2004, 'inproceedings', 'Patrick J. Schroeder, Pankaj Bolaki, Vijayram Gopu', 'Comparing the Fault Detection Effectiveness of N-way and Random Test Suites', 'Evaluation', '', '2004 International Symposium on Empirical Software Engineering', 'ISESE', '', '', '49-59', '', '10.1109/ISESE.2004.1334893 \n', 'Combinatorial Testing', 'Software testing plays a critical role in the timely delivery of high-quality software systems. Despite the important role that testing plays, little is known about the fault detection effectiveness of many testing techniques. We investigate \"n-way\" test suites created using a common greedy algorithm for use in combinatorial testing. A controlled study is designed and executed to compare the fault detection effectiveness of n-way and random test suites. Combinatorial testing is conducted on target systems that have been injected with software faults. The results are that there is no significant difference in the fault detection effectiveness of n-way and random test suites for the applications studied. Analysis of the random test suite finds that they are very similar to n-way test suites from the perspective of the number of test data combinations covered. This result concurs with other hypothetical results that indicate little difference between n-way and random test suites. While we do not expect this result to apply in all combinatorial testing situations, we believe the result will lead to the design of better combinatorial test suites.', NULL);
INSERT INTO `list` VALUES (66, '0000-00-00', 2004, 'inproceedings', 'James Bach, Patrick J. Schroeder', 'Pairwise Testing - A Best Practice That Isn\'t', 'Evaluation', '', '2004 Pacific Northwest Software Quality Conference', 'PNSQC', '', '', '180-196', '', 'not found', 'Combinatorial Testing', 'Pairwise testing is a wildly popular approach to combinatorial testing problems. The number of \r\narticles and textbooks covering the topic continues to grow, as do the number of commercial and \r\nacademic courses that teach the technique. Despite the technique\'s popularity and its reputation \r\nas a best practice, we find the technique to be over promoted and poorly understood. In this \r\npaper, we define pairwise testing and review many of the studies conducted using pairwise \r\ntesting. Based on these studies and our experience with pairwise testing, we discuss weaknesses \r\nwe perceive in pairwise testing. Knowledge of the weaknesses of the pairwise testing technique, \r\nor of any testing technique, is essential if we are to apply the technique wisely. We conclude by \r\nre-stating the story of pairwise testing and by warning testers against blindly accepting best \r\npractices', NULL);
INSERT INTO `list` VALUES (67, '0000-00-00', 2004, 'phdthesis', 'Myra B. Cohen', 'Designing Test Suites for Software Interaction Testing', 'Generation', '', '2004 The University of Auckland', 'Phd', '', '', 'not found', '', 'not found', 'Combinatorial Testing', 'Testing is an expensive but essential part of any software project. Having the right\r\nmethods to detect faults is a primary factor for success in the software industry.\r\nComponent based systems are problematic because they are prone to unexpected\r\ninteraction faults, yet these may be left undetected by traditional testing techniques.\r\nIn all but the smallest of systems, it is not possible to test every component interaction. One can use a reduced test suite that guarantees to include a defined subset\r\nof interactions instead.\r\nA well studied combinatorial object, the covering array, can be used to achieve\r\nthis goal. Constructing covering arrays for a specific software system is not always\r\nsimple and the resulting object may not closely mirror the real test environment.\r\nNot only are new methods for building covering arrays needed, but new tools to\r\nsupport these are required as well. Our aim is to develop methods for building\r\nsmaller test suites that provide stronger interaction coverage, while retaining the\r\nflexibility required in a practical test suite. We combine ideas from combinatorial\r\ndesign theory, computational search, statistical design of experiments and software\r\nengineering.\r\nWe begin with a description of a framework for greedy algorithms that has formed\r\nthe basis for several published methods and a widely used commercial tool. We\r\ncompare this with a meta-heuristic search algorithm, simulated annealing. The\r\nresults suggest that simulated annealing is more effective at finding smaller test\r\nsuites, and in some cases improves on combinatorial methods as well.\r\nWe then develop a mathematical model for variable strength interaction testing.\r\niii\r\nThis allows us to balance the cost and the time of testing by targeting individual\r\nsubsets of components. We present construction techniques using meta-heuristic\r\nsearch and provide the first known bounds for objects of this type.\r\nWe end by presenting some new cut-and-paste techniques that merge recursive\r\ncombinatorial constructions with computational search via a process we term augmented annealing. This method leverages the computational efficiency and optimality of size obtained through combinatorial constructions while benefiting from the\r\ngenerality of a meta-heuristic search. We present examples of specific constructions\r\nand provide new bounds for strength three covering arrays. The results presented\r\nprovide the foundations for an interaction testing toolkit.', NULL);
INSERT INTO `list` VALUES (68, '0000-00-00', 2005, 'article', 'C.M. Lott, Aridaman Jain, Siddhartha R. Dalal', 'Modeling Requirements for Combinatorial Software Testing', 'Model', '', '2005 ACM SIGSOFT Software Engineering Notes', 'SIGSOFT ', '30', '4', '1--7', '', '10.1145/1082983.1083281 ', 'Combinatorial Testing', 'The combinatorial approach to software testing uses models to generate a minimal number of test inputs so that selected combinations of input values are covered. The most common coverage criteria is two-way, or pairwise coverage of value combinations, though for higher confidence three-way or higher coverage may be required. This paper presents example system requirements and corresponding models for applying the combinatorial approach to those requirements. These examples are intended to serve as a tutorial for applying the combinatorial approach to software testing. Although this paper focuses on pairwise coverage, the discussion is equally valid when higher coverage criteria such as three-way (triples) are used. We use terminology and modeling notation from the AETG1 system to provide concrete examples.', NULL);
INSERT INTO `list` VALUES (69, '0000-00-00', 2005, 'article', 'Renée C. Bryce, Charles J. Colbourn', 'Test Prioritization for Pairwise Interaction Coverage', 'Optimization', 'Priority', '2005 ACM SIGSOFT Software Engineering Notes', 'SIGSOFT ', '30', '4', '1--7', '', '10.1145/1083274.1083275 ', 'Combinatorial Testing', 'Interaction testing is widely used in screening for faults. In software testing, it provides a natural mechanism for testing systems to be deployed on a variety of hardware and software configurations. Several algorithms published in the literature are used as tools to automatically generate these test suites; AETG is a well known example of a family of greedy algorithms that generate one test at a time. In many applications where interaction testing is needed, the entire test suite is not run as a result of time or cost constraints. In these situations, it is essential to prioritize the tests. Here we adapt a \"one-test-at-a-time\" greedy method to take importance of pairs into account. The method can be used to generate a set of tests in order, so that when run to completion all pairwise interactions are tested, but when terminated after any intermediate number of tests, those deemed most important are tested. Computational results on the method are reported.', NULL);
INSERT INTO `list` VALUES (70, '0000-00-00', 2005, 'inproceedings', 'Renée C. Bryce, Charles J. Colbourn', 'Constructing Interaction Test Suites with Greedy Algorithms', 'Generation', '', '2005 International Conference on Automated Software Engineering', 'ASE', '', '', '440-443', '', '10.1145/1101908.1101994', 'Combinatorial Testing', 'Combinatorial approaches to testing are used in several fields, and have recently gained momentum in the field of software testing through software interaction testing. One-test-at-a-time greedy algorithms are used to automatically construct such test suites. This paper discusses basic criteria of why greedy algorithms have been appropriate for this test generation problem in the past and then expands upon how greedy algorithms can be utilized to address test suite prioritization.', NULL);
INSERT INTO `list` VALUES (71, '0000-00-00', 2005, 'inproceedings', 'Liang Shi, Changhai Nie, Baowen Xu', 'A Software Debugging Method Based on Pairwise Testing', 'Diagnosis', '', '2005 International Conference on Computational Science', 'ICCS', '', '', '1088-1091', '', '10.1007/11428862_179 ', 'Combinatorial Testing', 'Pairwise testing is one of very practical and effective testing methods for various types of software systems. This paper proposes a novel debugging method based on pairwise testing. By analyzing the test cases and retesting with some complementary test cases, the method can narrow the factors that cause the errors in a very small range. So it can provide a very efficient and valuable guidance for the software testing and debugging. ', NULL);
INSERT INTO `list` VALUES (72, '0000-00-00', 2005, 'inproceedings', 'Renée C. Bryce', 'Automatic Generation of High Coverage Usability Tests', 'Generation', '', '2005 International Conference on Human Factors in Computing Systems', 'ICHFCS', '', '', '1108-1109', '', 'https://doi.org/10.1145/1056808.1056835', 'Combinatorial Testing', 'Software systems are often complex in the number of features that are available through the user interface and consequently, the number of interactions that can occur. Such systems are prone to errors when interactions do not work as anticipated. This research introduces a combinatorial method for setting up task-based usability tests. The method bridges contributions from mathematics, design of experiments, software test, and algorithms for application to usability testing. ', NULL);
INSERT INTO `list` VALUES (73, '0000-00-00', 2005, 'inproceedings', 'Kera Z. Bell, Mladen A. Vouk', 'On effectiveness of pairwise methodology for testing network-centric software', 'Application', '', '2005 International Conference on Information and Communications Technology', 'ICICT', '', '', '221-235', '', '10.1109/ITICT.2005.1609626 \n', 'Combinatorial Testing', 'Pairwise testing, which can be complemented with partial or full N-wise testing, is a technique which guarantees that all important parametric value pairs are included in a test suite. A percentage of N-wise testing is also included. We conjecture that N-wise enhanced pairwise testing can be used as a black-boxed testing method to increase effectiveness of random testing in exposing unusual or unexpected behaviors, such as security failures in network-centric software. This testing can also be quite cost-efficient since small N test suites grow linearly with the number of parameters. This paper explains the results of random testing of a simulation in which about 20% of the defects with probabilities of occurrence less than 50% are never exposed. This supports the premise that if the unusual or unexpected behaviors are based on defects which are less likely to occur, then random testing needs to be enhanced, especially if those unexposed defects could cause erratic or even critical behaviors to the system. Higher system complexities may indicate higher numbers of unusual or unexpected behaviors. It may be difficult to use the traditional operational profile information to determine the amount of testing for unusual behaviors since the operational usage may be 0 or close to it. Another interesting problem is that some testers lack the experience necessary to effectively analyze the results of a test run. It is important to compensate for the lack of experience so that novice testers are able to test comparatively as effectively as more experienced testers. It is believed that if the size of the test suite is relatively small, then it may be easier to pinpoint the source of a failure. The research presented in this paper is aimed at addressing some of these issues of random testing via enhanced pairwise testing and N-wise testing in general. It is possible that more complex systems, such as those that rely a great deal on a network, would require higher numbers of interactions to combat unexpected combinations for use in some testing instances such as security testing or high assurance testing. A tool is being developed concurrently to help automate a part of the test generation process.', NULL);
INSERT INTO `list` VALUES (74, '0000-00-00', 2005, 'inproceedings', 'Lei Xu, Baowen Xu, Changhai Nie', 'Testing and Fault Diagnosis for Web Application Compatibility Based on Combinatorial Method', 'Application', '', '2005 International Conference on Parallel and Distributed Processing and Applications, Workshops', 'PDPTA', '', '', '619-626', '', 'https://doi.org/10.1007/11576259_67', 'Combinatorial Testing', 'The testing and fault diagnosis for Web application compatibility are concerned with multiple kinds of software and hardware facilities, enormous numbers of equipments’ trademarks and types, and the combination of all the situations. How to test and find faults efficiently and quickly is a difficult and important task to complete. Combined with the characters of the Web application compatibility testing and the combinatorial method, we obtained acceptable number of test cases for the compatibility testing. After executing the test cases, we analyzed the results so as to find the fault factors by the properties of combinatorial method. Then we retested with some complementary test cases based on the elementary analytic results, and made further analysis and validation with the retesting results. Thus we obtained the factors that cause the errors in a very small range, and provided a very efficient and valuable guidance for the debugging and testing of Web application compatibility.', NULL);
INSERT INTO `list` VALUES (75, '0000-00-00', 2005, 'inproceedings', 'Renée C. Bryce, Charles J. Colbourn, Myra B. Cohen', 'A Framework of Greedy Methods for Constructing Interaction Test Suites', 'Generation', '', '2005 International conference on Software engineering', 'ICSE', '', '', '146-155', '', '\n10.1109/ICSE.2005.1553557 \n', 'Combinatorial Testing', 'Greedy algorithms for the construction of software interaction test suites are studied. A framework is developed to evaluate a large class of greedy methods that build suites one test at a time. Within this framework are many instantiations of greedy methods generalizing those in the literature. Greedy algorithms are popular when the time for test suite construction is of paramount concern. We focus on the size of the test suite produced by each instantiation. Experiments are analyzed using statistical techniques to determine the importance of the implementation decisions within the framework. This framework provides a platform for optimizing the accuracy and speed of \"one-test-at-a-time\" greedy methods.', NULL);
INSERT INTO `list` VALUES (76, '0000-00-00', 2005, 'inproceedings', 'Soumen Maity, Amiya Nayak', 'Improved Test Generation Algorithms for Pair-Wise Testing', 'Generation', '', '2005 International Symposium on Software Reliability Engineering', 'ISSRE', '', '', '235–244', '', '10.1109/ISSRE.2005.23', 'Combinatorial Testing', 'Software Performance Testing using Covering Arrays: Efficient Screening Designs with Categorical Factors', NULL);
INSERT INTO `list` VALUES (77, '0000-00-00', 2005, 'inproceedings', 'Charles J. Colbourn, Yinong Chen, Wei-Tek Tsai', 'Progressive Ranking and Composition of Web Services Using Covering Arrays', 'Application', '', '2005 International Workshop on Object-Oriented Real-Time Dependable Systems', 'WORDS', '', '', '179-185', '', '10.1109/WORDS.2005.47 ', 'Combinatorial Testing', 'Major computer companies and government agencies are adopting Web services (WS) technology. Web services must ensure interoperability and security, and be reliable and trustworthy. Consumers must make runtime decisions based on an intelligent and unbiased evaluation. We propose one component of a test suite generator to address this critical issue. The goal is to transform the labor-intensive software development process into a largely automated Web services development process. The method operates within a service-oriented architecture, with the models and tools implemented as services that can be added, removed and replaced at runtime. We propose a generic greedy algorithm based on covering arrays for application in this environment.', NULL);
INSERT INTO `list` VALUES (78, '0000-00-00', 2005, 'inproceedings', 'Dean S. Hoskins, Charles J. Colbourn, Douglas C. Montgomery', 'Software Performance Testing using Covering Arrays: Efficient Screening Designs with Categorical Factors', 'Generation', '', '2005 International Workshop on Software and Performance', 'IWSP', '', '', '131-136', '', '10.1145/1071021.1071034', 'Combinatorial Testing', 'Automatic Test Generation for N-way Combinatorial Testing', NULL);
INSERT INTO `list` VALUES (79, '0000-00-00', 2005, 'inproceedings', 'Changhai Nie, Baowen Xu, Liang Shi, Guowei Dong', 'Automatic Test Generation for N-way Combinatorial Testing', 'Generation', '', '2005 International Workshop on Software Quality', 'IWSQ', '', '', '20-22', '', ' 10.1007/11558569_15', 'Combinatorial Testing', 'n-way combinatorial testing is a specification-based testing criterion, which requires that for a system consisting of a few parameters, every combination of valid values of arbitrary n (n ≥ 2) parameters be covered by at least one test. In this paper, we propose two different tests generation algorithms based on the combinatorial design for the n-way combination testing. We show that the produced tests can cover all the combinations of parameters to the greatest degree with the small quantity. We implemented the automatic test generators based on the algorithms and obtained some valuable empirical results.', NULL);
INSERT INTO `list` VALUES (80, '0000-00-00', 2005, 'inproceedings', 'Brahim Hnich, Steven D. Prestwich, Evgeny Selensky', 'Constraint-Based Approaches to the Covering Test Problem', 'Generation', 'Constraint', '2005 Joint Annual Workshop of ERCIM/CoLogNet on Constraint Solving and Constraint Logic Programming', 'ERCIM', '', '', '199-219', '', '10.1007/s10601-006-7094-9\n', 'Combinatorial Testing', 'Covering arrays have been studied for their applications to drug screening and software and hardware testing. In this paper, we model the problem as a constraint program. Our proposed models ex- ploit non-binary (global) constraints, redundant modelling, channelling constraints, and symmetry breaking constraints. Our initial experiments show that with our best integrated model, we are able to either prove optimality of existing bounds or find new optimal values for arrays of moderate size. Local search on a SAT-encoding of the model is able to find improved bounds on larger problems.', NULL);
INSERT INTO `list` VALUES (83, '0000-00-00', 2005, 'article', 'Mats Grindal, Jeff Offutt, Sten F. Andler', 'Combination Testing Strategies: A Survey', 'Other', 'Survey', '2005 Software Testing, Verification and Reliability', 'STVR', '15', '3', '167-199', '', '10.1002/stvr.319 ', 'Combinatorial Testing', 'The National Software Reference Library (NSRL) of the U.S. National Institute of Standards and Technology (NIST) collects software from various sources and publishes file profiles computed from this software (such as MD5 and SHA-1 hashes) as a Reference Data Set (RDS) of information. The RDS can be used in the forensic examination of file systems, for example, to speed the process of identifying unknown or suspicious files. This paper describes the cross-platform, public domain, Linux/Apache/MySQL/Perl (LAMP) framework with which we produce the RDS from acquired software. The framework is easily deployed (it has been packaged on a Knoppix-based live CD) and allows for the distributed processing of large numbers of files in a loose, heterogeneous computing cluster. We go on to suggest that the framework is sufficiently general in its implementation to be suitable for application to classes of problems quite beyond our original scope.', NULL);
INSERT INTO `list` VALUES (84, '0000-00-00', 2006, 'article', 'Myra B. Cohen, Joshua Snyder, Gregg Rothermel', 'Testing Across Configurations: Implications for Combinatorial Testing', 'Evaluation', '', '2006 ACM SIGSOFT Software Engineering Notes', 'SIGSOFT ', '31', '6', '41-48', 'ACM', '10.1145/1218776.1218785', 'Combinatorial Testing', 'User configurable software systems allow users to customize functionality at run time. In essence, each such system consists of a family of potentially thousands or millions of program instantiations. Testing methods cannot test all of these configurations, therefore some sampling mechanism must be applied. A common approach to providing such a mechanism has been to use combinatorial interaction testing. To date, however, little work has been done to quantify the effects of different configurations on a test suites\' operation and effectiveness. In this paper we present a case study that investigates the effects of changing configurations on two types of test suites. Our results show that test coverage and fault detection effectiveness do not vary much across configurations for entire test suites; however, for individual test cases and certain types of faults, configurations matter.', NULL);
INSERT INTO `list` VALUES (85, '0000-00-00', 2006, 'phdthesis', 'Renée C. Turnban', 'Algorithms for Covering Arrays', 'Generation', '', '2006 Arizona State University', 'Phd', '', '', 'not found', '', 'not found', 'Combinatorial Testing', 'not found', NULL);
INSERT INTO `list` VALUES (86, '0000-00-00', 2006, 'inproceedings', 'Renée C. Bryce, Ajitha Rajan, Mats P.E. Heimdahl', 'Interaction Testing in Model-Based Development: Effect on Model-Coverage', 'Evaluation', '', '2006 Asia-Pacific Software Engineering Conference', 'APSEC', '', '', ' 259-268', '', '10.1109/APSEC.2006.42 ', 'Combinatorial Testing', 'Model-based software development is gaining interest in domains such as avionics, space, and automotives. The model serves as the central artifact for the development efforts (such as, code generation), therefore, it is crucial that the model be extensively validated. Automatic generation of interaction test suites is a candidate for partial automation of this model validation task. Interaction testing is a combinatorial approach that systematically tests all t-way combinations of inputs for a system. In this paper, we report how well interaction test suites (2-way through 5-way interaction test suites) structurally cover a model of the modelogic of a flight guidance system. We conducted experiments to (1) compare the coverage achieved with interaction test suites to that of randomly generated tests and (2) determine if interaction test suites improve the coverage of black-box test suites derived from system requirements. The experiments show that the interaction test suites provide little benefit over the randomly generated tests and do not improve coverage of the requirements-based tests. These findings raise questions on the application of interaction testing in this domain.', NULL);
INSERT INTO `list` VALUES (87, '0000-00-00', 2006, 'article', 'Brahim Hnich, Steven D. Prestwich, Evgeny Selensky, Barbara M. Smith', 'Constraint Models for the Covering Test Problem', 'Generation', 'Constraint', '2006 Constraints', 'CSTR', '11', '23', '199-219', '', '10.1007/s10601-006-7094-9\n', 'Combinatorial Testing', 'Covering arrays can be applied to the testing of software, hardware and\r\nadvanced materials, and to the effects of hormone interaction on gene expression. In\r\nthis paper we develop constraint programming models of the problem of finding an\r\noptimal covering array. Our models exploit global constraints, multiple viewpoints\r\nand symmetry-breaking constraints. We show that compound variables, representing tuples of variables in our original model, allow the constraints of this problem to\r\nbe represented more easily and hence propagate better. With our best integrated\r\nmodel, we are able to either prove the optimality of existing bounds or find new\r\noptimal solutions, for arrays of moderate size. Local search on a SAT-encoding of\r\nthe model is able to find improved solutions and bounds for larger problems.', NULL);
INSERT INTO `list` VALUES (88, '0000-00-00', 2006, 'article', 'Mats Grindal, Birgitta Lindström, Jeff Offutt, Sten F. Andler', 'An Evaluation of Combination Strategies for Test Case Selection', 'Evaluation', '', '2006 Empirical Software Engineering', 'EMSE', '11', '4', '583-611', '', '10.1007/s10664-006-9024-2', 'Combinatorial Testing', 'This paper presents results from a comparative evaluation of five combination strategies. Combination strategies are test case selection methods that combine “interesting” values of the input parameters of a test subject to form test cases. This research comparatively evaluated five combination strategies; the All Combination strategy (AC), the Each Choice strategy (EC), the Base Choice strategy (BC), Orthogonal Arrays (OA) and the algorithm from the Automatic Efficient Test Generator (AETG). AC satisfies n-wise coverage, EC and BC satisfy 1-wise coverage, and OA and AETG satisfy pair-wise coverage. The All Combinations strategy was used as a “gold standard” strategy; it subsumes the others but is usually too expensive for practical use. The others were used in an experiment that used five programs seeded with 128 faults. The combination strategies were evaluated with respect to the number of test cases, the number of faults found, failure size, and number of decisions covered. The strategy that requires the least number of tests, Each Choice, found the smallest number of faults. Although the Base Choice strategy requires fewer test cases than Orthogonal Arrays and AETG, it found as many faults. Analysis also shows some properties of the combination strategies that appear significant. The two most important results are that the Each Choice strategy is unpredictable in terms of which faults will be revealed, possibly indicating that faults are found by chance, and that the Base Choice and the pair-wise combination strategies to some extent target different types of faults.', NULL);
INSERT INTO `list` VALUES (90, '0000-00-00', 2006, 'article', 'Cemal Yilmaz, Myra B. Cohen, Adam Porter', 'Covering Arrays for Efficient Fault Characterization in Complex Configuration Spaces', 'Diagnosis', '', '2006 IEEE Transactions on Software Engineering', 'TSE', '32', '1', '20-34', '', '\n10.1109/TSE.2006.8 ', 'Combinatorial Testing', 'Backtracking Algorithms and Search Heuristics to Generate Test Suites for Combinatorial Testing', NULL);
INSERT INTO `list` VALUES (91, '0000-00-00', 2006, 'inproceedings', 'D. Richard Kuhn, Vadim Okun', 'Pseudo-Exhaustive Testing for Software', 'Application', '', '2006 IEEE/NASA Software Engineering Workshop', 'SEW', '', '', '153-158', '', ' 10.1109/SEW.2006.26', 'Combinatorial Testing', 'Pseudo-exhaustive testing uses the empirical observation \r\nthat, for broad classes of software, a fault is likely triggered by only a few variables interacting. The method \r\ntakes advantage of two relatively recent advances in software engineering: algorithms for efficiently generating \r\ncovering arrays to represent software interaction test \r\nsuites, and automated generation of test oracles using \r\nmodel checking. An experiment with a module of the Traffic Collision Avoidance System (TCAS) illustrates the approach testing pairwise through 6-way interactions. We \r\nalso outline current and future work applying the test \r\nmethodology to a large real-world application, the Personal Identity Verification (PIV) smart card. ', NULL);
INSERT INTO `list` VALUES (92, '0000-00-00', 2006, 'article', 'Renée C. Bryce, Charles J. Colbourn', 'Prioritized Interaction Testing for Pair-wise Coverage with Seeding and Constraints', 'Generation', 'Constraint, Priority', '2006 Information and Software Technology', 'IST', '48', '10', ' 960-970', '', 'https://doi.org/10.1016/j.infsof.2006.03.004', 'Combinatorial Testing', 'Interaction testing is widely used in screening for faults. In software testing, it provides a natural mechanism for testing systems to be deployed on a variety of hardware and software configurations. In many applications where interaction testing is needed, the entire test suite is not run as a result of time or budget constraints. In these situations, it is essential to prioritize the tests. Here, we adapt a “one-test-at-a-time” greedy method to take importance of pairs into account. The method can be used to generate a set of tests in order, so that when run to completion all pair-wise interactions are tested, but when terminated after any intermediate number of tests, those deemed most important are tested. In addition, practical concerns of seeding and avoids are addressed. Computational results are reported.', NULL);
INSERT INTO `list` VALUES (93, '0000-00-00', 2006, 'inproceedings', 'Jun Yan, Jian Zhang', 'Backtracking Algorithms and Search Heuristics to Generate Test Suites for Combinatorial Testing', 'Generation', 'Search Based', '2006 International Computers, Software & Applications Conference', 'COMPSAC', '', '', '17-21', '', '10.1109/COMPSAC.2006.33 ', 'Combinatorial Testing', 'Combinatorial covering arrays have been used in several testing approaches. This paper first discusses some existing methods for finding such arrays. Then a SAT-based approach and a backtracking search algorithm are presented to solve the problem. A novel pruning strategy called SCEH is proposed to increase the efficiency of the methods. Several existing search heuristics and symmetry breaking techniques are also used in the backtracking search algorithm. Lastly, this paper introduces a tool called EXACT (exhaustive search of combinatorial test suites) which implements all the above techniques to construct the covering arrays automatically. The experimental results show that our backtracking search method outperforms other methods in many small size cases', NULL);
INSERT INTO `list` VALUES (94, '0000-00-00', 2006, 'inproceedings', 'Changhai Nie, Baowen Xu, Ziyuan Wang, Liang Shi', 'Generating optimal test set for neighbor factors combinatorial testing', 'Generation', '', '2006 International Conference on Quality Software', 'QSIC', '', '', '26-28 ', '', '10.1109/QSIC.2006.31', 'Combinatorial Testing', 'Pair-wise testing is a practical and effective method to test the software with a test suite that covers all pair-wise combinations of parameter values; much research has been aimed at the test suite generation In this paper, we present a new heuristic for the test suite generation based on solution space tree model, in which each usable test data is represented as a path and all the usable test data form a tree, called solution space tree, then the test suite generation is to search a subset of paths by using depth-first search from the tree We have implemented this method as a tool, and the result shows that it has good merits and can be a complement of the existed methods and tools.', NULL);
INSERT INTO `list` VALUES (95, '0000-00-00', 2006, 'inproceedings', 'Changhai Nie, Baowen Xu, Liang Shi, Ziyuan Wang', 'A New Heuristic for Test Suite Generation for Pair-wise Testing', 'Generation', '', '2006 International Conference on Software Engineering and Knowledge Engineering', 'SEKE', '', '', '517-521', '', 'not found', 'Combinatorial Testing', 'Pair-wise testing is a practical and effective method to test the software with a test suite that covers all pair-wise combinations of parameter values; much research has been aimed at the test suite generation In this paper, we present a new heuristic for the test suite generation based on solution space tree model, in which each usable test data is represented as a path and all the usable test data form a tree, called solution space tree, then the test suite generation is to search a subset of paths by using depth-first search from the tree We have implemented this method as a tool, and the result shows that it has good merits and can be a complement of the existed methods and tools.', NULL);
INSERT INTO `list` VALUES (96, '0000-00-00', 2006, 'inproceedings', 'Myra B. Cohen, Matthew B. Dwyer, Jiangfan Shi', 'Coverage and Adequacy in Software Product Line Testing', 'Application', 'Software Product Line', '2006 Internationl workshop on Role of software architecture for testing and analysis', 'ROSATEA', '', '', '53-63', '', 'https://doi.org/10.1145/1147249.1147257', 'Combinatorial Testing', 'Software product line modeling has received a great deal of attention for its potential in fostering reuse of software artifacts across development phases. Research on the testing phase, has focused on identifying the potential for reuse of test cases across product line instances. While this offers potential reductions in test development effort for a given product line instance, it does not focus on and leverage the fundamental abstraction that is inherent in software product lines - variability.In this paper, we illustrate how rich software product line modeling notations can be mapped onto an underlying relational model that captures variability in the feasible product line instances. This relational model serves as the semantic basis for defining a family of coverage criteria for testing of a product line. These criteria make it possible to accumulate test coverage information for the product line itself over the course of multiple product line instance development efforts. Cumulative coverage, in turn, enables targeted testing efforts for new product line instances. We describe how combinatorial interaction testing methods can be applied to define test configurations that achieve a desired level of coverage and identify challenges to scaling such methods to large, complex software product lines.', NULL);
INSERT INTO `list` VALUES (97, '0000-00-00', 2006, 'inproceedings', 'Jacek Czerwonka', 'Pairwise Testing in Real World: Practical Extensions to Test Case Generator', 'Generation', 'Tool, Constraint', '2006 Pacific Northwest Software Quality Conference', 'PNSQC', '', '', '419-430', '', 'not found', 'Combinatorial Testing', 'Pairwise testing has become an indispensable tool in a software tester’s toolbox. The technique has been known for almost twenty years [22] but it is the last five years that we have seen a tremendous increase in its popularity. Information on at least 20 tools that can generate pairwise test cases, have so far been published [1]. Most tools, however, lack practical features necessary for them to be used in industry. This paper pays special attention to usability of the pairwise testing technique. In particular, it does not describe any radically new method of efficient generation of pairwise test suites, a topic that has already been researched extensively, neither does it refer to any specific case studies or results obtained through this method of test case generation. It does focus on ways in which pure pairwise testing approach needs to be modified to become practically applicable and on features tools need to offer to support a tester trying to use pairwise in practice. The paper makes frequent references to PICT, an existing and publicly available tool built on top of a flexible combinatorial test case generation engine, which implements several of the concepts described herein', NULL);
INSERT INTO `list` VALUES (98, '0000-00-00', 2006, 'techreport', 'Mats Grindal, Jeff Offutt, Jonas Mellin', 'Handling Constraints in the Input Space when Using Combination Strategies for Software Testing', 'Generation', 'Constraint', '2006 School of Humanities and Informatics', 'Tech', '', 'HS-IKI-TR-06-01', 'not found', '', 'not found', 'Combinatorial Testing', 'This study compares seven different methods for handling constraints in input parameter mod-els when using combination strategies to select test cases. Combination strategies are used to select test cases based on input parameter models. An input parameter model is a representation of the input space of the system under test via a set of parameters and values for these parameters. A test case is one specific combination of values for all the parameters. Sometimes the input parameter model may contain parameters that are not independent. Some sub-combinations of values of the dependent parameters may not be valid, i.e., these sub-combinations do not make sense. Combination strategies, in their basic forms, do not take into account any semantic information. Thus, invalid sub-combinations may be included in test cases in the test suite. This paper proposes four new constraint handling methods and compares these with three existing methods in an experiment in which the seven constraint handling methods are used to handle a number of different constraints in different sized input parameter models under three different coverage criteria. All in all, 2568 test suites with a total of 634263 test cases have been generated within the scope of this experiment.', NULL);
INSERT INTO `list` VALUES (99, '0000-00-00', 2006, 'phdthesis', 'Latifa Zekaoui', 'Mixed Covering Arrays On Graphs and Tabu Search Algorithms', 'Generation', 'Search Based', '2006 University of Ottawa', 'Phd', '', '', 'not found', '', 'not found', 'Combinatorial Testing', 'Mixed covering arrays on graphs and tabu search algorithms Latifa Zekaoui, Master’s 2006 Ottawa-Carleton Institute for Computer Science University of Ottawa Covering arrays are combinatorial objects that have been successfully applied in the design of test suits for testing software, networks and circuits. Mixed covering arrays on graphs are new generalizations of both mixed covering arrays and covering arrays on graphs. In this thesis, we give new theoretical results and constructions for mixed covering arrays on graphs. First, we extend to the mixed case the work done by Meagher and Stevens [31], which uses graph homomorphisms for covering arrays on graphs. Second, we study covering arrays on special classes of graphs. In particular, we solve to optimality the case in which G is a tree, a cycle or a bipartite graph, as well as give results for wheels and cubic graphs. We also provide general graph operations that preserve the size of a balanced covering array. In the second part of the thesis, we do a complete experimental study of two tabu search algorithms for covering array construction. POT is a variation of the algorithm given by Stardom [40] while PAT is an implementation of the algorithm proposed by Nurmela [35]. We conclude that they provide effective methods for constructing covering arrays of moderate size. In particular, POT and PAT improve upper bounds for 18 sets of parameters for covering arrays', NULL);
INSERT INTO `list` VALUES (100, '0000-00-00', 2007, 'article', 'Krishnan Rangarajan, S. Murali Krishna, P. Siva Nandhan', 'Combinatorial Testing: Learnings from our Experience', 'Application', '', '2007 ACM SIGSOFT Software Engineering Notes', 'SIGSOFT ', '32', '3', '1--8', '', '10.1145/1241572.1241582', 'Combinatorial Testing', 'Combinatorial testing methods address generation of test cases for problems involving multiple parameters and combinations. The Orthogonal Array Based Testing Strategy (OATS) is one such combinatorial testing method, a systematic, statistical way of testing pair-wise interactions. It provides representative (uniformly distributed) coverage of all variable pair combinations. This makes the technique particularly useful for testing of software, wherever there is combinatorial explosion: a. In system testing for handling feature interactions b. In integration testing components c. It is also quite useful for testing products with a large number of configuration possibilities.\r\n\r\nOne of the fundamental assumptions behind OATS approach is that a subset covering all pair-wise combinations will be more effective than a randomly selected subset. OATS provides a means to select a minimal test set that guarantees testing the pair-wise combinations of all the selected variables. Covering pair-wise combinations has been reported to be very effective in the literature. Successful use of this technique, with 50% effort saving and improved testing with a factor of 2.6 is reported in the literature.\r\n\r\nIn this paper, we report on the in-house web-based application that we designed and implemented to support customized version of OATS and our experience in piloting and getting this method used in projects. In the in-house tool we have introduced a number of additional features, that help in generation and post processing of test-cases. We have also designed a supporting process for using this method, and we discuss the steps in this process in the paper. We share details on application in feature testing of a mobile phone application. This method has also been successfully used in designing feature interaction test cases and for augmenting the regression suite to increase coverage.', NULL);
INSERT INTO `list` VALUES (101, '0000-00-00', 2007, 'inproceedings', 'Renée C. Bryce, Charles J. Colbourn', 'One-Test-at-a-Time Heuristic Search for Interaction Test Suites', 'Generation', 'Search Based', '2007 Annual conference on Genetic and evolutionary computation', 'GECCO', '', '', '1082-1089', '', '10.1145/1276958.1277173 ', 'Combinatorial Testing', 'Algorithms for the construction of software interaction test suites have focussed on the special case of pairwise coverage; less is known about efficiently constructing test suites for higher strength coverage. The combinatorial growth of t-tuples associated with higher strength hinders the efficacy of interaction testing. Test suites are inherently large, so testers may not run entire test suites. To address these problems, we combine a simple greedy algorithmallwith heuristic search to construct and dispense one test at a time. Our algorithm attempts to maximize the number of t-tuples covered by the earliest tests so that if a tester only runs a partial test suite, they test as many t-tuples as possible.allHeuristic search is shown to provide effective methods for achieving such coverage.', NULL);
INSERT INTO `list` VALUES (102, '0000-00-00', 2007, 'inproceedings', 'Mats Grindal, Jeff Offutt, Jonas Mellin', 'Managing Conflicts when Using Combination Strategies to Test Software', 'Generation', 'Constraint', '2007 Australian Software Engineering Conference ', 'ASWEC', '', '', '255-264', '', '10.1109/ASWEC.2007.27 ', 'Combinatorial Testing', 'Testers often represent systems under test in input parameter models. These contain parameters with associated values. Combinations of parameter values, with one value for each parameter, are potential test cases. In most models, some values of two or more parameters cannot be combined. Testers must then detect and avoid or remove these conflicts. This paper proposes two new methods for automatically handling such conflicts and compares these with two existing methods, based on the sizes of the final conflict-free test suites. A test suite reduction method, usable with three of the four investigated methods is also included in the study, resulting in seven studied conflict handling methods. In the experiment, the number and types of conflicts, as well as the size of the input parameter model and the coverage criterion used, are varied. All in all, 3854 test suites with a total of 929,158 test cases were generated. Two methods stand out as tractable and complementary. The best method (called the avoid methods) with respect to test suite size is to avoid selection of test cases with conflicts. However, this method cannot always be used. The second best method (called the replace method), removing conflicts from the final test suite, is completely general.', NULL);
INSERT INTO `list` VALUES (105, '0000-00-00', 2007, 'inproceedings', 'Renée C. Bryce, Atif M. Memon', 'Test Suite Prioritization by Interaction Coverage', 'Optimization', 'Priority', '2007 Domain-Specific Approaches to Software Test Automation Workshop', 'DSASTA', '', '', '1--7', '', ' 10.1145/1294921.1294922 ', 'Combinatorial Testing', 'Event-driven software (EDS) is a widely used class of software that takes sequences of events as input, changes state, and outputs new event sequences. Managing the size of tests suites for EDS is difficult as the number of event combinations and sequences grow exponentially with the number of events. We propose a new testing technique that extends software interaction testing. Traditional software interaction testing systematically examines all t-way interactions of parameters for a program. This paper extends the notion to t-way interactions over sequences of events. The technique applies to many classes of software; we focus on that of EDS. As a proof-of-concept, we prioritize existing test suites for four GUI-based programs by t-way interaction coverage. We compare the rate of fault detection with that of several other prioritization criteria. Results show that prioritization by interaction coverage has the fastest rate of fault detection in half of our experiments, making the most impact when tests have high interaction coverage.', NULL);
INSERT INTO `list` VALUES (106, '0000-00-00', 2007, 'article', 'Yves Ledru, Lydie du Bousquet, Frederic Dadeau, Faryel Alloutia', 'A Case Study in Matching Test and Proof Coverage', 'Application', '', '2007 Electronic Notes in Theoretical Computer Science', 'ENTCS', '190', '2', '73-84', '', ' 10.1016/j.entcs.2007.08.007 ', 'Combinatorial Testing', 'This paper studies the complementarity of test and deductive proof processes for Java programs specified in JML (Java Modeling Language). The proof of a program may be long and difficult, especially when automatic provers give up. When a theorem is not automatically proved, there are two possibilities: either the theorem is correct and there are not enough pieces of information to deal with the proof, or the theorem is incorrect. In order to discriminate between those two alternatives, testing techniques can be used. Here, we present experiments around the use of the JACK tool to prove Java programs annotated with JML assertions. When JACK fails to decide proof obligations, we use a combinatorial testing tool, TOBIAS, to produce large test suites that exercise the unproved program parts. The key issue is to establish the relevance of the test suite with respect to the unproved proof obligations. Therefore, we use code coverage techniques: our approach takes advantage of the statement orientation of the JACK tool to compare the statements involved in the unproved proof obligations and the statements covered by the test suite. Finally, we ensure our confidence within the test suites, by evaluating them on mutant program killing exercises. These techniques have been put into practice and are illustrated by a simple case study.', NULL);
INSERT INTO `list` VALUES (107, '0000-00-00', 2007, 'article', 'Frederic Dadeau, Yves Ledru, Lydie du Bousquet', 'Measuring a Java Test Suite Coverage Using JML Specifications', 'Evaluation', '', '2007 Electronic Notes in Theoretical Computer Science', 'ENTCS', '', '', '21-32', '', '10.1016/j.entcs.2007.08.003 ', 'Combinatorial Testing', 'We propose in this paper a way to measure the coverage of a Java test suite by considering the JML specification associed to the Java program under test. This approach is based on extracting a predicate-based graph from the JML method specifications. We then measure the coverage of this latter w.r.t. nodes of the graph that are visited by the test suite. In addition, we propose to check whether the test suite satisfies classical condition coverage criteria. We also introduce a tool, to be used as precompiler for Java, that is in charge of measuring and reporting the coverage according to these criteria.', NULL);
INSERT INTO `list` VALUES (108, '0000-00-00', 2007, 'inproceedings', 'Kamal Z. Zamli, Nor Ashidi M. Isa, Mohammed F.J. Klaib, Siti Norbaya Azizan', 'Designing a combinatorial Java unit testing tool', 'Application', 'Tool', '2007 IASTED International Conference on Advances in Computer Science and Technology', 'IASTED ', '', '', '153-158', '', 'not found', 'Combinatorial Testing', 'Software testing relates to the process of executing a program or system with the intent of finding errors. Covering as much as 40 to 50 percent of the development costs and resources, software testing is an integral part of the software development lifecycle. Despite its importance, current software testing practice lacks automation and is still primarily based on highly manual processes from the generation of test cases (i.e. from the specifications documents) up to the actual execution of the test. Although the emergence of helpful automated testing tools in the market is blooming, their adoptions are lacking as they do not adequately provide the right level of abstraction and automation required by test engineers.\r\n\r\nJTst is a Java based automated unit testing tool that addresses some of the aforementioned issues. The main novel features of JTst are the fact that it permits combinatorial test case generations as well as automated and concurrent execution of test cases for Java classes, enabling higher product quality at lower testing costs.', NULL);
INSERT INTO `list` VALUES (109, '0000-00-00', 2007, 'inproceedings', 'Mats Grindal, Jeff Offutt', 'Input Parameter Modeling for Combination Strategies', 'Model', '', '2007 IASTED International Conference on Software Engineering', 'IASTED ', '', '', '255-260', '', 'not found', 'Combinatorial Testing', 'Combination strategies are test methods that generate test cases based on input parameter models. This paper sug-gests a structured modeling method used to translate re-quirements expressed in a general format into an input pa-rameter model suitable for combination strategies. This paper also describes results from two initial ex-periments exploring the efficiency and effectiveness of the modeling method. These results indicate that the resulting models may contain enough information to detect the vast majority of faults in the system under test. Further, results indicate that the modeling method is simple enough to use in practical testing.', NULL);
INSERT INTO `list` VALUES (110, '0000-00-00', 2007, 'inproceedings', 'Yu Lei, Raghu N. Kacker, D. Richard Kuhn, Vadim Okun, James Lawrence', 'IPOG: A General Strategy for T-Way Software Testing', 'Generation', '', '2007 International Conference and Workshops on the Engineering of Computer-Based Systems', 'ECBS', '', '', '549-556', '', '10.1109/ECBS.2007.47 ', 'Combinatorial Testing', 'Most existing work on t-way testing has focused on 2-way (or pairwise) testing, which aims to detect faults caused by interactions between any two parameters. However, faults can also be caused by interactions involving more than two parameters. In this paper, we generalize an existing strategy, called in-parameter-order (IPO), from pairwise testing to t-way testing. A major challenge of our generalization effort is dealing with the combinatorial growth in the number of combinations of parameter values. We describe a t-way testing tool, called FireEye, and discuss design decisions that are made to enable an efficient implementation of the generalized IPO strategy. We also report several experiments that are designed to evaluate the effectiveness of FireEye', NULL);
INSERT INTO `list` VALUES (111, '0000-00-00', 2007, 'inproceedings', 'Yves Ledru, Frederic Dadeau, Lydie du Bousquet, Sébastien Ville, Elodie Rose', 'Mastering combinatorial explosion with the Tobias-2 test generator', 'Application', 'Tool', '2007 International conference on Automated software engineering', 'ASE', '', '', '535-536', '', '10.1145/1321631.1321731', 'Combinatorial Testing', 'This paper briefly describes the second version of the Tobias combinatorial test generator. This version improves the architecture of the tool to include filtering and test selection mechanisms. These mechanisms, associated with an efficient implementation, allow to generate and filter test suites of up to 1 million test cases.', NULL);
INSERT INTO `list` VALUES (112, '0000-00-00', 2007, 'inproceedings', 'Xun Yuan, Myra B. Cohen, Atif M. Memon', 'Covering array sampling of input event sequences for automated GUI testing', 'Generation', 'Sequence CA', '2007 International Conference on Automated Software Engineering ', 'ASE', '', '', '405-408', '', ' 10.1145/1321631.1321695 ', 'Combinatorial Testing', 'This paper describes a new automated technique to generate test cases for GUIs by using covering arrays (CAs). The key motivation is to generate long GUI event sequences that are systematically sampled at a particular coverage strength. CAs, to date, have not been effectively used in sampling event driven systems such as GUIs which maintain state. We leverage a \"stateless\" abstraction of GUIs that allows us to use CAs. Once the CAs have been generated, we reuse the abstractions to reinsert ordering relationships between GUI events, thereby creating executable test cases. A feasibility study on a well-studied GUI-based application shows that the new technique is able to detect a large number of previously undetected faults', NULL);
INSERT INTO `list` VALUES (113, '0000-00-00', 2007, 'inproceedings', 'Xiao Qu, Myra B. Cohen, Katherine M. Woolf', 'Combinatorial Interaction Regression Testing: A Study of Test Case Generation and Prioritization', 'Generation', '', '2007 International Conference on Software Maintenance', 'ICSM', '', '', '255-264', '', '10.1109/ICSM.2007.4362638', 'Combinatorial Testing', 'Regression testing is an expensive part of the software maintenance process. Effective regression testing techniques select and order (or prioritize) test cases between successive releases of a program. However, selection and prioritization are dependent on the quality of the initial test suite. An effective and cost efficient test generation technique is combinatorial interaction testing, CIT, which systematically samples all t-way combinations of input parameters. Research on CIT, to date, has focused on single version software systems. There has been little work that empirically assesses the use of CIT test generation as the basis for selection or prioritization. In this paper we examine the effectiveness of CIT across multiple versions of two software subjects. Our results show that CIT performs well in finding seeded faults when compared with an exhaustive test set. We examine several CIT prioritization techniques and compare them with a re-generation/prioritization technique. We find that prioritized and re-generated/prioritized CIT test suites may find faults earlier than unordered CIT test suites, although the re-generated/prioritized test suites sometimes exhibit decreased fault detection.', NULL);
INSERT INTO `list` VALUES (114, '0000-00-00', 2007, 'inproceedings', 'Myra B. Cohen, Matthew B. Dwyer, Jiangfan Shi', 'Interaction Testing of Highly-Configurable Systems in the Presence of Constraints', 'Generation', 'Constraint', '2007 International Symposium on Software Testing and Analysis', 'ISSTA', '', '', '129-139', '', ' 10.1145/1273463.1273482 ', 'Combinatorial Testing', 'Combinatorial interaction testing (CIT) is a method to sample configurations of a software system systematically for testing. Many algorithms have been developed that create CIT samples, however few have considered the practical concerns that arise when adding constraints between combinations of options. In this paper, we survey constraint handling techniques in existing algorithms and discuss the challenges that they present. We examine two highly-configurable software systems to quantify the nature of constraints in real systems. We then present a general constraint representation and solving technique that can be integrated with existing CIT algorithms and compare two constraint-enhanced algorithm implementations with existing CIT tools to demonstrate feasibility.', NULL);
INSERT INTO `list` VALUES (115, '0000-00-00', 2007, 'inproceedings', 'Frederic Dadeau, Yves Ledru, Lydie du Bousquet', 'Directed Random Reduction of Combinatorial Test Suites', 'Optimization', 'Reduction', '2007 International Workshop on Random Testing', 'RT', '', '', '18-25', '', '10.1145/1292414.1292421', 'Combinatorial Testing', 'Combinatorial testing consists in generating (possibly large) test suites by combining both the sequencing of several operations, and the selection of test data. The TOBIAS tool is based on this generation technique. The combinatorial part of the approach makes both its strength and its weakness. Indeed, the more tests are produced, the more confidence the user may have in his/her program. Nevertheless, simple patterns may result in millions of test cases due to the combinatorial explosion problem, leading to intractable testsuites. To overcome this weakness, TOBIAS makes it possible to connect the generator to \"selectors\" that choose a subset of the test suite based on various techniques or criteria.\r\n\r\nThis paper presents such a test suite reduction technique, based on a stochastic approach. The selection is improved so a uniform repartition of test cases is performed w.r.t. a given criterion, namely, an abstraction of the test cases based on their \"shape\". The approach is implemented into TOBIAS as a generic selector, independent of the system under test. It has been put into practice on a smart card case study, for which the results are reported in this paper.', NULL);
INSERT INTO `list` VALUES (116, '0000-00-00', 2007, 'inproceedings', 'Ziyuan Wang, Changhai Nie, Baowen Xu', 'Generating Combinatorial Test Suite for Interaction Relationship', 'Generation', '', '2007 International Workshop on Software Quality Assurance', 'SOQUA', '', '', '55-61', '', 'https://doi.org/10.1145/1295074.1295085', 'Combinatorial Testing', 'Combinatorial testing could detect the faults triggered by the interactions among factors in software. But in many cases, the pair-wise, N-way and even the variable strength combinatorial testing may lead test suite redundancy and fault detect ability decreasing, because these methods do not make sufficient consideration on the actual factors interaction. In this paper, a new interaction relationship based combinatorial testing model was proposed to cover the actual factor interactions in software by extending the conventional combinatorial testing model and IO relationship testing model. The new method may be more effectively than existed combinatorial testing methods without decrease of the fault detect ability. Furthermore, two test suite generation algorithms for interaction relationship based combinatorial testing were also presented. Finally, we compared our algorithms with some similar test generation algorithms in IO relationship testing model, and the experience result showed the advantage of our algorithms.', NULL);
INSERT INTO `list` VALUES (117, '0000-00-00', 2007, 'inproceedings', 'Sandro Fouche, Myra B. Cohen, Adam Porter', 'Towards incremental adaptive covering arrays', 'Generation', 'Adaptive CT', '2007 International Symposium on the Foundations of Software Engineering', 'FSE', '', '', '557-560', '', '10.1145/1287624.1287709 ', 'Combinatorial Testing', 'The increasing complexity of configurable software systems\r\ncreates a need for more intelligent sampling mechanisms\r\nto detect and locate failure-inducing dependencies between\r\nconfigurations. Prior work shows that test schedules based\r\non a mathematical object, called a covering array, can be\r\nused to detect and locate failures in combination with a classification tree analysis. This paper addresses limitations of\r\nthe earlier approach. First, the previous work requires developers to choose the covering array’s strength, even though\r\nthere is no scientific or historical basis for doing so. Second,\r\nif a single covering array is insufficient to classify specific\r\nfailures, the entire process must be rerun from scratch. To\r\naddress these issues, our new approach incrementally and\r\nadaptively builds covering array schedules. It begins with\r\na low strength, and continually increases this as resources\r\nallow, or poor classification results require. At each stage,\r\nprevious tests are reused. This allows failures due to only\r\none or two configurations settings to be found and classified\r\nas early as possible, and also limits duplication of work when\r\nmultiple covering arrays must be used.', NULL);
INSERT INTO `list` VALUES (118, '0000-00-00', 2007, 'article', 'Renée C. Bryce, Yinong Chen, Charles J. Colbourn', 'Biased covering arrays for progressive ranking and composition of Web Services', 'Application', '', '2007 Journal of Simulation and Process Modelling', 'IJSPM', '3', '4', '80-87', '', '10.1109/WORDS.2005.47', 'Combinatorial Testing', 'Service-oriented computing is a new software development paradigm that allows application builders to choose from many available services. The challenges are to efficiently determine which services are the most appropriate to combine into an application based on concerns such as functionalities, licensing costs, and known reliability. Group testing has addressed some issues on how to select a small subset of candidate services. We expand upon the group testing methodology with a greedy algorithm that generates biased covering arrays for interactive testing of the services selected by group testing.', NULL);
INSERT INTO `list` VALUES (119, '0000-00-00', 2007, 'inproceedings', 'Myra B. Cohen, Matthew B. Dwyer, Jiangfan Shi', 'Exploiting Constraint Solving History to Construct Interaction Test Suites', 'Generation', 'Constraint', '2007 Proceedings of the Testing: Academic and Industrial Conference Practice and Research Techniques', 'TAICPART', '', '', '121-132', '', '10.1109/TAIC.PART.2007.17 ', 'Combinatorial Testing', 'Researchers have explored the application of combinatorial interaction testing (CIT) methods to construct samples to drive systematic testing of software system configurations. Applying CIT to highly-configurable software systems is complicated by the fact that, in many such systems, there are constraints between specific configuration parameters that render certain combinations invalid. In recent work, automated constraint solving methods have been combined with search-based CIT methods to address this problem with promising results. In this paper, we observe that the pattern of computation in greedy CIT algorithms leads to sequences of constraint solving problems that are closely related to one another. We propose two techniques for exploiting the history of constraint solving: (1) using incremental algorithms that are present within available constraint solvers and (2) mining constraint solver data structures to extract information that can be used to reduce the CIT search space. We evaluate the cost-effectiveness of these reductions on four real-world highly-configurable software systems and on a population of synthetic examples that share the characteristics of those four systems. In combination our techniques reduce the cost of CIT in the presence of constraints to that of traditional unconstrained CIT methods without sacrificing the quality of solutions.', NULL);
INSERT INTO `list` VALUES (120, '0000-00-00', 2007, 'article', 'Yu Lei, Richard H. Carver, Raghu N. Kacker, David Kung', 'A combinatorial testing strategy for concurrent programs', 'Application', '', '2007 Software Testing, Verification and Reliability', 'STVR', '17', '4', '207-225', '', '10.1002/stvr.369', 'Combinatorial Testing', 'One approach to testing concurrent programs is called reachability testing, which derives test sequences automatically and on-the-fly, without constructing a static model. Existing reachability testing algorithms are exhaustive in that they are intended to exercise all possible synchronization sequences of a concurrent program with a given input. In this paper, we present a new testing strategy, called t-way reachability testing, that adopts the dynamic framework of reachability testing but selectively exercises a subset of synchronization sequences. The selection of the synchronization sequences is based on a combinatorial testing strategy called t-way testing. We present an algorithm that implements t-way reachability testing, and report the results of several case studies that were conducted to evaluate its effectiveness. The results indicate that t-way reachability testing can substantially reduce the number of synchronization sequences exercised during reachability testing while still effectively detecting faults. Copyright © 2007 John Wiley & Sons, Ltd.', NULL);
INSERT INTO `list` VALUES (121, '0000-00-00', 2007, 'article', 'Renée C. Bryce, Charles J. Colbourn', 'The Density Algorithm for Pairwise Interaction Testing', 'Generation', '', '2007 Software Testing, Verification and Reliability', 'STVR', '17', '3', '159-182', '', ' 10.1002/stvr.365', 'Combinatorial Testing', 'There are many published algorithms for generating interaction test suites for software testing, exemplified by AETG, IPO, TCG, TConfig, simulated annealing and other heuristic search, and combinatorial design techniques. Among these, greedy one-test-at-a-time methods (such as AETG and TCG) have proven to be a reasonable compromise between the needs for small test suites, fast test-suite generation, and flexibility to accommodate a variety of testing scenarios. However, such methods suffer from the lack of a worst-case logarithmic guarantee on test suite size, while methods that provide such a guarantee at present are less efficient or flexible, or do not produce test suites that are competitive in size for practical testing scenarios. In this paper, a new algorithm establishes that efficient, greedy, one-test-at-a-time methods can indeed produce a logarithmic worst-case guarantee on the test suite size. In addition, this can be done while still producing test suites that are of competitive size, and in a time that is comparable to the published methods. It is deterministic, guaranteeing reproducibility. It generates only one candidate test at a time, permits users to ‘seed’ the test suite with specified tests, and allows users to specify constraints of combinations that should be avoided. Further, statistical analysis examines the impact of five variables used to tune this density algorithm for execution time and test suite size: weighting of density for factors, scaling of density, tie-breaking, use of multiple candidates, and multiple repetitions using randomization. Copyright © 2007 John Wiley & Sons, Ltd.', NULL);
INSERT INTO `list` VALUES (122, '0000-00-00', 2007, 'phdthesis', 'Mats Grindal', 'Handling Combinatorial Explosion in Software Testing', 'Application', '', '2007 University of Linköping', 'Phd', '', '', 'not found', '', 'not found', 'Combinatorial Testing', 'In this thesis, the overall conclusion is that combination strategies, (i.e., test case selection methods that manage the combinatorial explosion of possible things to test), can improve the softwa ... ', NULL);
INSERT INTO `list` VALUES (124, '0000-00-00', 2008, 'inproceedings', 'Andrea Calvagna, Angelo Gargantini', 'Using SRI SAL model checker for combinatorial tests generation in the presence of temporal constraints', 'Generation', 'Constraint', '2008 AFM Automated Formal Methods - workshop of CAV', 'AFM ', '', '', '1--10', '', 'not found', 'Combinatorial Testing', 'In this paper we describe an approach to use formal analysis tools in conjunction with traditional testing to improve the efficiency of the test generation process. We have developed a technique for the construction of combinatorial test suites, featuring expressive constraints over the models under test and cross coverage evaluation between multiple coverage criteria: combinatorial, structural and fault based. Our approach is tightly integrated with formal logic, since it uses formal logic to specify the system inputs (including the constraints), test predicates to formalize testing as a logic problem, and applies the SAL model checker tool to solve it, and hence to generate combinatorial test suites. Early results of experimental assessment are presented, supported by a prototype tool implementation.', NULL);
INSERT INTO `list` VALUES (125, '0000-00-00', 2008, 'inproceedings', 'Mohammad F.J. Klaib, Kamal Z. Zamli, Nor Ashidi M. Isa, Mohammed I. Younis, Rusli Abdullah', 'G2Way A Backtracking Strategy for Pairwise Test Data Generation', 'Generation', '', '2008 Asia-Pacific Software Engineering Conference', 'APSEC', '', '', '463-370', '', '10.1109/APSEC.2008.49 ', 'Combinatorial Testing', 'Our continuous dependencies on software (i.e. to assist as well as facilitate our daily chores) often raise dependability issue particularly when software is being employed harsh and life threatening or (safety) critical applications. Here, rigorous software testing becomes immensely important. Many combinations of possible input parameters, hardware/software environments, and system conditions need to be tested and verified against for conformance. Due to resource constraints as well as time and costing factors, considering all exhaustive test possibilities would be impossible (i.e. due to combinatorial explosion problem). Earlier work suggests that pairwise sampling strategy (i.e. based on two-way parameter interaction) can be effective. Building and complementing earlier work, this paper discusses an efficient pairwise test data generation strategy, called G2Way. In doing so, this paper demonstrates the correctness of G2Way as well as compares its effectiveness against existing strategies including AETG and its variations, IPO, SA, GA, ACA, and All Pairs. Empirical evidences demonstrate that G2Way, in some cases, outperformed other strategies in terms of the number of generated test data within reasonable execution time.', NULL);
INSERT INTO `list` VALUES (126, '0000-00-00', 2008, 'article', 'D. Richard Kuhn, Raghu N. Kacker, Yu Lei', 'Automated Combinatorial Test Methods: Beyond Pairwise Testing', 'Application', '', '2008 CrossTalk: Journal of Defense Software Engineering', 'APSEC', '21', '6', '22-26', '', 'not found', 'Combinatorial Testing', 'Pairwise testing has become a popular approach to software quality assurance because it often provides effective error detection at low cost. However, pairwise (2-way) coverage is not sufficient for assurance of mission-critical software. Combinatorial testing beyond pairwise is rarely used because good algorithms have not been available for complex combinations such as 3- way, 4-way, or more. In addition, significantly more tests are required for combinations beyond pairwise testing, and testers must determine expected results for each set of inputs. This article introduces new tools for automating the production of complete test cases covering up to 6-way combinations.', NULL);
INSERT INTO `list` VALUES (130, '0000-00-00', 2008, 'article', 'D. Richard Kuhn, Yu Lei, Raghu N. Kacker', 'Practical combinatorial testing: beyond pairwise', 'Application', '', '2008 IEEE Computer', 'Computer', '10', '3', '19-23', '', '10.1109/MITP.2008.54 ', 'Combinatorial Testing', 'With new algorithms and tools, developers can apply high-strength combinatorial testing to detect elusive failures that occur only when multiple components interact. In pairwise testing, all possible pairs of parameter values are covered by at least one test, and good tools are available to generate arrays with the value pairs. In the past few years, advances in covering-array algorithms, integrated with model checking or other testing approaches, have made it practical to extend combinatorial testing beyond pairwise tests. The US National Institute of Standards and Technology (NIST) and the University of Texas, Arlington, are now distributing freely available methods and tools for constructing large t-way combination test sets (known as covering arrays), converting covering arrays into executable tests, and automatically generating test oracles using model checking (http://csrc.nist.gov/acts). In this review, we focus on real-world problems and empirical results from applying these methods and tools.', NULL);
INSERT INTO `list` VALUES (131, '0000-00-00', 2008, 'article', 'Myra B. Cohen, Matthew B. Dwyer, Jiangfan Shi', 'Constructing Interaction Test Suites for Highly-Configurable Systems in the Presence of Constraints: A Greedy Approach', 'Generation', 'Constraint', '2008 IEEE Transactions on Software Engineering', 'TSE', '34', '5', '633-650', '', '10.1109/TSE.2008.50', 'Combinatorial Testing', 'Researchers have explored the application of combinatorial interaction testing (CIT) methods to construct samples to drive systematic testing of software system configurations. Applying CIT to highly-configurable software systems is complicated by the fact that, in many such systems, there are constraints between specific configuration parameters that render certain combinations invalid. Many CIT algorithms lack a mechanism to avoid these. In recent work, automated constraint solving methods have been combined with search-based CIT construction methods to address the constraint problem with promising results. However, these techniques can incur a non-trivial overhead. In this paper, we build upon our previous work to develop a family of greedy CIT sample generation algorithms that exploit calculations made by modern Boolean satisfiability (SAT) solvers to prune the search space of the CIT problem. We perform a comparative evaluation of the cost-effectiveness of these algorithms on four real-world highly-configurable software systems and on a population of synthetic examples that share the characteristics of those systems. In combination our techniques reduce the cost of CIT in the presence of constraints to 30 percent of the cost of widely-used unconstrained CIT methods without sacrificing the quality of the solutions.', NULL);
INSERT INTO `list` VALUES (132, '0000-00-00', 2008, 'inproceedings', 'Michael Ellims, Darrel Ince, Marian Petre', 'The Effectiveness of T-Way Test Data Generation', 'Evaluation', '', '2008 International Conference on Computer Safety, Reliability, and Security', 'SAFECOMP', '', '', '16-29', '', '10.1007/978-3-540-87698-4_5', 'Combinatorial Testing', 'This paper reports the results of a study comparing the effectiveness of automatically generated tests constructed using random and t-way combinatorial techniques on safety related industrial code using mutation adequacy criteria. A reference point is provided by hand generated test vectors constructed during development to establish minimum acceptance criteria. The study shows that 2-way testing is not adequate measured by mutants kill rate compared with hand generated test set of similar size, but that higher factor t-way test sets can perform at least as well. To reduce the computation overhead of testing large numbers of vectors over large numbers of mutants a staged optimising approach to applying t-way tests is proposed and evaluated which shows improvements in execution time and final test set size', NULL);
INSERT INTO `list` VALUES (133, '0000-00-00', 2008, 'inproceedings', 'Chengying Mao', 'Performing Combinatorial Testing on Web Service-Based Software', 'Application', '', '2008 International Conference on Computer Science and Software Engineering ', 'CSASE', '', '', '755-758', '', '10.1109/CSSE.2008.1284', 'Combinatorial Testing', 'Although Web service-based software (WSBS) possesses a lot of merits such as loose coupling and good interoperability, its some new characters also bring challenges to latter maintenance activities inevitably. In the paper, we proposed a combinatorial testing framework for the WSBS, which mainly includes test cases generation and knowledge-based debugging. For the former, naive method and ldquogreedy+backtrackingrdquo method are addressed in detail. At the stage of debugging, rough set reasoning is adopted to generate association rules, which can help maintainers to locate faults in the WSBS by using dynamic slicing technology. In addition, the feasibility and effectiveness of our approach is validated by some working examples and experiments.', NULL);
INSERT INTO `list` VALUES (134, '0000-00-00', 2008, 'inproceedings', 'Vincent C. Hu, D. Richard Kuhn, Tao Xie', 'Property Verification for Generic Access Control Models', 'Application', '', '2008 International Conference on Embedded and Ubiquitous Computing', 'EUC', '', '', '243-250', '', '10.1109/EUC.2008.22', 'Combinatorial Testing', 'To formally and precisely capture the security properties that access control should adhere to, access control models are usually written to bridge the rather wide gap in abstraction between policies and mechanisms. In this paper, we propose a new general approach for property verification for access control models. The approach defines a standardized structure for access control models, providing for both property verification and automated generation of test cases. The approach expresses access control models in the specification language of a model checker and expresses generic access control properties in the property language. Then the approach uses the model checker to verify these properties for the access control models and generates test cases via combinatorial covering array for the system implementations of the models.', NULL);
INSERT INTO `list` VALUES (135, '0000-00-00', 2008, 'inproceedings', 'Wenhua Wang, Sreedevi Sampath, Yu Lei, Raghu N. Kacker', 'An Interaction-Based Test Sequence Generation Approach for Testing Web Application', 'Generation', 'Sequence CA', '2008 International Conference on High Assurance Systems Engineerng', 'HASE', '', '', '209-218', '', '10.1109/HASE.2008.53 ', 'Combinatorial Testing', 'Web applications often use dynamic pages that interact with each other by accessing shared objects, e.g., session objects. Interactions between dynamic pages need to be carefully tested, as they may give rise to subtle faults that cannot be detected by testing individual pages in isolation. Since it is impractical to test all possible interactions, a trade-off must be made between test coverage (in terms of number of interactions covered in the tests) and test effort. In this paper, we present a test sequence generation approach to cover all pairwise interactions, i.e., interactions between any two pages. Intuitively, if a page P could reach another page Ppsila, there must exist a test sequence in which both P and Ppsila are visited in the given order. We report a test sequence generation algorithm and two case studies in which test sequences are generated to achieve pairwise interaction coverage for two Web applications. The empirical results indicate that our approach achieves good code coverage and is effective for detecting interaction faults in the subject applications.', NULL);
INSERT INTO `list` VALUES (136, '0000-00-00', 2008, 'inproceedings', 'Sergiy Vilkomir, W. Thomas Swain, Jesse H. Poore', 'Combinatorial test case selection with Markovian usage models', 'Generation', '', '2008 International Conference on Information Technology: New Generations', 'ITNG', '', '', '3--8', '', '10.1109/ITNG.2008.80', 'Combinatorial Testing', 'A method of using Markov chain techniques for combinatorial test case selection is presented. The method can be used for statistical and coverage testing of many software programs, in particular for scientific computational software. The central point of the approach is modeling of dependencies between input parameters. Several different types of such dependencies are considered and models for each situation are created. Based on these models, test cases can be automatically generated and executed. Results of using the JUMBL tool for analyzing models and generating test cases are described.', NULL);
INSERT INTO `list` VALUES (137, '0000-00-00', 2008, 'inproceedings', 'Ziyuan Wang, Baowen Xu, Changhai Nie', 'Greedy Heuristic Algorithms to Generate Variable Strength Combinatorial Test Suite', 'Generation', '', '2008 International Conference on Quality Software', 'QSIC', '', '', '155-160', '', '10.1109/QSIC.2008.52', 'Combinatorial Testing', 'Combinatorial testing is a practical software testing approach that has been widely used in practice. Most research and applications of such approach focus on N-way combinatorial testing that provides a minimum coverage of all N-way interactions among factor. However, the strengths of different interactions may not be a fixed integer N, but a variable. Therefore, variable strength combinatorial testing approach is necessary in applications. Existing variable strength combinatorial testing, which allows some interactions have a higher strength than others, has a limitation that such higher-strength interactions must be disjoint. To avoid such a limitation, an improved variable strength combinatorial testing approach, which makes a more sufficient consideration on actual interaction relationship, is proposed in this article. Furthermore, two greedy heuristic algorithms are also proposed to generate combinatorial test suite. Compared to some existing algorithms and tools, the proposed algorithms have advantages on both the execution effectiveness and the optimality of generated test suite. Experimental results can prove such advantages.', NULL);
INSERT INTO `list` VALUES (138, '0000-00-00', 2008, 'inproceedings', 'Shin Kimoto, Tatsuhiro Tsuchiya, Tohru Kikuno', 'Pairwise Testing in the Presence of Configuration Change Cost', 'Optimization', 'Priority', '2008 International Conference on Secure System Integration and Reliability Improvement', 'ICSRS', '', '', '32-38', '', '10.1109/SSIRI.2008.27 ', 'Combinatorial Testing', 'Testing is an important but expensive part of software development. This paper discusses the minimization of testing cost in the presence of configuration change cost. By configuration change cost we mean the cost of configuration changes that occur in sequential testcase execution - the time and effort incurred in changing the configuration if the execution of two consecutive testcases requires different system configurations. To the best of our knowledge this problem has never been studied before. We tackle the problem in the context of pairwise testing, a well-known testing strategy for black box testing. This strategy requires that all possible pairs of input parameters be covered by at least one testcase. Extending a greedy algorithm, we develop two algorithms for constructing pairwise test suites of both small size and low configuration change cost.', NULL);
INSERT INTO `list` VALUES (139, '0000-00-00', 2008, 'inproceedings', 'Sreedevi Sampath, Renée C. Bryce, Gokulanand Viswanath, Vani Kandimalla, A. Gunes Koru', 'Prioritizing User-Session-Based Test Cases for Web Applications Testing', 'Optimization', 'Priority', '2008 International Conference on Software Testing, Verification and Validation', 'ICST', '', '', '141-150', '', '10.1109/ICST.2008.42', 'Combinatorial Testing', 'Web applications have rapidly become a critical part of business for many organizations. However, increased usage of Web applications has not been reciprocated with corresponding increases in reliability. Unique characteristics, such as quick turnaround time, coupled with growing popularity motivate the need for efficient and effective Web application testing strategies. In this paper, we propose several new test suite prioritization strategies for Web applications and examine whether these strategies can improve the rate of fault detection for three Web applications and their preexisting test suites. We prioritize test suites by test lengths, frequency of appearance of request sequences, and systematic coverage of parameter-values and their interactions. Experimental results show that the proposed prioritization criteria often improve the rate of fault detection of the test suites when compared to random ordering of test cases. In general, the best prioritization metrics either (1) consider frequency of appearance of sequences of requests or (2) systematically cover combinations of parameter-values as early as possible.', NULL);
INSERT INTO `list` VALUES (140, '0000-00-00', 2008, 'inproceedings', 'Andrea Calvagna, Angelo Gargantini', 'A Logic-Based Approach to Combinatorial Testing with Constraints', 'Generation', 'Constraint', '2008 International conference on Tests and proofs', 'TAP', '', '', '66-83', '', '10.1007/978-3-540-79124-9_6', 'Combinatorial Testing', 'Usage of combinatorial testing is wide spreading as an effective technique to reveal unintended feature interaction inside a given system. To this aim, test cases are constructed by combining tuples of assignments of the different input parameters, based on some effective combinatorial strategy. The most commonly used strategy is two-way (pairwise) coverage, requiring all combinations of valid assignments for all possible pairs of input parameters to be covered by at least one test case. In this paper a new heuristic strategy developed for the construction of pairwise covering test suites is presented, featuring a new approach to support expressive constraining over the input domain. Moreover, it allows the inclusion or exclusion of ad-hoc combinations of parameter bindings to let the user customize the test suite outcome. Our approach is tightly integrated with formal logic, since it uses test predicates to formalize combinatorial testing as a logic problem, and applies an external model checker tool to solve it. The proposed approach is supported by a prototype tool implementation, and early results of experimental assessment are also presented.', NULL);
INSERT INTO `list` VALUES (141, '0000-00-00', 2008, 'inproceedings', 'Zainal Hisham Che Soh, Syahrul A.C. Abdullah, Kamal Z. Zamli', 'A Parallelization Strategies of Test Suites Generation for t-way Combinatorial Interaction Testing', 'Generation', '', '2008 International Symposium on Information Technology', 'ISIT', '', '', '1--5', '', '10.1109/ITSIM.2008.4631571', 'Combinatorial Testing', 'This paper proposed a few parallelization strategies for test suite generation for the combinatorial interaction testing using IBM’s TSpaces implementation. Much existing work in this field makes use of sequential algorithms for generating interaction test suites for software testing, such as by AETG, IPO, TConfig, IPOG, DDA, simulated annealing and other heuristic search. The TSpaces implementation using Java language provide more powerful programming and deployment environment in term of portability and also greatly simplifies the parallelization using master-worker pattern as described here', NULL);
INSERT INTO `list` VALUES (142, '0000-00-00', 2008, 'inproceedings', 'Mohammed I. Younis, Kamal Z. Zamli, Nor Ashidi M. Isa', 'Generating pairwise combinatorial test set using artificial parameters and values', 'Generation', '', '2008 International Symposium on Information Technology', 'ISIT', '4', '', '1--8', '', '10.1109/ITSIM.2008.4632001', 'Combinatorial Testing', 'In order to meet market demands for quality software products, software engineers are increasingly under pressure to test more lines of codes. To maintain acceptable test coverage, software engineers need to consider a significantly large number of test set. Many combinations of possible input parameters, hardware/software environments, and system conditions need to be tested and verified against for conformance. Often, this results into combinatorial explosion problem (i.e. too many test data set too consider). Earlier work suggests that pairwise sampling strategy based on parameter interactions of variables can be effective. This paper discusses an efficient pairwise strategy, termed RA and ORA, that can systematically minimize the pairwise test set generated from higher order test parameters to lower order ones. In doing so, this paper demonstrates and compares the results against existing strategies including IRPS, IPO, GA, ACA, Jenny and All Pairs.', NULL);
INSERT INTO `list` VALUES (143, '0000-00-00', 2008, 'inproceedings', 'Xiao Qu, Myra B. Cohen, Gregg Rothermel', 'Configuration-aware regression testing: an empirical study of sampling and prioritization', 'Optimization', 'Priority', '2008 International Symposium on Software Testing and Analysis', 'ISSTA', '', '', '75-86', '', '10.1145/1390630.1390641', 'Combinatorial Testing', 'Configurable software lets users customize applications in many ways, and is becoming increasingly prevalent. Researchers have created techniques for testing configurable software, but to date, only a little research has addressed the problems of regression testing configurable systems as they evolve. Whereas problems such as selective retesting and test prioritization at the test case level have been extensively researched, these problems have rarely been considered at the configuration level. In this paper we address the problem of providing configuration-aware regression testing for evolving software systems. We use combinatorial interaction testing techniques to model and generate configuration samples for use in regression testing. We conduct an empirical study on a non-trivial evolving software system to measure the impact of configurations on testing effectiveness, and to compare the effectiveness of different configuration prioritization techniques on early fault detection during regression testing. Our results show that configurations can have a large impact on fault detection and that prioritization of configurations can be effective.', NULL);
INSERT INTO `list` VALUES (145, '0000-00-00', 2008, 'article', 'Michael Forbes, James Lawrence, Yu Lei, Raghu N. Kacker, D. Richard Kuhn', 'Refining the In-Parameter-Order Strategy for Constructing Covering Arrays', 'Generation', '', '2008 Journal of Research of the National Institute of Standards and Technology', 'NIST', '113', '5', '287-297', '', '10.6028/jres.113.022', 'Combinatorial Testing', 'Covering arrays are structures for wellrepresenting extremely large input spaces\r\nand are used to efficiently implement\r\nblackbox testing for software and hardware. This paper proposes refinements\r\nover the In-Parameter-Order strategy (for\r\narbitrary t). When constructing homogeneous-alphabet covering arrays, these\r\nrefinements reduce runtime in nearly all\r\ncases by a factor of more than 5 and in\r\nsome cases by factors as large as 280. This\r\ntrend is increasing with the number of\r\ncolumns in the covering array. Moreover,\r\nthe resulting covering arrays are about 5 %\r\nsmaller. Consequently, this new algorithm\r\nhas constructed many covering arrays that\r\nare the smallest in the literature. A heuristic variant of the algorithm sometimes produces comparably sized covering arrays\r\nwhile running significantly faster', NULL);
INSERT INTO `list` VALUES (147, '0000-00-00', 2008, 'article', 'Jun Yan, Jian Zhang', 'A backtracking search tool for constructing combinatorial test suites', 'Generation', 'Search Based', '2008 Journal of Systems and Software ', 'JSS', '81', '10', '1681-1693', '', '10.1016/j.jss.2008.02.034 ', 'Combinatorial Testing', 'Combinatorial testing is an important testing method. It requires the test cases to cover various combinations of parameters of the system under test. The test generation problem for combinatorial testing can be modeled as constructing a matrix which has certain properties. This paper first discusses two combinatorial testing criteria: covering array and orthogonal array, and then proposes a backtracking search algorithm to construct matrices satisfying them. Several search heuristics and symmetry breaking techniques are used to reduce the search time. This paper also introduces some techniques to generate large covering array instances from smaller ones. All the techniques have been implemented in a tool called EXACT (EXhaustive seArch of Combinatorial Test suites). A new optimal covering array is found by this tool.', NULL);
INSERT INTO `list` VALUES (148, '0000-00-00', 2008, 'incollection', 'Mohammed I. Younis, Kamal Z. Zamli, Nor Ashidi M. Isa', 'IRPS - An Efficient Test Data Generation Strategy for Pairwise Testing', 'Generation', '', '2008 Knowledge-Based Intelligent Information and Engineering Systems', 'Book', '', '', '493-500', 'Springer', '10.1007/978-3-540-85563-7_63 ', 'Combinatorial Testing', 'Software testing is an integral part of software engineering. Lack of testing often leads to disastrous consequences including loss of data, fortunes, and even lives. In order to ensure software reliability, many combinations of possible input parameters, hardware/software environments, and system configurations need to be tested and verified against for conformance. Due to costing factors as well as time to market constraints, considering all exhaustive test possibilities would be infeasible (i.e. due to combinatorial explosion problem). Earlier work suggests that pairwise sampling strategy (i.e. based on two-way parameter interaction) can be effective. Building and complementing earlier work, this paper discusses an efficient pairwise test data generation strategy, called IRPS. In doing so, IRPS is compared against existing strategies including AETG and its variations, IPO, SA, GA, ACA, and All Pairs. Empirical results demonstrate that IRPS strategy, in most cases, outperformed other strategies as far as the number of test data generated within reasonable time. ', NULL);
INSERT INTO `list` VALUES (149, '0000-00-00', 2008, 'inproceedings', 'Conrado Martínez, Lucia Moura, Daniel Panario, Brett Stevens', 'Algorithms to Locate Errors Using Covering Arrays', 'Diagnosis', '', '2008 Latin American conference on Theoretical informatics', 'LATIN', '', '', '504-519', '', '10.1007/978-3-540-78773-0_44', 'Combinatorial Testing', 'In this paper, we define error locating arrays (ELAs), which can be used to locate faulty interactions between parameters or components in a software system. We give constructions of ELAs based on covering arrays. Under certain assumptions on the structure of the faulty interactions, we design and analyse efficient algorithms that locate errors. Under the assumption of known “safe values”, our algorithm performs a number of tests that is polynomial in logk and d, where k is the number of parameters in the system and d is an upper bound on the number of faulty pairwise interactions. For the binary alphabet case, we provide an algorithm that does not require safe values and runs in expected polynomial time in logk whenever d ∈ O(loglogk).', NULL);
INSERT INTO `list` VALUES (150, '0000-00-00', 2008, 'inproceedings', 'Daniel Lopez-Escogido, Jose Torres-Jimenez, Eduardo Rodriguez-Tello, Nelson Rangel-Valdez', 'Strength Two Covering Arrays Construction Using a SAT Representation', 'Generation', '', '2008 Mexican International Conference on Artificial Intelligence', 'MICAI', '', '', '44-53', '', '10.1007/978-3-540-88636-5_4', 'Combinatorial Testing', 'According to the NIST report of 2002 there is a great potential to reduce the cost, and to increase the quality of the software developed in USA through the creation of automated tools that help in the software testing process. One alternative to improve the software testing process is the creation of tools that generate testing cases in an automatic way. Through the construction of Covering Arrays (CA) it is possible to obtain a minimum set of test cases with the maximum possibility of testing all the functionality of the developed software.\r\n\r\nIn this paper an approach to construct CA using the propositional satisfiability problem (SAT) is presented. The approach starts with the transformation of a CA instance into a non-conjunctive normal form (non-CNF) SAT instance. Then the SAT instance is solved through a non-CNF SAT solver, and finally the SAT solution is transformed into a CA solution. The main contributions of this work are: an efficient non-CNF SAT solver able to equals or improves previously reported results, and a simplified SAT representation to solve the CA problem.', NULL);
INSERT INTO `list` VALUES (151, '0000-00-00', 2008, 'article', 'Yu Lei, Raghu N. Kacker, D. Richard Kuhn, Vadim Okun, James Lawrence', 'IPOG/IPOG-D: efficient test generation for multi-way combinatorial testing', 'Generation', '', '2008 Software Testing, Verification and Reliability', 'STVR', '18', '3', '125-148', '', ' 10.1002/stvr.381', 'Combinatorial Testing', 'We present two strategies for multi-way testing (i.e., t-way testing with t > 2). The first strategy generalizes an existing strategy, called In-Parameter-Order, from pairwise testing to multi-way testing. This strategy requires all t-way combinations to be explicitly enumerated. When the number of t-way combinations is large, however, explicit enumeration can be prohibitive both in terms of the space for storing these combinations and the time needed to enumerate them. To alleviate this problem, the second strategy combines the first strategy with a recursive construction procedure to reduce the number of t-way combinations that have to be enumerated. Both strategies are deterministic, i.e., they always produce the same test set for the same system configuration. We describe a t-way testing tool called FireEye and provide both analytic and experimental evaluation of the two strategies.', NULL);
INSERT INTO `list` VALUES (152, '0000-00-00', 2009, 'inproceedings', 'Snezana Popovic, Ljubomir Lazic', 'Orthogonal array and virtualization as a method for configuration testing improvement', 'Application', '', '2009 1st Eastern European Regional Conference on the Engineering of Computer Based Systems', 'ECBS', '', '', '148-149', '', '10.1109/ECBS-EERC.2009.12', 'Combinatorial Testing', 'Combinatorial testing methods are often applied in cases of configuration testing. Good practice points to the simultaneous application of combinatorial testing and virtualization. Virtualization, in the process of testing, is based on setting the necessary environment to multiple virtual machines, which run on one computer or in smaller groups of computers, which are: reduce the cost of equipment and related resources, reduce the time required to manage the testing process, and favours raising removal of test infrastructure. Together, combinatorial testing and virtualization presents a practical approach to improving testing process, through the balancing of quality, cost and time.', NULL);
INSERT INTO `list` VALUES (153, '0000-00-00', 2009, 'inproceedings', 'Lixin Wang, Jingchao Chen, Renxia Wan', 'Building small combinatorial test suites via linear programming and input-output analysis', 'Generation', '', '2009 2nd International Conference on Modelling and Simulation', 'ANNSIM', '6', '', '79-83', '', 'not found', 'Combinatorial Testing', 'In combinatorial test, the number of test cases for software under test (SUT) increases exponentially as the number of input parameters or the number of entries for each parameter increases. It is difficult to verify all of the test cases. To obtain small combinatorial test suites, a new test suite generating method based on a linear programming (LP) is proposed in this paper. The method obtains LP objective function and constraints by a combinatorial cover-matrix. If LP has a huge number of constraints and variables, we simplify the LP to an acceptable number of constraints and variables by using the Input-Output relationships of the SUT. Therefore, the solving efficiency via LP can be improved significantly, and the generated combinatorial test suites can cover the Input-Output relationships, without losing the fault-detection capability. We verify that our method is effective by the experimental results.', NULL);
INSERT INTO `list` VALUES (154, '0000-00-00', 2009, 'inproceedings', 'Rajendra S. Sisodia, Vijaykumar Channakeshava', 'Combinatorial approach for automated platform diversity testing', 'Application', 'Software Product Line', '2009 4th International Conference on Software Engineering Advances', 'IARIA', '', '', '134-139', '', '10.1109/ICSEA.2009.28', 'Combinatorial Testing', 'In recent years, product line engineering has been used effectively in many industrial setups to create a large variety of products. One key aspect of product line engineering is to develop re-usable assets often referred to as a platform. Such software platforms are inherently complex due to requirements of providing diverse functionalities, thereby leading to combinatorial test data explosion problem while validating these platforms. In this paper, we present a combinatorial approach for testing varied features and data diversity present within the platform. The proposed solution effectively takes care of complex interdependencies among diversity features and generates only valid combinations for test scenario. We also developed a prototype tool based on our proposed approaches to automate the platform testing. As part of our case study, we have used our prototype to validate a software platform widely being used across Philips Medical Systems (PMS) products. Initial results confirm that our approach significantly improves the overall platform testing process by reducing testing effort and improve the quality of the platform by detecting all interaction faults.\r\n\r\n', NULL);
INSERT INTO `list` VALUES (155, '0000-00-00', 2009, 'inproceedings', 'Bellanov S. Apilli', 'Fault-based combinatorial testing of web services', 'Application', '', '2009 ACM SIGPLAN conference companion on Object oriented programming systems languages and applications', 'SIGPLAN', '', '', '731-732', '', '10.1145/1639950.1639987', 'Combinatorial Testing', 'The Internet houses diverse applications (i.e., banking, networking, etc.), commonly implemented as web services. Web services are flexible but can become complex, making it difficult to assure their quality. I propose fault-based combinatorial testing and compare its fault-detection capability to existing web service testing techniques. ', NULL);
INSERT INTO `list` VALUES (156, '0000-00-00', 2009, 'inproceedings', 'Xiang Chen, Qing Gu, Ang Li, Daoxu Chen', 'Variable Strength Interaction Testing with an Ant Colony System Approach', 'Generation', 'Search Based', '2009 Asia-Pacific Software Engineering Conference', 'ASPEC', '', '', '160-167', '', '10.1109/APSEC.2009.18', 'Combinatorial Testing', 'Interaction testing (also called combinatorial testing) is an cost-effective test generation technique in software testing. Most research work focuses on finding effective approaches to build optimal t-way interaction test suites. However, the strength of different factor sets may not be consistent due to the practical test requirements. To solve this problem, a variable strength combinatorial object and several approaches based on it have been proposed. These approaches include simulated annealing (SA) and greedy algorithms. SA starts with a large randomly generated test suite and then uses a binary search process to find the optimal solution. Although this approach often generates the minimal test suites, it is time consuming. Greedy algorithms avoid this shortcoming but the size of generated test suites is usually not as small as SA. In this paper, we propose a novel approach to generate variable strength interaction test suites (VSITs). In our approach, we adopt a one-test-at-a-time strategy to build final test suites. To generate a single test, we adopt ant colony system (ACS) strategy, an effective variant of ant colony optimization (ACO). In order to successfully adopt ACS, we formulize the solution space, the cost function and several heuristic settings in this framework. We also apply our approach to some typical inputs. Experimental results show the effectiveness of our approach especially compared to greedy algorithms and several existing tools.', NULL);
INSERT INTO `list` VALUES (160, '0000-00-00', 2009, 'inbook', 'Renée C. Bryce, Yu Lei, D. Richard Kuhn, Raghu N. Kacker', 'Combinatorial Testing', 'Other', 'Survey', '2009 Handbook of Research on Software Engineering and Productivity Technologies: Implications of Globalization', 'Book', '', '', 'not found', 'IGI Global', 'not found', 'Combinatorial Testing', 'not found', NULL);
INSERT INTO `list` VALUES (161, '0000-00-00', 2009, 'article', 'D. Richard Kuhn, Raghu N. Kacker, Yu Lei, Justin Hunter', 'Combinatorial Software Testing', 'Application', '', '2009 IEEE Computer', 'Computer', '42', '8', '94-96', '', '10.1109/MC.2009.253', 'Combinatorial Testing', 'Combinatorial testing can detect hard-to-find software faults more efficiently than manual test case selection methods. While the most basic form of combinatorial testing-pairwise-is well established, and adoption by software testing practitioners continues to increase, industry usage of these methods remains patchy at best. However, the additional training required is well worth the effort.', NULL);
INSERT INTO `list` VALUES (162, '0000-00-00', 2009, 'inproceedings', 'James D. McCaffrey', 'Generation of Pairwise Test Sets Using a Genetic Algorithm', 'Generation', 'Search Based', '2009 International Computers, Software & Applications Conference', 'COMPSAC', '', '', '626-631', '', '10.1109/COMPSAC.2009.91', 'Combinatorial Testing', 'Pairwise testing is a combinatorial technique used to reduce the number of test case inputs to a system in situations where exhaustive testing with all possible inputs is not possible or prohibitively expensive. Given a set of input parameters where each parameter can take on one of a discrete set of values, a pairwise test set consists of a collection of vectors which captures all possible combinations of pairs of parameter values. The generation of minimal pairwise test sets has been shown to be an NP-complete problem and there have been several deterministic algorithms published. This paper presents the results of an investigation of generating pairwise test sets using a genetic algorithm. Compared with published results for deterministic pairwise test set generation algorithms, the genetic algorithm approach produced test sets which were comparable or better in terms of test set size in 39 out of 40 cases. However, the genetic algorithm approach required longer processing time than deterministic approaches in all cases. The results demonstrate that the generation of pairwise test sets using a genetic algorithm is possible, and suggest that the approach may be practical and useful in certain testing scenarios.', NULL);
INSERT INTO `list` VALUES (163, '0000-00-00', 2009, 'inproceedings', 'Sergiy Vilkomir, W. Thomas Swain, Jesse H. Poore', 'Software Input Space Modeling with Constraints among Parameters', 'Model', 'Constraint', '2009 International Computers, Software & Applications Conference', 'COMPSAC', '', '', '136-141', '', '10.1109/COMPSAC.2009.27', 'Combinatorial Testing', 'This paper considers the task of software test case generation from a large space of values of input parameters. The purpose of the paper is to create a model of software input space with constraints among parameters to serve as a basis of testing. We suggest a procedure to create a directed graph model, where paths through the graph represent all valid (and only valid) input combinations. The procedure accommodates an arbitrary set of dependencies among parameters. It starts from a simple linear graph and sequentially modifies this graph for each dependency between parameters. Modifications include subgraph splitting and elimination of dead nodes and edges. A complete example of a system with six input parameters and five dependencies among them is presented to illustrate the application of the procedure. Applicability of the approach for different types of parameters and dependencies is addressed', NULL);
INSERT INTO `list` VALUES (164, '0000-00-00', 2009, 'inproceedings', 'Eduardo Rodriguez-Tello, Jose Torres-Jimenez', 'Memetic algorithms for constructing binary covering arrays of strength three', 'Generation', 'Search Based', '2009 International conference on Artificial evolution', 'EA', '', '', '86-97', '', '10.1007/978-3-642-14156-0_8', 'Combinatorial Testing', 'This paper presents a new Memetic Algorithm (MA) designed to compute near-optimal solutions for the covering array construction problem. It incorporates several distinguished features including an efficient heuristic to generate a good quality initial population, and a local search operator based on a fine tuned Simulated Annealing (SA) algorithm employing a carefully designed compound neighborhood. Its performance is investigated through extensive experimentation over well known benchmarks and compared with other state-of-the-art algorithms, showing improvements on some previous best-known results.', NULL);
INSERT INTO `list` VALUES (165, '0000-00-00', 2009, 'inproceedings', 'Xiang Chen, Qing Gu, Xinping Wang, Ang Li, Daoxu Chen', 'A Hybrid Approach to Build Prioritized Pairwise Interaction Test Suites', 'Optimization', 'Priority', '2009 International Conference on Computational Intelligence and Software Engineering', 'CISE', '', '', '1--4', '', '10.1109/CISE.2009.5365886', 'Combinatorial Testing', 'Traditional interaction testing aims to build test suites that cover all t-way interactions of inputs. But in many test scenarios, the entire test suites cannot be fully run due to the limited budget. Therefore it is necessary to take the importance of interactions into account and prioritize these tests of the test suite. In the paper, we use the hybrid approach to build prioritized pairwise interaction test suites (PITS). It adopts a one-test-at-a-time strategy to construct final test suites. But to generate a single test it firstly generates a candidate test and then applies a specific metaheuristic search strategy to enhance this test. Here we experiment four different metaheuristic search strategies. In the experiments, we compare our approach to weighted density algorithm (WDA). Meanwhile, we also analyze the effectiveness of four different search strategies and the effectiveness of the increasing iterations. Empirical results demonstrate the effectiveness of our proposed approach. Keywords-prioritized interaction test suites; greedy algorithm; metaheuristic search', NULL);
INSERT INTO `list` VALUES (166, '0000-00-00', 2009, 'inproceedings', 'Chengying Mao', 'A specification-based testing framework for web service-based software', 'Application', '', '2009 International Conference on Granular Computing', 'GrC', '', '', '440-441', '', '10.1109/GRC.2009.5255083', 'Combinatorial Testing', 'As a rapidly emerging technology, Web services offer a brand-new mechanism for program-to-program interactions over the Internet. Inevitably, this programming pattern brings great challenge to the improvement of the quality and reliability of Web services. In the paper, a two-level testing framework for WSBS is proposed through deeply analyzing the architecture of WSBS and black-box character of Web service unit. In service unit level, combinatorial testing method is used to ensure single service\'s reliability through extracting interface information from WSDL file. In system level, BPEL specification is converted into state diagram at first, and then state transition-based test cases generation algorithm is presented. In addition, the feasibility and effectiveness of our approach is validated by some examples.', NULL);
INSERT INTO `list` VALUES (167, '0000-00-00', 2009, 'inproceedings', 'Kamal Z. Zamli, Mohammad F.J. Klaib, Mohammed I. Younis, Noor S. Jusof', 'A Deterministic T-Way Strategy for Test Data Minimization', 'Optimization', 'Reduction', '2009 International Conference on IT to Celebrate S. Charmonman\'s 72nd Birthday', 'other', '', '', '36.1-36.9', '', 'not found', 'Combinatorial Testing', 'In order to meet market demands for quality software products, software engineers are increasingly under pressure to test more lines of codes. To maintain acceptable test coverage, software engineers need to consider a significantly large number of test cases. Many combinations of possible input parameters, hardware/software environments, and system conditions need to be tested and verified against for conformance based on the system’s specification. Often, this results into combinatorial explosion of test cases. While earlier work has indicated that pairwise testing (i.e. based on 2-way interaction of variables) can be effective to detect most faults in a typical software system, a counter argument suggests such conclusion cannot be generalized to all software system faults. In some system, faults may also be caused by the interaction of more than two parameters (i.e. t-way). In order to address some of these issues, this paper discusses a novel strategy, called GTWay. Utilizing two main algorithms (i.e. the t-way pair generation algorithm and the backtracking algorithm respectively) as its basis, we demonstrate the efficiency and correctness of GTWay for t-way test data minimization. Keywordst-way Testing, Software Engineering', NULL);
INSERT INTO `list` VALUES (168, '0000-00-00', 2009, 'inproceedings', 'Xiang Chen, Qing Gu, Xin Zhang, Daoxu Chen', 'Building Prioritized Pairwise Interaction Test Suites with Ant Colony Optimization', 'Generation', 'Search Based, Priority', '2009 International Conference on Quality Software', 'QSIC', '', '', '347-352', '', '10.1109/QSIC.2009.52', 'Combinatorial Testing', 'Interaction testing offers a stable cost-benefit ratio in identifying faults. But in many testing scenarios, the entire test suite cannot be fully executed due to limited time or cost. In these situations, it is essential to take the importance of interactions into account and prioritize these tests. To tackle this issue, the biased covering array is proposed and the Weighted Density Algorithm (WDA) is developed. To find a better solution, in this paper we adopt ant colony optimization (ACO) to build this prioritized pairwise interaction test suite (PITS). In our research, we propose four concrete test generation algorithms based on Ant System, Ant System with Elitist, Ant Colony System and Max-Min Ant System respectively. We also implement these algorithms and apply them to two typical inputs and report experimental results. The results show the effectiveness of these algorithms.', NULL);
INSERT INTO `list` VALUES (169, '0000-00-00', 2009, 'inproceedings', 'Xiao Qu', 'Configuration aware prioritization techniques in regression testing (doctor symposium)', 'Optimization', 'Priority', '2009 International Conference on Software Engineering', 'ICSE', '', '', '375-378', '', '10.1109/ICSE-COMPANION.2009.5071025', 'Combinatorial Testing', 'Configurable software lets users customize applications in many ways, and is becoming increasingly prevalent. Regression testing is an important but expensive way to build confidence that software changes introduce no new faults as software evolves, resulting in many attempts to improve its performance given limited resources. Whereas problems such as test selection and prioritization at the test case level have been extensively researched in the regression testing literature, they have rarely been considered for configurations, though there is evidence that we should not ignore the effects of configurations on regression testing. This research intends to provide a framework for configuration aware prioritization techniques, evaluated through empirical studies.', NULL);
INSERT INTO `list` VALUES (170, '0000-00-00', 2009, 'inproceedings', 'James D. McCaffrey, Jacek Czerwonka', 'An Empirical Study of the Effectiveness of Pairwise Testing', 'Evaluation', '', '2009 International Conference on Software Engineering Research & Practice', 'SERP', '', '', '186-191', '', 'not found', 'Combinatorial Testing', 'For moistening a water roller in contact with a planographic printing plate on a plate cylinder in an offset printing press, a sprayer produces a more or less flat spray of dampening water. Baffles are positioned in front of the sprayer to define an aperture through which the spray travels before hitting the water roller. The aperture has a width shorter than the longer dimension of the cross section of the spray as measured in a plane containing the aperture, and longer than the shorter dimension of the cross section of the spray in the same plane. Thus the rate at which the dampening water is supplied to the water roller is infinitely variable by changing the angular position of the spray relative to the aperture between a minimum dampening position where the spray has the opposite longitudinal end portions of its cross section interrupted to the utmost by the baffle means and a maximum dampening position where the spray is allowed wholly through the aperture. In practice a series of rotary sprayers may be arranged along the axis of the water roller.', NULL);
INSERT INTO `list` VALUES (171, '0000-00-00', 2009, 'inproceedings', 'Chengying Mao', 'Towards a hierarchical testing and evaluation strategy for web services system', 'Application', '', '2009 International Conference on Software Engineering Research, Management and Applications', 'SERA', '', '', '245-252', '', '10.1109/SERA.2009.27', 'Combinatorial Testing', 'Web services can be combined in a collaborative way to create a new Web services system (WSS) to solve more complex problems. However, WSS testing is not a trivial task, features like distribution, loose-coupling, and collaboration bring great pressure to the latter testing activity. In the paper, a hierarchical testing and evaluation strategy is proposed from the perspective of the developers of Web services system. In service unit level, combinatorial testing method is used to ensure single service\'s quality. In system level, BPEL specification is converted into state diagram firstly, and then state transition-based test cases generation algorithm is presented. Based on the testing records of the above two levels, a simple reliability evaluation method is addressed. Furthermore, the feasibility and effectiveness of our approach is validated by the preliminary study and case-based experiments.', NULL);
INSERT INTO `list` VALUES (172, '0000-00-00', 2009, 'inproceedings', 'Wenhua Wang, Yu Lei, Sreedevi Sampath, Raghu N. Kacker, D. Richard Kuhn, James Lawrence', 'A combinatorial approach to building navigation graphs for dynamic web applications', 'Application', '', '2009 International Conference on Software Maintenance', 'ICSM', '', '', '211-220', '', '10.1109/ICSM.2009.5306321', 'Combinatorial Testing', 'Modeling the navigation structure of a dynamic Web application is a challenging task because of the presence of dynamic pages. In particular, there are two problems to be dealt with: (1) the page explosion problem, i.e., the number of dynamic pages may be huge or even infinite; and (2) the request generation problem, i.e., many dynamic pages may not be reached unless appropriate user requests are supplied. As a user request typically consists of multiple parameter values, the request generation problem can be further divided into two problems: (1) How to select appropriate values for individual parameters? (2) How to effectively combine individual parameter values to generate requests? This paper presents a combinatorial approach to building a navigation graph. The novelty of our approach is two-fold. First, we use an abstraction scheme to control the page explosion problem. In this scheme, pages that are likely to have the same navigation behavior are grouped together, and are represented as a single node in a navigation graph. Grouping pages reduces and bounds the size of a navigation graph for practical applications. Second, assuming that values of individual parameters are supplied by using other techniques or generated manually by the user, we combine parameter values in a way that achieves a well-defined combinatorial coverage called pairwise coverage. Using pairwise coverage can significantly reduce the number of requests that have to be submitted while still achieving effective coverage of the navigation structure. We report a prototype tool called Tansuo, and apply the tool to five open source Web applications. Our empirical results indicate that Tansuo can efficiently generate Web navigation graphs for these applications.', NULL);
INSERT INTO `list` VALUES (173, '0000-00-00', 2009, 'inproceedings', 'Andrea Calvagna, Angelo Gargantini', 'IPO-s: Incremental Generation of Combinatorial Interaction Test Data Based on Symmetries of Covering Arrays', 'Generation', '', '2009 International Conference on Software Testing, Verification and Validation Workshops', 'ICST', '', '', '41930', '', '10.1109/ICSTW.2009.7', 'Combinatorial Testing', 'Verification and validation of highly-configurable software systems, such as those supporting many optional or customizable features, is a challenging activity. In fact, due to its intrinsic complexity, formal modeling of the whole system may require a great effort. Modeling activities may become extremely expensive and time consuming, and the tester may decide to model (at least initially) only the inputs and require they are sufficiently covered by tests. The recent wide spreading usage of combinatorial interaction testing (CIT) is dramatically improving the effectiveness of this activity. Although there exist analytical ways to derive minimal sized CIT test suites, they are not applicable to all task sizes. Therefore, researchers have explored many techniques based on greedy or heuristic algorithms that may lead to sub-optimal result in the size of the built test suite but that are applicable to problems of real size. In this paper, a new parameter-based heuristic algorithm for the construction of pairwise covering test suites is presented; it is based on a symmetry property of covering arrays and it is called IPOS . Time and space complexity of IPOS is discussed in comparison especially with the only other parameter-based approach existing in literature. The proposed approach is supported by a prototype implementation, and experimental assessment is also presented.', NULL);
INSERT INTO `list` VALUES (174, '0000-00-00', 2009, 'inproceedings', 'Anthony Barrett, Daniel Dvorak', 'A Combinatorial Test Suite Generator for Gray-Box Testing', 'Application', '', '2009 International Conference on Space Mission Challenges for Information Technology', 'SMC-IT', '', '', '387-393', '', '10.1109/SMC-IT.2009.53', 'Combinatorial Testing', 'In black-box testing, the system being tested is typically characterized as a number of inputs, where each input can take one of a number of values. Thus each test is a vector of input settings, and the set of possible tests is an N dimensional space, where N is the number of inputs. For example, an instance of a simulation of a crew exploration vehicle\'s (CEV) launch pad abort scenario can have 76 floating-point inputs. Unfortunately, for such a large number of inputs only a small percentage of the test space can be actually tested. This paper characterizes levels of partial test space coverage and presents Testgen, a tool for generating a suite of tests that guarantees a level of test space coverage, which a user can adapt to take advantage of knowledge of system internals. This ability to adapt coverage makes Testgen a gray-box testing tool.', NULL);
INSERT INTO `list` VALUES (175, '0000-00-00', 2009, 'inproceedings', 'Wolfgang Grieskamp, Xiao Qu, Xiangjun Wei, Nicolas Kicillof, Myra B. Cohen', 'Interaction Coverage Meets Path Coverage by SMT Constraint Solving', 'Generation', 'Constraint', '2009 International Conference on Testing of Software and Communication Systems', 'TESTCOM', '', '', '97-112', '', '10.1007/978-3-642-05031-2_7', 'Combinatorial Testing', 'We present a novel approach for generating interaction combinations based on SMT constraint resolution. Our approach can generate maximal interaction coverage in the presence of general constraints as supported by the underlying solver. It supports seeding with general predicates, which allows us to combine it with path exploration such that both interaction and path coverage goals can be met. Our approach is motivated by the application to behavioral model-based testing in the Spec Explorer tool, where parameter combinations must be generated such that all path conditions of a model action have at least one combination which enables the path. It is applied in a large-scale project for model-based quality assurance of interoperability documentation at Microsoft.', NULL);
INSERT INTO `list` VALUES (176, '0000-00-00', 2009, 'inproceedings', 'Yingxia Cui, Longshu Li, Sheng Yao', 'A New Strategy for Pairwise Test Case Generation', 'Generation', '', '2009 International Symposium on Intelligent Information Technology Application', 'IITA', '', '', '303-306', '', '10.1109/IITA.2009.416', 'Combinatorial Testing', 'Pairwise testing has become an important approach to software testing because it often provides effective error detection at low cost, and a key problem of it is the test case generation method. As the part of an effort to develop an optimized strategy for pairwise testing, this paper proposes an efficient pairwise test case generation strategy, called VIPO (Variant of In-Parameter-order), which is a variant of IPO strategy. We compare its effectiveness with some existing strategies including IPO, Tconfig, Pict and AllPairs. Experimental results demonstrate that VIPO outperformed them in terms of the number of generated test case within reasonable execution times, in most cases.', NULL);
INSERT INTO `list` VALUES (177, '0000-00-00', 2009, 'inproceedings', 'Brady J. Garvin, Myra B. Cohen, Matthew B. Dwyer', 'An Improved Meta-heuristic Search for Constrained Interaction Testing', 'Generation', 'Search Based', '2009 International Symposium on Search Based Software Engineering', 'ISSRE', '', '', '13-22', '', '10.1109/SSBSE.2009.25', 'Combinatorial Testing', 'Combinatorial interaction testing (CIT) is a cost-effective sampling technique for discovering interaction faults in highly configurable systems. Recent work with greedy CIT algorithms efficiently supports constraints on the features that can coexist in a configuration. But when testing a single system configuration is expensive, greedy techniques perform worse than meta-heuristic algorithms because they produce larger samples. Unfortunately, current meta-heuristic algorithms are inefficient when constraints are present. We investigate the sources of inefficiency, focusing on simulated annealing, a well-studied meta-heuristic algorithm. From our findings we propose changes to improve performance, including a reorganized search space based on the CIT problem structure. Our empirical evaluation demonstrates that the optimizations reduce run-time by three orders of magnitude and yield smaller samples. Moreover, on real problems the new version compares favorably with greedy algorithms.', NULL);
INSERT INTO `list` VALUES (178, '0000-00-00', 2009, 'inproceedings', 'Hema Srikanth, Myra B. Cohen, Xiao Qu', 'Reducing Field Failures in System Configurable Software: Cost-Based Prioritization', 'Optimization', 'Priority', '2009 International Symposium on Software Reliability Engineering', 'ISSRE', '', '', '61-70', '', '10.1109/ISSRE.2009.26', 'Combinatorial Testing', 'System testing of configurable software is an expensive and resource constrained process. Insufficient testing often leads to escaped faults in the field where failures impact customers and are costly to repair. Prior work has shown that it is possible to efficiently sample configurations for testing using combinatorial interaction testing, and to prioritize these configurations to increase the rate of early fault detection. The underlying assumption to date has been that there is no added complexity to configuring a system level environment over a user configurable one; i.e. the time required to setup and test each individual configuration is nominal. In this paper we examine prioritization of system configurable software driven not only by fault detection but also by the cost of configuration and setup time that moving between different configurations incurs. We present a case study on two releases of an enterprise software system using failures reported in the field. We examine the most effective prioritization technique and conclude that (1) using failure history of configurations can improve the early fault detection rate, but that (2) we must consider fault detection rate over time, not by the number of configurations tested. It is better to test related configurations which incur minimal setup time than to test fewer, more diverse configurations.', NULL);
INSERT INTO `list` VALUES (179, '0000-00-00', 2009, 'inproceedings', 'Sandro Fouche, Myra B. Cohen, Adam Porter', 'Incremental covering array failure characterization in large configuration spaces', 'Application', '', '2009 International symposium on Software testing and analysis', 'ISSTA', '', '', '177-188', '', '10.1145/1572272.1572294', 'Combinatorial Testing', 'The increasing complexity of configurable software systems has created a need for more intelligent sampling mechanisms to detect and characterize failure-inducing dependencies between configurations. Prior work - in idealized environments - has shown that test schedules based on a mathematical object, called a covering array, in combination with classification techniques, can meet this need. Applying this approach in practice, however, is tricky because testing time and resource availability are unpredictable, and because failure characteristics can change from release to release. With current approaches developers must set a key covering array parameter (its strength) based on estimated release times and failure characterizations. This will influence the outcome of their results.\r\n\r\nIn this paper we propose a new approach that incrementally builds covering array schedules. This approach begins at a low strength, and then iteratively increases strength as resources allow. At each stage previously tested configurations are reused, thus avoiding duplication of work. With the incremental approach developers need never commit to a specific covering array strength. Instead, by using progressively stronger covering array schedules, failures due to few configuration dependencies can be found and classified as soon and as cheaply as possibly. Additionally, it eliminates the risks of committing to overly strong test schedules.\r\n\r\nWe evaluate this new approach through a case study on three consecutive releases of MySQL, an open source database. Our results suggest that our approach is as good or better than previous approaches, costing less in most cases, and allowing greater flexibility in environments with unpredictable development constraints.', NULL);
INSERT INTO `list` VALUES (180, '0000-00-00', 2009, 'inproceedings', 'Andrea Calvagna, Angelo Gargantini, Emiliano Tramontana', 'Building T-wise Combinatorial Interaction Test Suites by Means of Grid Computing', 'Generation', '', '2009 International Workshops on Enabling Technologies: Infrastructures for Collaborative Enterprises', 'WETICE', '', '', '213-218', '', '10.1109/WETICE.2009.52', 'Combinatorial Testing', 'Generally, systematic testing is the only way to assess the occurrence of failures in systems consisting in a set of components, however given the size of real-world systems, it would be very expensive to construct and test all the possible combinations of the states of components. Combinatorial interaction testing is an existing technique that appropriately reduces the number of test cases by choosing either pairs, triplets, etc., i.e. t-tuples, of input values. Of course, the effectiveness of a test suite is higher when choosing e.g. triplets of inputs rather than pairs. Since high values of t are preferable, a large number of test cases could still be generated. This paper proposes a technique for building the smallest possible test suite of size t. This technique consists in reducing the number of test cases by carefully choosing non redundant t-tuples. The paper shows that for obtaining the smallest possible set of tests, it is best to generate a large \'flexible\' set of t-tuples and then reduce such a set until the smallest one is obtained. Reduction is a computationally expensive operation and therefore it is worth performing it by parallelizing its execution. This paper proposes a solution for executing the reduction algorithm over a set of Grid resources.', NULL);
INSERT INTO `list` VALUES (183, '0000-00-00', 2009, 'incollection', 'Matthew J. McGill, R.E. Kurt Stirewalt, Laura K. Dillon', 'Automated test input generation for software that consumes ORM models', 'Application', 'Tool', '2009 Lecture Notes in Computer Science', 'Book', '', '', '704-713', '', '10.1007/978-3-642-05290-3_86', 'Combinatorial Testing', 'Software tools that analyze and generate code from ORM conceptual schemas are highly susceptible to feature interaction bugs. When testing such tools, test suites are needed that cover many combinations of features, including combinations that rarely occur in practice. Manually creating such a test suite is extremely labor-intensive, and the tester may fail to cover feasible feature combinations that are counter-intuitive or that rarely occur. This paper describes ATIG, a prototype tool for automatically generating test suites that cover diverse combinations of ORM features. ATIG makes use of combinatorial testing to optimize coverage of select feature combinations within constraints imposed by the need to keep the sizes of test suites manageable. We have applied ATIG to generate test inputs for an industrial strength ORM-to-Datalog code generator. Initial results suggest that it is useful for finding feature interaction errors in tools that operate on ORM models.', NULL);
INSERT INTO `list` VALUES (184, '0000-00-00', 2009, 'inproceedings', 'Josue Bracho-Rios, Jose Torres-Jimenez, Eduardo Rodriguez-Tello', 'A New Backtracking Algorithm for Constructing Binary Covering Arrays of Variable Strength', 'Generation', '', '2009 Mexican International Conference on Artificial Intelligence', 'MICAI', '', '', '394-407', '', '10.1007/978-3-642-05258-3_35', 'Combinatorial Testing', 'A Covering Array denoted by CA(N;t,k,v) is a matrix of size N ×k, in which each of the v t combinations appears at least once in every t columns. Covering Arrays (CAs) are combinatorial objects used in software testing. There are different methods to construct CAs, but as it is a highly combinatorial problem, few complete algorithms to construct CAs have been reported. In this paper a new backtracking algorithm based on the Branch & Bound technique is presented. It searches only non-isomorphic Covering Arrays to reduce the search space of the problem of constructing them. The results obtained with this algorithm are able to match some of the best known solutions for small instances of binary CAs.', NULL);
INSERT INTO `list` VALUES (185, '0000-00-00', 2009, 'inproceedings', 'Pedro Quiz-Ramos, Jose Torres-Jimenez, Nelson Rangel-Valdez', 'Constant Row Maximizing Problem for Covering Arrays', 'Generation', '', '2009 Mexican International Conference on Artificial Intelligence', 'MICAI', '', '', '159-164', '', '10.1109/MICAI.2009.28', 'Combinatorial Testing', 'A Covering Array denoted by CA(N; t,k,¿) is a matrix of size N × k, where each tuple of t columns has at least one time each of the v t combinations of symbols. The C As are combinatorial objects used for software testing and design of experiments in: biology, agriculture, medicine, etc. CAs can be constructed using heuristic algorithms, greedy search and algebraic procedures. The Hartman Style Rising Procedures (HSRP) are algebraic procedures to construct large C As. These procedures create large CAs using small CAs. If the small C As have many constant rows, the HSRP provides better large CAs. In this paper we present the constant Row Maximizing Problem (CMRP) for CAs. We propose 4 distinct models to maximize the number of constant rows in a CA. The models were tested with binary and senary CAs and we improved some upper bounds.', NULL);
INSERT INTO `list` VALUES (186, '0000-00-00', 2009, 'inproceedings', 'D. Richard Kuhn, Raghu N. Kacker, Yu Lei', 'Random vs. Combinatorial Methods for Discrete Event Simulation of a Grid Computer Network', 'Evaluation', '', '2009 MODSIM World Conference and Expo', 'MODSIM', '', '', '83-88', '', 'not found', 'Combinatorial Testing', 'This study compared random and t-way combinatorial inputs of a network simulator, to\r\ndetermine if these two approaches produce significantly different deadlock detection for varying network\r\nconfigurations. Modeling deadlock detection is important for analyzing configuration changes that could\r\ninadvertently degrade network operations, or to determine modifications that could be made by attackers\r\nto deliberately induce deadlock. Discrete event simulation of a network may be conducted using random\r\ngeneration of inputs. In this study, we compare random with combinatorial generation of inputs.\r\nCombinatorial (or t-way) testing requires every combination of any t parameter values to be covered by at\r\nleast one test. Combinatorial methods can be highly effective because empirical data suggest that nearly\r\nall failures involve the interaction of a small number of parameters (1 to 6). Thus, for example, if all\r\ndeadlocks involve at most 5-way interactions between n parameters, then exhaustive testing of all n-way\r\ninteractions adds no additional information that would not be obtained by testing all 5-way interactions.\r\nWhile the maximum degree of interaction between parameters involved in the deadlocks clearly cannot\r\nbe known in advance, covering all t-way interactions may be more efficient than using random generation\r\nof inputs. In this study we tested this hypothesis for t = 2, 3, and 4 for deadlock detection in a network\r\nsimulation. Achieving the same degree of coverage provided by 4-way tests would have required\r\napproximately 3.2 times as many random tests; thus combinatorial methods were more efficient for\r\ndetecting deadlocks involving a higher degree of interactions. The paper reviews explanations for these\r\nresults and implications for modeling and simulation. ', NULL);
INSERT INTO `list` VALUES (187, '0000-00-00', 2009, 'inproceedings', 'Jianhua Gao, Yuefeng Hu', 'A Novel Generation Algorithm of Pair-Wise Testing Cases', 'Generation', '', '2009 Pacific Rim International Symposium on Dependable Computing', 'PRDC', '', '', '43-48', '', '10.1109/PRDC.2009.16', 'Combinatorial Testing', 'Pair-wise testing is a practical and effective method which has already been used in the software testing. Extensive research has been made on the generation of pair-wise testing. In order to make it easy to analyze the current generation methods, we propose a method to ease the process. That is we transform the problem of pair-wise testing to a graphic one. The IPO algorithm is based on parameters and can ensure the optimization of test cases in each expansion. Though it has many advantages, it is still not sustainable enough because of its flexibility. We studied the three elements which affect its sustainability. The three elements are the horizontal growth of pair-wise testing, the combination of pair-wise testing cases and the extension sequence of the parameters to be extended. Thus we propose a HIPO algorithm based on IPO algorithm to solve those problems. The HIPO algorithm inherits the merits of high extension of IPO algorithm and introduces a new concept of contribution extent. It adopts the methods of preferential sequence as well as minimization algorithm to optimize the problems above. We develop the test case generation tool based on the HIPO algorithm by means of .Net technology. And we also prove its effectiveness in our experiment.', NULL);
INSERT INTO `list` VALUES (188, '0000-00-00', 2009, 'article', 'Renée C. Bryce, Charles J. Colbourn', 'A density-based greedy algorithm for higher strength covering arrays', 'Generation', '', '2009 Software Testing, Verification and Reliability', 'STVR', '19', '1', '37-53', '', '10.1002/stvr.393', 'Combinatorial Testing', 'Algorithmic construction of software interaction test suites has focussed on pairwise coverage; less is known about the efficient construction of test suites for t-way interactions with t≥3. This study extends an efficient density-based algorithm for pairwise coverage to generate t-way interaction test suites and shows that it guarantees a logarithmic upper bound on the size of the test suites as a function of the number of factors. To complement this theoretical guarantee, an implementation is outlined and some practical improvements are made. Computational comparisons with other published methods are reported. Many of the results improve upon those in the literature. However, limitations on the ability of one-test-at-a-time algorithms are also identified. Copyright © 2008 John Wiley & Sons, Ltd', NULL);
INSERT INTO `list` VALUES (189, '0000-00-00', 2009, 'incollection', 'Andrea Calvagna, Angelo Gargantini', 'Combining Satisfiability Solving and Heuristics to Constrained Combinatorial Interaction Testing', 'Generation', 'Constraint', '2009 International Conference on Tests and Proofs', 'Book', '', '', '27-42', 'Springer Berlin Heidelberg', '10.1007/978-3-642-02949-3_4', 'Combinatorial Testing', 'Combinatorial interaction testing aims at revealing errors inside a system under test triggered by unintended interaction between values of its input parameters. In this context we defined a new greedy approach to generate a combinatorial interaction test suites in the presence of constraints, based on integration of an SMT solver, and ordered processing of test goals. Based on the observation that the processing order of required combinations determines the size of the final test suite, this approach has been then used as a framework to evaluate a set of deterministic ordering strategies, each based on a different heuristic optimization criteria. Their performance has been assessed and contrasted also with those of random and dummy ordering strategies. Results of experimental assessment are presented and compared with well-known combinatorial tools', NULL);
INSERT INTO `list` VALUES (190, '0000-00-00', 2009, 'article', 'Peter Danziger, Eric Mendelsohn, Lucia Moura, Brett Stevens', 'Covering arrays avoiding forbidden edges', 'Generation', 'Constraint', '2009 Theoretical Computer Science', 'Theor Comput Sci', '410', '52', '5403-5414', '', '10.1016/j.tcs.2009.07.057', 'Combinatorial Testing', 'Covering arrays (CAs) can be used to detect the existence of faulty pairwise interactions between parameters or components in a software system. The generalization considered here applies to the situation in which some input combinations are invalid, a requirement quite common in software testing. In this paper, we study covering arrays avoiding forbidden edges (\r\ns), where certain pairwise interactions are forbidden while all others must be covered, and we aim to minimize the number of tests. We establish a theoretical framework for this problem, by providing connections to the edge clique covering problem, lower and upper bounds, complexity results and a recursive construction. We also give an algorithm for the case of binary alphabets.', NULL);
INSERT INTO `list` VALUES (191, '0000-00-00', 2009, 'phdthesis', 'Elizabeth Maltais', 'Covering arrays avoiding forbidden edges and edge clique covers', 'Generation', 'Constraint', '2009 University of Ottawa', 'Phd', '', '', 'not found', '', 'https://doi.org/10.20381/RUOR-19265', 'Combinatorial Testing', 'Covering arrays avoiding forbidden edges (CAFEs) are combinatorial designs which can be used to generate test suites for practical testing applications. CAFEs generate test suites in which all required pairwise interactions between any two factors are tested at least once each, with the property that a specified list of pairwise interactions, the so called forbidden interactions, are avoided by all tests generated by the CAFE. Consequently, CAFEs can be applied to testing applications wherein constraints are imposed on the factors of the tests, resulting in forbidden interactions. In this thesis, we study CAFEs, as well as their relationship to the edge clique cover problem from graph theory. We give new results and bounds for uniform edge clique covers and CAFEs. We establish the computational complexity of several problems related to CAFEs and edge clique covers. In particular, we prove that finding an optimal CAFE (as well as finding an optimal error-locating array) for a graph is NP-hard, even for the case of binary alphabets', NULL);
INSERT INTO `list` VALUES (192, '0000-00-00', 2009, 'article', 'Jianjun Yuan, Changjun Jiang', 'Construct Pairwise Test Suites Based on the Bak-Sneppen Model of Biological Evolution', 'Generation', '', '2009 World Academy of Science, Engineering and Technology', 'WASET', '59', '1', '224-229', '', 'not found', 'Combinatorial Testing', 'Abstract—Pairwise testing, which requires that every combination of valid values of each pair of system factors be covered by at lease one test case, plays an important role in software testing since many faults are caused by unexpected 2-way interactions among system factors. Although meta-heuristic strategies like simulated annealing can generally discover smaller pairwise test suite, they may cost more time to perform search, compared with greedy algorithms. We propose a new method, improved Extremal Optimization (EO) based on the Bak-Sneppen (BS) model of biological evolution, for constructing pairwise test suites and define fitness function according to the requirement of improved EO. Experimental results show that improved EO gives similar size of resulting pairwise test suite and yields an 85% reduction in solution time over SA', NULL);
INSERT INTO `list` VALUES (193, '0000-00-00', 2009, 'article', 'Ljubomir Lazic, Snezana Popovic, Nikos E. Mastorakis', 'A simultaneous application of combinatorial testing and virtualization as a method for software testing', 'Application', '', '2009 WSEAS Transactions on Information Science and Applications', 'WSEAS ', '6', '11', '1802-1813', '', 'https://dl.acm.org/doi/10.5555/1718140.1718147', 'Combinatorial Testing', 'We propose in this paper a general framework for an integrated End-to-End Testing of IT Architecture and Applications using the simultaneous application of combinatorial testing and virtualization. Combinatorial testing methods are often applied in cases of the configuration testing. The combinatorial approach to software testing uses models, particularly an Orthogonal Array Testing Strategy (OATS) is proposed as a systematic, statistical way of testing pair-wise interactions to generate a minimal number of test inputs so that selected combinations of input values are covered. Virtualization, in the process of testing, is based on setting the necessary environment to multiple virtual machines, which run on one or in smaller groups of physical computers, which are: reduce the cost of equipment and related resources, reduce the time required to manage the testing process, and favors raising removal of test infrastructure. Together, combinatorial testing and virtualization presents practical approach to improving process of testing, through the balancing quality, cost and time.', NULL);
INSERT INTO `list` VALUES (194, '0000-00-00', 2010, 'inproceedings', 'Ziyuan Wang, Baowen Xu, Lin Chen, Zhenyu Chen', 'Cost-effective combinatorial test case prioritization for varying combination weights', 'Optimization', 'Priority', '2010 22nd International Conference on Software Engineering and Knowledge Engineering', 'SEKE', '', '', '273-278', '', 'not found', 'Combinatorial Testing', 'Combinatorial testing has been widely used in practice. People usually assume all test cases in combinatorial test suite will be executed fairly. However, in many applications where combinatorial testing is needed, the entire test suite is not run as a result of test resource constraints. To improve the efficiency of testing, combinatorial test case prioritization technique is needed. This paper presents a novel cost-effective combinatorial test case prioritization technique, which takes combination weights and test costs into account. Firstly, a metric, which could incorporate varying combination weights and test costs, is proposed to assess the combinatorial coverage efficiency of combinatorial test suite. And secondly, two heuristic algorithms are proposed to prioritize combinatorial test cases. Finally, experimental results are given to illustrate the properties of proposed technique, and also prove its comparative advantage over existing methods.', NULL);
INSERT INTO `list` VALUES (196, '0000-00-00', 2010, 'inproceedings', 'Ajay Kattepur, Sagar Sen, Benoit Baudry, Albert Benveniste, Claude Jard', 'Variability modeling and Qos analysis of web services orchestrations', 'Application', '', '2010 8th International Conference on Web Services', 'ICWS', '', '', '99-106', '', '10.1109/ICWS.2010.40', 'Combinatorial Testing', 'The ever-growing choice in diverse services is making service orchestration variability an essential aspect of a composite web service. Influence of this variation on the Quality of Service (QoS) of a composite service is critical and the focus of our work. In this paper, we present a methodology to first model orchestration variability using a feature diagram (FD). The FD specifies a product line of orchestrations represented as configurations of invoked/rejected atomic services. Second, due to the potentially large set of configurations we employ combinatorial testing techniques to automatically generate configurations covering all valid pair wise interactions between services. Third, we analyze QoS variation for each configuration using probabilistic models of QoS. Using a crisis management system case study we experimentally show that pair wise generation covers all QoS outliers and eliminates analysis of > 75% of all possible configurations. The QoS analysis of the pair wise configurations reveals unsafe/ineffective configurations, helps determine realistic Service Level Agreements (SLAs), and provides valuable feedback to help remodel an orchestration.', NULL);
INSERT INTO `list` VALUES (197, '0000-00-00', 2010, 'incollection', 'Jorge Martinez-Pena, Jose Torres-Jimenez, Nelson Rangel-Valdez, Himer Avila-George', 'A Heuristic Approach for Constructing Ternary Covering Arrays Using Trinomial Coefficients', 'Generation', 'Search Based', '2010 Advances in Artificial Intelligence', 'AI Adv', '6443', '', '572-581', 'Springer Berlin Heidelberg', '10.1007/978-3-642-16952-6_58', 'Combinatorial Testing', 'This paper presents a simulated annealing (SA) algorithm for the construction of ternary covering arrays (CAs) using a trinomial coefficient representation. A ternary CA, denoted by CA(t,k,3), is an N ×k array where each N ×t subarray contains each of the 3t combinations of symbols at least once. The construction of optimal CAs is, in general, an NP-complete problem. Many reported SA implementations use an N ×k matrix representation for the CA construction. Instead of this, we represent ternary CAs using trinomial coefficients in order to reduce the search space for the SA algorithm.', NULL);
INSERT INTO `list` VALUES (198, '0000-00-00', 2010, 'incollection', 'Loreto Gonzalez-Hernandez, Jose Torres-Jimenez', 'MiTS: A New Approach of Tabu Search for Constructing Mixed Covering Arrays', 'Generation', 'Search Based', '2010 Advances in Soft Computing', 'Book', '6438', '', '382-393', 'Springer Berlin Heidelberg', '10.1007/978-3-642-16773-7_33', 'Combinatorial Testing', 'Software systems have been increasingly used by our society, so a failure in them can lead to large losses. To reduce the failures of a software it is necessary to carry out the testing process appropriately. The combinatorial testing helps in the testing process by providing structures with a test set of small size, like Mixed Covering Arrays (MCAs). However, the problem of constructing an optimal test set is an NP-complete problem leading to the development of non exhaustive approaches to solve it. This paper proposes a new approach of Tabu Search (TS) called MiTS (that stands for Mixed Tabu Search) which focuses on constructing MCAs. The approach is based on the use of a mixture of neighborhood functions and a fine tuning process to improve the performance of the TS. Experimental evidence shows a poor performance when a single neighborhood function is used. In the other side, the TS (using a mixture of neighborhood functions) is competitive in the construction of MCAs over a known benchmark reported in the literature.', NULL);
INSERT INTO `list` VALUES (200, '0000-00-00', 2010, 'inproceedings', 'Joshua R. Maximoff, Michael D. Trela, D. Richard Kuhn, Raghu N. Kacker', 'A Method for Analyzing System State-space Coverage within a t-Wise Testing Framework', 'Application', '', '2010 Annual IEEE Systems Conference', 'SYSCON', '', '', '598-603', '', '10.1109/SYSTEMS.2010.5482481', 'Combinatorial Testing', 'Inadequate state-space coverage of complex configurable systems during test phases is an area of concern for systems engineers. Determining the state-space coverage of a proposed or executed test suite traditionally involves qualitative assessment, rendering meaningful comparative analysis between tests for a given system or across multiple systems difficult. We propose a method for assessing state-space coverage of a test suite utilizing t-wise testing, a combinatorial technique borrowed from the software testing community which generalizes pair-wise testing. We refine traditional notions of a t-wise test suite to analyze the configuration coverage of a test plan. This provides a methodology and a set of metrics to assess both the level and the distribution of state-space coverage. We detail a proof-of-concept experiment using this partial t-wise coverage framework to analyze Integration and Test (I&T) data from three separate NASA spacecraft.', NULL);
INSERT INTO `list` VALUES (201, '0000-00-00', 2010, 'techreport', 'D. Richard Kuhn, Raghu N. Kacker, Yu Lei', 'Advanced Combinatorial Test Methods for System Reliability', 'Application', '', '2010 Annual Technical Report of the IEEE Reliability Society', 'Tech', '', '', 'not found', '', 'not found', 'Combinatorial Testing', 'Every computer user is familiar with software bugs. Many seem to appear almost randomly, suggesting that the conditions triggering them must be complex, and some famous software bugs have been traced to highly unusual combinations of conditions. For example, the 1997 Mars Pathfinder mission began experiencing system resets at seemingly unpredictable times soon after it landed and began collecting data. Fortunately, engineers were able to deduce and correct the problem, which occurred only when (1) a particular type of data was being collected and (2) intermediate priority tasks exceeded a certain load, allowing a blocking condition that eventually triggered a reset.', NULL);
INSERT INTO `list` VALUES (203, '0000-00-00', 2010, 'inproceedings', 'Baiqiang Chen, Jun Yan, Jian Zhang', 'Combinatorial Testing with Shielding Parameters', 'Generation', 'Constraint', '2010 Asia-Pacific Software Engineering Conference', 'APSEC', '', '', '280-289', '', '10.1109/APSEC.2010.40', 'Combinatorial Testing', 'Combinatorial testing is an important approach to detecting interaction errors for a system with several parameters. Existing research in this area assumes that all parameters of the system under test are always effective. However, in many realistic applications, there may exist some parameters that can disable other parameters in certain conditions. These parameters are called shielding parameters. Shielding parameters make test cases generated by the existing test model, which uses the Mixed Covering Array (MCA), fail in exposing some potential errors that should be detected. In this paper, the Mixed Covering Array with Shielding parameters (MCAS) is proposed to describe such problems. Then test cases can be generated by constructing MCAS\'s in three different approaches. According to the experimental results, our test model can generate satisfactory test cases for combinatorial testing with shielding parameters.', NULL);
INSERT INTO `list` VALUES (204, '0000-00-00', 2010, 'article', 'Lixin Wang, Renxia Wan', 'A New Method of Reducing Pair-wise Combinatorial Test Suite', 'Generation', 'Constraint', '2010 Computer and Information Science', 'CIS', '3', '1', '35-41', '', '10.5539/cis.v3n1p35', 'Combinatorial Testing', 'The biggest problem for combinatorial test is a numerous number of combinations of input parameters by combinatorial explosion. Pair-wise combinatorial coverage testing is an effective method which can reduce the test cases in a suite and is able to detect about 70% program errors. But, under many circumstances, the parameters in programs under test (PUTs) have relations with each other. So there are some ineffective test cases in pair-wise combinatorial test suites. In this paper, we propose a method of reducing ineffective combinatorial test cases from pair-wise test suite. The main ideas of the method is that we firstly analyzes the dependent relationships among input parameters, then use the relationships to reduce ineffective pair-wise combinations of input parameters, and lastly generate the pair-wise combinatorial coverage test suite. The experiments show that the method is feasible and effective, and considerably reduce the number of pair-wise combinatorial test cases for some programs under test.', NULL);
INSERT INTO `list` VALUES (205, '0000-00-00', 2010, 'inproceedings', 'Jose Torres-Jimenez, Eduardo Rodriguez-Tello', 'Simulated Annealing for constructing binary covering arrays of variable strength', 'Generation', '', '2010 Congress on Evolutionary Computation', 'CEC', '', '', '1--8', '', '10.1109/CEC.2010.5586148', 'Combinatorial Testing', 'This paper presents new upper bounds for binary covering arrays of variable strength constructed by using a new Simulated Annealing (SA) algorithm. This algorithm incorporates several distinguished features including an efficient heuristic to generate good quality initial solutions, a compound neighborhood function which combines two carefully designed neighborhoods and a fine-tuned cooling schedule. Its performance is investigated through extensive experimentation over well known benchmarks and compared with other state-of-the-art algorithms, showing that the proposed SA algorithm is able to outperform them.', NULL);
INSERT INTO `list` VALUES (206, '0000-00-00', 2010, 'incollection', 'Himer Avila-George, Jose Torres-Jimenez, Vicente Hernández, Nelson Rangel-Valdez', 'Verification of General and Cyclic Covering Arrays Using Grid Computing', 'Evaluation', '', '2010 Data Management in Grid and Peer-to-Peer Systems', 'Book', '6265', '', '112-123', 'Springer Berlin Heidelberg', '10.1007/978-3-642-15108-8_10', 'Combinatorial Testing', 'A covering array (CA) is an N ×k matrix over the alphabet v s.t. each N ×k subset contains at least one time each v t combination. Covering Arrays (CAs) have been applied mainly in software and hardware testing. The construction of CAs requires to do the verification that each N ×t subset contains at least one time each v t combination. In this paper we present a sequential algorithm and a grid algorithm to do the CA verification. The algorithms were tested using a benchmark of CAs of variable strength. The main conclusion of the paper lies in the identification of the strengths and weakness of our algorithms (related to the values of the CA parameters).', NULL);
INSERT INTO `list` VALUES (207, '0000-00-00', 2010, 'article', 'Brady J. Garvin, Myra B. Cohen, Matthew B. Dwyer', 'Evaluating improvements to a meta-heuristic search for constrained interaction testing', 'Generation', 'Constraint, Search Based', '2010 Empirical Software Engineering', 'EMSE', '16', '1', '61-102', '', '10.1007/s10664-010-9135-7', 'Combinatorial Testing', 'Combinatorial interaction testing (CIT) is a cost-effective sampling technique for discovering interaction faults in highly-configurable systems. Constrained CIT extends the technique to situations where some features cannot coexist in a configuration, and is therefore more applicable to real-world software. Recent work on greedy algorithms to build CIT samples now efficiently supports these feature constraints. But when testing a single system configuration is expensive, greedy techniques perform worse than meta-heuristic algorithms, because greedy algorithms generally need larger samples to exercise the same set of interactions. On the other hand, current meta-heuristic algorithms have long run times when feature constraints are present. Neither class of algorithm is suitable when both constraints and the cost of testing configurations are important factors. Therefore, we reformulate one meta-heuristic search algorithm for constructing CIT samples, simulated annealing, to more efficiently incorporate constraints. We identify a set of algorithmic changes and experiment with our modifications on 35 realistic constrained problems and on a set of unconstrained problems from the literature to isolate the factors that improve performance. Our evaluation determines that the optimizations reduce run time by a factor of 90 and accomplish the same coverage objectives with even fewer system configurations. Furthermore, the new version compares favorably with greedy algorithms on real-world problems, and, though our modifications were aimed at constrained problems, it shows similar advantages when feature constraints are absent.', NULL);
INSERT INTO `list` VALUES (208, '0000-00-00', 2010, 'article', 'Mohammed I. Younis, Kamal Z. Zamli', 'MC-MIPOG: A parallel t-way test generation strategy for multicore systems', 'Generation', '', '2010 ETRI Journal', 'ETRI J', '32', '1', '73-83', '', '10.4218/etrij.10.0109.0266', 'Combinatorial Testing', 'Combinatorial testing has been an active research area in recent  years.  One  challenge  in  this  area  is  dealing  with  the  combinatorial explosion problem, which typically requires a very expensive computational process to find a good test set that  covers  all  the  combinations  for  a  given  interaction  strength  (t).  Parallelization  can  be  an  effective  approach  to  manage   this   computational   cost,   that   is,   by   taking   advantage    of    the    recent    advancement    of    multicore    architectures.  In  line  with  such  alluring  prospects,  this  paper    presents    a    new    deterministic    strategy,    called    multicore  modified  input  parameter  order  (MC-MIPOG)  based   on   an   earlier   strategy,   input   parameter   order   generalized  (IPOG).  Unlike  its  predecessor  strategy,  MC-MIPOG adopts a novel approach by removing control and data  dependency  to  permit  the  harnessing  of  multicore  systems.   Experiments   are   undertaken   to   demonstrate   speedup  gain  and  to  compare  the  proposed  strategy  with  other   strategies,   including   IPOG.   The   overall   results   demonstrate  that  MC-MIPOG  outperforms  most  existing  strategies  (IPOG,  IPOF,  IPOF2,  IPOG-D,  ITCH,  TConfig,  Jenny,  and  TVG)  in  terms  of  test  size  within  acceptable  execution time. Unlike most strategies, MC-MIPOG is also capable of supporting high interaction strengths of t > 6.', NULL);
INSERT INTO `list` VALUES (209, '0000-00-00', 2010, 'inproceedings', 'Kera Z. Watkins', 'Introducing fault-based combinatorial testing to Web services', 'Application', '', '2010 IEEE SoutheastCon', 'IEEE SoutheastCon', '', '', '131-134', '', '10.1109/SECON.2010.5453905', 'Combinatorial Testing', 'Combinatorial testing is considered effective for finding software faults. It is also efficient, since it keeps the number of tests relatively small. However, there seems to be very little research that considers combinatorial testing as a testing approach for web services. They are commonly tested by injecting fault-causing data perturbations into the network. It may be worthwhile to see if combinatorial testing can complement existing perturbations with the benefits of combinatorial testing. The approach proposed in this paper is called combinatorial fault-based testing. This type of testing combines existing fault-based testing techniques, such as fault injection, with combinatorial testing to attempt to find faults of varying strength within a web service. Combinatorial fault-based testing uses fault injection and helps reduce the problem with combinatorial explosion by focusing solely on fault-based combinations. This raises the following research question: Is there a way to take advantage of the benefits of combinatorial testing for web services assuming that source code will not be available, while minimizing the possibility of a combinatorial explosion? Combinatorial fault-based testing looks very promising for answering this question. As a side effect, it could potentially offer a way to determine the maximum strength of interactions to test for web services.', NULL);
INSERT INTO `list` VALUES (210, '0000-00-00', 2010, 'article', 'Xun Yuan, Myra B. Cohen, Atif M. Memon', 'GUI Interaction Testing: Incorporating Event Context', 'Generation', 'Constraint', '2010 IEEE Transactions on Software Engineering', 'TSE', '37', '4', '559-574', '', '10.1109/TSE.2010.50', 'Combinatorial Testing', 'Graphical user interfaces (GUIs), due to their event driven nature, present an enormous and potentially unbounded way for\r\nusers to interact with software. During testing it is important to “adequately cover” this interaction space. In this paper, we develop a\r\nnew family of coverage criteria for GUI testing grounded in combinatorial interaction testing. The key motivation of using combinatorial\r\ntechniques is that they enable us to incorporate “context” into the criteria in terms of event combinations, sequence length, and by\r\nincluding all possible positions for each event. Our new criteria range in both efficiency (measured by the size of the test suite) and\r\neffectiveness (the ability of the test suites to detect faults). In a case study on eight applications, we automatically generate test\r\ncases and systematically explore the impact of context, as captured by our new criteria. Our study shows that by increasing the event\r\ncombinations tested and by controlling the relative positions of events defined by the new criteria, we can detect a large number of\r\nfaults that were undetectable by earlier techniques.\r', NULL);
INSERT INTO `list` VALUES (212, '0000-00-00', 2010, 'inproceedings', 'Mohammed I. Younis, Kamal Z. Zamli, Rozmie R. Othman', 'Effectiveness of the cumulative vs. normal mode of operation for combinatorial testing', 'Application', '', '2010 Interational Symposium on Industrial Electronics and Applications', 'INDEL', '', '', '350-354', '', '10.1109/ISIEA.2010.5679441', 'Combinatorial Testing', 'This paper discusses the state of the art of applying combinatorial interaction testing (CIT) in conjunction with mutation testing for hardware testing. In addition, the paper discusses the art of the practice of applying CIT in normal and cumulative mode in order to derive an optimal test suite that can be used for hardware testing in a production line. Our previous study based on applying CIT in cumulative mode; described the systematic application of the strategy for testing 4-bit Magnitude Comparator Integrated Circuits in a production line. Complementing our previous work, this paper compares the effectiveness of cumulative mode versus normal mode of operation. Our result demonstrates that the use of CIT in cumulative mode is more practical than normal mode of operation as far as detecting faults introduced by mutation.', NULL);
INSERT INTO `list` VALUES (213, '0000-00-00', 2010, 'inproceedings', 'Xiang Chen, Qing Gu, Jingxian Qi, Daoxu Chen', 'Applying Particle Swarm Optimization to Pairwise Testing', 'Generation', 'Search Based', '2010 International Computers, Software & Applications Conference', 'COMPSAC', '', '', '107-116', '', '10.1109/COMPSAC.2010.17', 'Combinatorial Testing', 'Combinatorial testing (also called interaction testing) is an effective specification-based test input generation technique. By now most of research work in combinatorial testing aims to propose novel approaches trying to generate test suites with minimum size that still cover all the pairwise, triple, or n-way combinations of factors. Since the difficulty of solving this problem is demonstrated to be NP-hard, existing approaches have been designed to generate optimal or near optimal combinatorial test suites in polynomial time. In this paper, we try to apply particle swarm optimization (PSO), a kind of meta-heuristic search technique, to pairwise testing (i.e. a special case of combinatorial testing aiming to cover all the pairwise combinations). To systematically build pairwise test suites, we propose two different PSO based algorithms. One algorithm is based on one-test-at-a-time strategy and the other is based on IPO-like strategy. In these two different algorithms, we use PSO to complete the construction of a single test. To successfully apply PSO to cover more uncovered pairwise combinations in this construction process, we provide a detailed description on how to formulate the search space, define the fitness function and set some heuristic settings. To verify the effectiveness of our approach, we implement these algorithms and choose some typical inputs. In our empirical study, we analyze the impact factors of our approach and compare our approach to other well-known approaches. Final empirical results show the effectiveness and efficiency of our approach.', NULL);
INSERT INTO `list` VALUES (215, '0000-00-00', 2010, 'inproceedings', 'Mohammad F.J. Klaib, Sangeetha Muthuraman, Noraziah Ahmad, Roslina Sidek ', 'A Tree based strategy for test data generation and cost calculation for uniform and non-uniform parametric values', 'Generation', '', '2010 International Conference on Computer and Information Technology', 'ICCIT', '', '', '1376-1383', '', '10.1109/CIT.2010.246', 'Combinatorial Testing', 'Software testing is a very important phase of software development to ensure that the developed system is reliable. Due to huge number of possible combinations involved in testing and the limitation in the time and resources, it is usually too expensive and sometimes impossible to test systems exhaustively. To reduce the number of test cases to an acceptable level, combinatorial software interaction testing has been suggested and used by many researchers in the software testing field. It is also reported in literature that pairwise (2-way) combinatorial interaction testing can detect most of the software faults. In this paper we propose a new strategy for test data generation, a Tree Based Test Case Generation and Cost Calculation strategy (TBGCC) that supports uniform and non-uniform values, for input parameters (i.e. parameters with same and different number of values). Our strategy is distinct from others work since we include only the test cases which covers the maximum number of pairs in the covering array at every iteration. Additionally, the whole set of test cases will be checked as one block at every iteration only until the covering array is covered. Other strategies check each test case (N-1) times, where N is the maximum number of the input parameters. A detail description of the tree generation strategy, the iterative cost calculation strategy and efficient empirical results are presented.', NULL);
INSERT INTO `list` VALUES (216, '0000-00-00', 2010, 'inproceedings', 'Bestoun S. Ahmed, Kamal Z. Zamli', 'T-Way Test Data Generation Strategy Based on Particle Swarm Optimization', 'Generation', 'Search Based', '2010 International Conference on Computer Research and Development', 'ICCRD', '', '', '93-97', '', '10.1109/ICCRD.2010.56', 'Combinatorial Testing', 'Due to market demands, software has grown tremendously in size and functionalities over the years. As side effects of such growth, there tend to be more and more unwanted interaction between software and system parameters. These unwanted interactions can sometimes lead to nasty and difficult bugs to detect. In order to address these issues, t-way strategies (i.e. where t indicates interaction strength) are helpful to generate a set of test cases (i.e. to form a complete suite) that cover the required interaction strength as least once from a typically large space of possible test values. In this paper, we highlight a new t-way strategy based on Particle Swarm Optimization, called PSTG. Preliminary results demonstrated that PSTG compares well against other existing t-way strategies.', NULL);
INSERT INTO `list` VALUES (217, '0000-00-00', 2010, 'inproceedings', 'Tian Pei, Wang Jiancheng, Xi Xiaojing, Li Yingmei', 'A method of combinatorial test cases generating based on CMA-PGA model', 'Generation', '', '2010 International Conference on Industrial and Information Systems', 'ICIIS', '', '', '249-251', '', '10.1109/INDUSIS.2010.5565697', 'Combinatorial Testing', 'Aiming at shortening the design time of the optimal test cases, a model of Collaborative Multi-Agent based on Parallel Genetic Algorithm (CMA-PGA) is put forward, which is to be used in combinatorial testing of the software system. Because of the competition and coordination mechanisms especially designed in CMA-PGA, the convergence rate of this model outperforms that of simple genetic algorithm in evolving the optimum or near-optimum solution.', NULL);
INSERT INTO `list` VALUES (218, '0000-00-00', 2010, 'inproceedings', 'Pu Yunming', 'The design of test case based on combinatorial and orthogonal experiment', 'Application', '', '2010 International Conference on Information Science and Engineering', 'ICISE', '', '', '2440-2443', '', '10.1109/ICISE.2010.5690660', 'Combinatorial Testing', 'The combinatorial testing technology and the orthogonal experiment method were studied, optimizing of the design of test case, decreasing the workload of test case. The method of test case was designed with AETG algorithm. A load testing solution was suggested with orthogonal theory and Range analysis method. The load testing factor of system response time was analyzed, including network bandwidth, processor speed, concurrency users etc, the optimization performance criteria of system and testing combinatorial factors were selected.', NULL);
INSERT INTO `list` VALUES (219, '0000-00-00', 2010, 'inproceedings', 'James D. McCaffrey, Jacek Czerwonka', 'An Empirical Study of Pairwise Test Set Generation Using a Genetic Algorithm', 'Generation', 'Search Based', '2010 International Conference on Information Technology: New Generations', 'ITNG', '', '', '992-997', '', '10.1109/ITNG.2010.93', 'Combinatorial Testing', 'Pairwise test set generation is the process of producing a subset of all possible test case inputs to a system in situations where exhaustive testing is not possible or is prohibitively expensive. For a given system under test with a set of input parameters where each parameter can take on one of a discrete set of values, a pairwise test set consists of a collection of vectors which capture all possible combinations of pairs of parameter values. Generating pairwise test sets with a minimal size has been shown to be an NP-complete problem, and several deterministic generation algorithms have been published. This paper describes the results of an investigation of pairwise test set generation using a genetic algorithm. The genetic algorithm approach produced pairwise test sets with comparable or smaller (better) size compared with published results for deterministic algorithms for 39 out of 40 benchmark problems. However, the genetic algorithm test set generation technique required significantly longer processing time in all cases. The results illustrate that generation of pairwise test sets using a genetic algorithm is possible, and suggest that the technique may be both practical and useful in certain software testing situations.', NULL);
INSERT INTO `list` VALUES (220, '0000-00-00', 2010, 'inproceedings', 'Ziyuan Wang, Baowen Xu, Lin Chen, Lei Xu', 'Adaptive Interaction Fault Location Based on Combinatorial Testing', 'Diagnosis', '', '2010 International Conference on Quality Software', 'QSIC', '', '', '495-502', '', '10.1109/QSIC.2010.36', 'Combinatorial Testing', 'Combinatorial testing aims to detect interaction faults, which are triggered by interaction among parameters in system, by covering some specific combinations of parametric values. Most works about combinatorial testing focus on detecting such interaction faults rather than locating them. Based on the model of interaction fault schema, in which the interaction fault is described as a minimum fault schema and several corresponding parent-schemas, we propose an iterative adaptive interaction fault location technique for combinatorial testing. In order to locate interaction faults that detected in combinatorial testing, such technique utilizes delta debugging strategy to filtrate suspicious schemas by generating and running additional test cases iteratively. The properties, which include both recall and precision, of adaptive interaction fault location techniques are also analyzed in this paper. Analytical results suggest that the high scores in both recall and precision are guaranteed. It means that such technique can provide an efficient guidance for the applications of combinatorial testing.', NULL);
INSERT INTO `list` VALUES (221, '0000-00-00', 2010, 'inproceedings', 'Longshu Li, Yingxia Cui, Sheng Yao', 'Application of quotient space theory in input-output relationship based combinatorial testing', 'Generation', '', '2010 International conference on Rough set and knowledge technology', 'RSKT ', '', '', '735-742', '', 'https://dl.acm.org/doi/10.5555/1929344.1929457', 'Combinatorial Testing', 'The input-output relationship based combinatorial testing strategy considers the interactions of factors and generates test suite to cover them rather than to cover all t-way interactions. It is a very effective combinatorial testing method. However in some cases, for its characteristic of black-box testing, the identified input-output relationships may actually be inexistent or incomplete and the range of faults diagnosis is wide. To address these issues, we apply the quotient space theory in input-output combinatorial testing and extend the model of the traditional strategy to be used for gray-box testing by identifying the input-output relationships of different granules of program and constructing the test suite for each granule. In the end of the paper, we have evaluated the strategy using a case study, which indicates the effectiveness of it.', NULL);
INSERT INTO `list` VALUES (222, '0000-00-00', 2010, 'inproceedings', 'Myra B. Cohen, Shmuel Ur', 'Combinatorial test design in practice', 'Other', 'Survey', '2010 International Conference on Software Engineering', 'ICSE', '', '', '495-496', '', '10.1145/1810295.1810447', 'Combinatorial Testing', 'Combinatorial testing is a specification based sampling technique that provides a systematic way to select combinations of program inputs or features for testing. It has been applied over the years to test input data, configurations, web forms, protocols, graphical user interfaces and for testing software product lines. This tutorial introduces the fundamentals of combinatorial testing, including both practical and theoretical foundations, to provide a comprehensive introduction that is relevant to both test practitioners and software engineering researchers. The tutorial will present an overview of Combinatorial Test Design (CTD) and describe some state of the art research advances and domains where CTD has been applied. It will present the theoretical underpinnings of CTD and explain a few algorithmic techniques used to generate CTD samples, as well as describe recent work on practical extensions to these algorithms that allow for a broader use of CTD. A session devoted to modeling test problems using CTD will follow, with attendees obtaining hands-on experience using several realistic problems.', NULL);
INSERT INTO `list` VALUES (223, '0000-00-00', 2010, 'inproceedings', 'Feifei Ma', 'Constraint solving techniques for software testing and analysis', 'Evaluation', '', '2010 International Conference on Software Engineering', 'ICSE', '', '', '417-420', '', '10.1145/1810295.1810407', 'Combinatorial Testing', 'Software testing and analysis are very important research topics in software engineering. We are interested in improving the accuracy of analysis, as well as automation of test generation. In particular, we have been working on the automatic generation of small Orthogonal Arrays which can be used for combinatorial testing, and the computation of path execution frequency for a program path. The basic idea is to reduce the original problems to constraint satisfaction problems and develop effective constraint solving techniques for solving the problems.', NULL);
INSERT INTO `list` VALUES (224, '0000-00-00', 2010, 'inproceedings', 'Peter Gorm Larsen, Kenneth Lausdahl, Nick Battle', 'Combinatorial Testing for VDM', 'Application', '', '2010 International Conference on Software Engineering and Formal Methods', 'SEFM ', '', '', '278-285', '', '10.1109/SEFM.2010.32', 'Combinatorial Testing', 'Combinatorial testing in VDM involves the automatic generation and execution of a large collection of test cases derived from templates provided in the form of trace definitions added to a VDM specification. The main value of this is the rapid detection of run-time errors caused by forgotten preconditions as well as broken invariants and post-conditions. Trace definitions are defined as regular expressions describing possible sequences of operation calls, and are conceptually similar to UML sequence diagrams. In this paper we present a tool enabling test automation based on VDM traces, and explain how it is possible to reduce large collections of test cases in different ways. Its use is illustrated with a small case study.', NULL);
INSERT INTO `list` VALUES (225, '0000-00-00', 2010, 'inproceedings', 'Gilles Perrouin, Sagar Sen, Jacques Klein, Benoit Baudry, Yves Le Traon', 'Automated and Scalable T-wise Test Case Generation Strategies for Software Product Lines', 'Generation', 'Software Product Line', '2010 International Conference on Software Testing, Verification and Validation', 'ICST', '', '', '459-468', '', '10.1109/ICST.2010.43', 'Combinatorial Testing', 'Software Product Lines (SPL) are difficult to validate due to combinatorics induced by variability across their features. This leads to combinatorial explosion of the number of derivable products. Exhaustive testing in such a large space of products is infeasible. One possible option is to test SPLs by generating test cases that cover all possible T feature interactions (T-wise). T-wise dramatically reduces the number of test products while ensuring reasonable SPL coverage. However, automatic generation of test cases satisfying T-wise using SAT solvers raises two issues. The encoding of SPL models and T-wise criteria into a set of formulas acceptable by the solver and their satisfaction which fails when processed “all-at-once\'”. We propose a scalable toolset using Alloy to automatically generate test cases satisfying T-wise from SPL models. We define strategies to split T-wise combinations into solvable subsets. We design and compute metrics to evaluate strategies on Aspect OPTIMA, a concrete transactional SPL.', NULL);
INSERT INTO `list` VALUES (226, '0000-00-00', 2010, 'inproceedings', 'Si Huang, Myra B. Cohen, Atif M. Memon', 'Repairing GUI Test Suites Using a Genetic Algorithm', 'Generation', 'Search Based', '2010 International Conference on Software Testing, Verification and Validation', 'ICST', '', '', '245-254', '', '10.1109/ICST.2010.39', 'Combinatorial Testing', 'Recent advances in automated functional testing of Graphical User Interfaces (GUIs) rely on deriving graph models that approximate all possible sequences of events that may be executed on the GUI, and then use the graphs to generate test cases (event sequences) that achieve a specified coverage goal. However, because these models are only approximations of the actual event flows, the generated test cases may suffer from problems of infeasibility, i.e., some events may not be available for execution causing the test case to terminate prematurely. In this paper we develop a method to automatically repair GUI test suites, generating new test cases that are feasible. We use a genetic algorithm to evolve new test cases that increase our test suite\'s coverage while avoiding infeasible sequences. We experiment with this algorithm on a set of synthetic programs containing different types of constraints and for test sequences of varying lengths. Our results suggest that we can generate new test cases to cover most of the feasible coverage and that the genetic algorithm outperforms a random algorithm trying to achieve the same goal in almost all cases.', NULL);
INSERT INTO `list` VALUES (227, '0000-00-00', 2010, 'inproceedings', 'Bjorn Johansson, Raghu N. Kacker, Ruediger Kessel, Charles McLean, Ram Sriram', 'Utilizing combinatorial testing on discrete event simulation models for sustainable manufacturing', 'Application', '', '2010 International Design Engineering Technical Conferences and Computers and Information in Engineering Conference', 'IDETC-CIE', '2', '', '1095-1101', '', '10.1115/DETC2009-86522', 'Combinatorial Testing', 'This paper describes how combinatorial testing using covering arrays can be implemented to optimize discrete event simulation models of manufacturing systems for measures of sustainability. Discrete event simulation models often have hundreds of parameters and many test values for each parameter. Generally the interactions between the parameter-values are not well understood; this can lead to sub-optimization of the system. Most optimization engines and software for discrete event simulation packages use full factorial designs, which require many runs and hence a lot of computation time. In this paper we introduce combinatorial testing using a test-suite generation tool called NIST-ACTS (National Institute of Standards and Technology - Advanced Combinatorial Test Suites) to dramatically decrease the number of runs required to detect the interactions and determine an optimal solution.', NULL);
INSERT INTO `list` VALUES (228, '0000-00-00', 2010, 'inproceedings', 'Jianjun Yuan, Zuowen Jiang', 'Constructing Prioritized Interaction Test Suite with Interaction Relationship', 'Optimization', 'Priority', '2010 International Workshop on Education Technology and Computer Science', 'ICETC', '', '', '181-184', '', '10.1109/ETCS.2010.239', 'Combinatorial Testing', 'Interaction testing has addressed some issues on how to select a small subset of test cases. In many systems where interaction testing is needed, the entire test suite is not executed because of time or budget constraints. It is important to prioritize the test cases in these situations. On the other hand, there are not always interactions among any factors in real systems. Moreover, some factors may need N-way (N>2) testing since there is a closer relationship among them. We present a model for prioritized interaction testing with interaction relationship and propose a greedy algorithm for generating variable strength covering arrays with bias.', NULL);
INSERT INTO `list` VALUES (229, '0000-00-00', 2010, 'article', 'Andrea Calvagna, Angelo Gargantini', 'A Formal Logic Approach to Constrained Combinatorial Testing', 'Generation', 'Constraint', '2010 Journal of Automated Reasoning', 'J Autom Reason', '45', '4', '331-358', '', '10.1007/s10817-010-9171-4', 'Combinatorial Testing', 'Combinatorial testing is as an effective testing technique to reveal failures in a given system, based on input combinations coverage and combinatorial optimization. Combinatorial testing of strength t (t ≥ 2) requires that each t-wise tuple of values of the different system input parameters is covered by at least one test case. Combinatorial test suite generation algorithms aim at producing a test suite covering all the required tuples in a small (possibly minimal) number of test cases, in order to reduce the cost of testing. The most used combinatorial technique is the pairwise testing (t = 2) which requires coverage of all pairs of input values. Constrained combinatorial testing takes also into account constraints over the system parameters, for instance forbidden tuples of inputs, modeling invalid or not realizable input values combinations. In this paper a new approach to combinatorial testing, tightly integrated with formal logic, is presented. In this approach, test predicates are used to formalize combinatorial testing as a logical problem, and an external formal logic tool is applied to solve it. Constraints over the input domain are expressed as logical predicates too, and effectively handled by the same tool. Moreover, inclusion or exclusion of select tuples is supported, allowing the user to customize the test suite layout. The proposed approach is supported by a prototype tool implementation and results of experimental assessment are also presented.', NULL);
INSERT INTO `list` VALUES (230, '0000-00-00', 2010, 'article', 'Mohammad F.J. Klaib, Sangeetha Muthuraman, Noraziah Ahmad, Roslina Sidek ', 'Tree based test case generation and cost calculation strategy for uniform parametric pairwise testing', 'Generation', '', '2010 Journal of Computer Science', 'J Comput Sci', '6', '5', '542-547', '', '10.3844/jcssp.2010.542.547', 'Combinatorial Testing', 'Problem statement: Although it is very important to test any system extensively it is usually too expensive to do so owing to the cost and the resources that are involved in it. Software testing is a very important phase of software development to ensure that the developed system is reliable. Some systematic approach for testing is essential to test any system and make it acceptable. Combinatorial software interaction testing is one which tests all possible software interactions. This interaction could be at various levels such as two way interaction (pairwise) or three or four or five or six way interactions. Combinatorial interaction testing had been used in several fields. It was reported in literature that pairwise combinatorial interaction testing had identified most of the software faults. Approach: In this study we proposed a new strategy for test suite generation, a tree generation strategy for pairwise combinatorial software testing, with parameters of equal values. The algorithm considered one parameter at a time systematically to generate the tree until all the parameters were considered. This strategy used a cost calculation technique iteratively for each of the leaf nodes to generate the test suite until all the combinations were covered. Results: The experimental data showed that we had achieved about 88% (or more in some cases) of reduction in the number of test cases needed for a complete pairwise combinatorial software interaction testing. Conclusion: Thus, the strategy proposed had achieved a significant reduction in minimizing the number of test cases that was generated.', NULL);
INSERT INTO `list` VALUES (231, '0000-00-00', 2010, 'incollection', 'Mutsunori Banbara, Haruki Matsunaka, Naoyuki Tamura, Katsumi Inoue', 'Generating combinatorial test cases by efficient SAT encodings suitable for CDCL SAT solvers', 'Generation', 'Constraint', '2010 Logic for Programming, Artificial Intelligence, and Reasoning', 'Book', '6397', '', '112-126', 'Springer Berlin Heidelberg', '10.1007/978-3-642-16242-8_9', 'Combinatorial Testing', 'Generating test cases for combinatorial testing is to find a covering array in Combinatorial Designs. In this paper, we consider the problem of finding optimal covering arrays by SAT encoding. We present two encodings suitable for modern CDCL SAT solvers. One is based on the order encoding that is efficient in the sense that unit propagation achieves the bounds consistency in CSPs. Another one is based on a combination of the order encoding and Hnich’s encoding. CDCL SAT solvers have an important role in the latest SAT technology. The effective use of them is essential for enhancing efficiency. In our experiments, we found solutions that can be competitive with the previously known results for the arrays of strength two to six with small to moderate size of components and symbols. Moreover, we succeeded either in proving the optimality of known bounds or in improving known lower bounds for some arrays.', NULL);
INSERT INTO `list` VALUES (232, '0000-00-00', 2010, 'techreport', 'D. Richard Kuhn, Raghu N. Kacker, Yu Lei', 'Practical combinatorial testing', 'Application', '', '2010 National Institute of Standards & Technology', 'NIST', '', '800-142', '', '', 'not found', 'Combinatorial Testing', 'Combinatorial testing can help detect problems like this early in the testing life cycle. The key insight underlying t-way combinatorial testing is that not every parameter contributes to every fault and most faults are caused by interactions between a relatively small number of parameters. This publication provides a self-contained tutorial on using combinatorial testing for real-world software, including how to use it effectively for system and software assurance. It introduces the key concepts and methods, explains use of software tools for generating combinatorial tests (freely available on the NIST web site csrc.nist.gov/acts), and discusses advanced topics such as the use of formal models of software to determine the expected results for each set of test inputs. With each topic, a section on costs and practical considerations explains tradeoffs and limitations that may impact resources or funding. The material is accessible to an undergraduate student of computer science or engineering, and includes an extensive set of references to papers that provide more depth on each topic.', NULL);
INSERT INTO `list` VALUES (233, '0000-00-00', 2010, 'incollection', 'Mohammad F.J. Klaib, Sangeetha Muthuraman, Noraziah Ahmad, Roslina Sidek', 'A Parallel Tree Based Strategy for Test Data Generation and Cost Calculation for Pairwise Combinatorial Interaction Testing', 'Generation', '', '2010 Networked Digital Technologies', 'Book', '88', '', '509-522', 'Springer Berlin Heidelberg', '10.1007/978-3-642-14306-9_51', 'Combinatorial Testing', 'Software testing is a very important phase of the software development cycle which ensures that the system developed is reliable and acceptable. Optimizing the test suite size of software eliminates the unnecessary cost and resources that are involved in testing. Sometimes it is not possible to exhaustively test any system due to huge number of test cases. In order to test any system and make it acceptable, combinatorial software interaction testing has been used in several fields. Investigations have concluded that most of the software faults could be identified by pairwise combinatorial interaction testing. Researchers have applied parallel algorithms to various combinatorial optimisation problems and have succeeded in significant time reduction in solving the problems. Large and/or computationally expensive optimization problems sometimes require parallel or high-performance computing systems to achieve reasonable running times.\r\n\r\nIn this paper we propose a new strategy, “A Parallel Tree Based Strategy for Pairwise Combinatorial Interaction Testing”. The proposed strategy is based on two algorithms, a parallel tree generation algorithm and a parallel cost calculation algorithm, which are used in constructing a test suite with minimum number of test cases. The correctness of the strategy has been proved, and imperial results show that our strategy is efficient in test size reduction.', NULL);
INSERT INTO `list` VALUES (234, '0000-00-00', 2010, 'techreport', 'Carmelo Montanez, D. Richard Kuhn, Mary Brady, Richard M. Rivello, Jenise Reyes, Michael K. Powers', 'An Application of Combinatorial Methods to Conformance Testing for Document Object Model Events', 'Application', '', '2010 NIST Internal Report', 'NIST ', '', 'NISTIR 7773', '', '', 'not found', 'Combinatorial Testing', 'This report describes the use of combinatorial test\r\nmethods to reduce the cost of testing for the Document Object\r\nModel Events standard while maintaining an equivalent level of\r\nassurance. More than 36,000 tests – all possible combinations of\r\nequivalence class values –were reduced by approximately a\r\nfactor of 20 with no reduction in error detection effectiveness. \r', NULL);
INSERT INTO `list` VALUES (235, '0000-00-00', 2010, 'incollection', 'Sebastian Oster, Florian Markert, Philipp Ritter', 'Automated Incremental Pairwise Testing of Software Product Lines', 'Generation', 'Software Product Line', '2010 Software Product Lines: Going Beyond', 'Book', '6287', '', '196-210', 'Springer Berlin Heidelberg', '10.1007/978-3-642-15579-6_14', 'Combinatorial Testing', 'Testing Software Product Lines is very challenging due to a high degree of variability leading to an enormous number of possible products. The vast majority of today’s testing approaches for Software Product Lines validate products individually using different kinds of reuse techniques for testing. Due to the enormous number of possible products, individual product testing becomes more and more unfeasible. Combinatorial testing offers one possibility to test a subset of all possible products. In this contribution we provide a detailed description of a methodology to apply combinatorial testing to a feature model of a Software Product Line. We combine graph transformation, combinatorial testing, and forward checking for that purpose. Additionally, our approach considers predefined sets of products.', NULL);
INSERT INTO `list` VALUES (236, '0000-00-00', 2010, 'incollection', 'Beatriz Pérez Lamancha, Macario Polo', 'Testing Product Generation in Software Product Lines Using Pairwise for Features Coverage', 'Generation', 'Software Product Line', '2010 Testing Software and Systems', 'Book', '6435', '', '111-125', 'Springer Berlin Heidelberg', '10.1007/978-3-642-16573-3_9', 'Combinatorial Testing', 'A Software Product Lines (SPL) is \"a set of software-intensive systems sharing a common, managed set of features that satisfy the specific needs of a particular market segment or mission and that are developed from a common set of core assets in a prescribed way\". Variability is a central concept that permits the generation of different products of the family by reusing core assets. It is captured through features which, for a SPL, define its scope. Features are represented in a feature model, which is later used to generate the products from the line. From the testing point of view, testing all the possible combinations in feature models is not practical because: (1) the number of possible combinations (i.e., combinations of features for composing products) may be untreatable, and (2) some combinations may contain incompatible features. Thus, this paper resolves the problem by the implementation of combinatorial testing techniques adapted to the SPL context.', NULL);
INSERT INTO `list` VALUES (238, '0000-00-00', 2011, 'article', 'Changhai Nie, Hareton Leung', 'A survey of combinatorial testing', 'Other', 'Survey', '2011 ACM Computing Surveys', 'CSUR', '43', '2', '11:1-11:29', '', '10.1145/1883612.1883618', 'Combinatorial Testing', 'Combinatorial Testing (CT) can detect failures triggered by interactions of parameters in the Software Under Test (SUT) with a covering array test suite generated by some sampling mechanisms. It has been an active field of research in the last twenty years. This article aims to review previous work on CT, highlights the evolution of CT, and identifies important issues, methods, and applications of CT, with the goal of supporting and directing future practice and research in this area. First, we present the basic concepts and notations of CT. Second, we classify the research on CT into the following categories: modeling for CT, test suite generation, constraints, failure diagnosis, prioritization, metric, evaluation, testing procedure and the application of CT. For each of the categories, we survey the motivation, key issues, solutions, and the current state of research. Then, we review the contribution from different research groups, and present the growing trend of CT research. Finally, we recommend directions for future CT research, including: (1) modeling for CT, (2) improving the existing test suite generation algorithm, (3) improving analysis of testing result, (4) exploring the application of CT to different levels of testing and additional types of systems, (5) conducting more empirical studies to fully understand limitations and strengths of CT, and (6) combining CT with other testing techniques.', NULL);
INSERT INTO `list` VALUES (239, '0000-00-00', 2011, 'article', 'Changhai Nie, Hareton Leung', 'The Minimal Failure-Causing Schema of Combinatorial Testing', 'Diagnosis', '', '2011 ACM Transactions on Software Engineering and Methodology', 'TOSEM', '20', '4', '15:1-15:38', '', '10.1145/2000799.2000801', 'Combinatorial Testing', 'Combinatorial Testing (CT) involves the design of a small test suite to cover the parameter value combinations so as to detect failures triggered by the interactions among these parameters. To make full use of CT and to extend its advantages, this article first gives a model of CT and then presents a theory of the Minimal Failure-causing Schema (MFS), including the concept of the MFS, proof of its existence, some of its properties, and a method of finding the MFS. Then we propose a methodology for CT based on this MFS theory and the existing research. Our MFS-based methodology emphasizes that CT should work on accurate testing requirements, and has the following advantages: 1) Detect failure to the greatest degree with the least cost. 2) Effectiveness is improved by emphasizing mining of the information in software and making full use of the information gained from test design and execution. 3) Determine the root causes of failures and reveal related faults near the exposed ones. 4) Provide a foundation and model for regression testing and software quality evaluation of CT. A case study is presented to illustrate the MFS-based CT methodology, and an empirical study on a real software developed by us shows that the MFS really exists and the methodology based on MFS can considerably improve CT.', NULL);
INSERT INTO `list` VALUES (240, '0000-00-00', 2011, 'incollection', 'Loreto Gonzalez-Hernandez, Jose Torres-Jimenez, Nelson Rangel-Valdez', 'An Exact Approach to Maximize the Number of Wild Cards in a Covering Array', 'Optimization', 'Reduction', '2011 Advances in Artificial Intelligence', 'AI Adv', '7094', '', '210-221', 'Springer Berlin Heidelberg', '10.1007/978-3-642-25324-9_18', 'Combinatorial Testing', 'Covering Arrays CA(N;t,k,v) are combinatorial structures that can be used to define adequate test suites for software testing. The smaller a CA is, the smaller the number of test cases that will be given to test the functionality of a software component in order to identify possible failures. Due to the fact that the construction of CAs of optimal size is a highly combinatorial problem, several approximated strategies have been developed. Some constructions of these strategies can be further improved through a post optimization process. For example, the wild card profile of a CA is the set of symbols that can be modified without changing the properties that define a CA. It has been shown that some CAs can be reduced by merging rows that contain wild cards. This paper presents a Branch and Bound (B&B) strategy that maximizes the number of wild cards in the profile of an already constructed CA. We identify such profiles in 106 CAs of strength t = 2 and alphabets v from 6 to 25. Also, it is shown that for an specific CA(42;2,8,6) different profiles can be obtained; such profiles vary in the number of wild cards and their distribution in the CA.', NULL);
INSERT INTO `list` VALUES (241, '0000-00-00', 2011, 'incollection', 'Oscar Carrizales-Turrubiates, Nelson Rangel-Valdez, Jose Torres-Jimenez', 'Optimal Shortening of Covering Arrays', 'Optimization', 'Reduction', '2011 Advances in Artificial Intelligence', 'AI Adv', '7094', '', '198-209', 'Springer Berlin Heidelberg', '10.1007/978-3-642-25324-9_17', 'Combinatorial Testing', 'A Covering Array (CA), denoted by CA(N ; t, k, v), is a matrix of size N ×k with entries from the set {0,1,2,...,v − 1}, where in each submatrix of size N ×t appears each combination of symbols derived from v t, at least once. The Covering Arrays (CAs) are combinatorial structures that have applications in software testing. This paper defines the Problem of Optimal Shortening of Covering ARrays (OSCAR), gives its NP-Completeness proof and presents an exact and a greedy algorithms to solve it. The OSCAR problem is an optimization problem that for a given matrix M consists in finding a submatrix M′ that is close to be a CA. An algorithm that solves the OSCAR problem has application as an initialization function of a metaheuristic algorithm that constructs CAs. Our algorithms were tested on a benchmark formed by 20 instances of the OSCAR problem, derived from 12 CAs taken from the scientific literature. From the solutions of the 20 instances of the OSCAR problem, 12 were transformed into CAs through a previously reported metaheuristic algorithm for the construction of CAs.', NULL);
INSERT INTO `list` VALUES (242, '0000-00-00', 2011, 'incollection', 'Kamal Z. Zamli, Rozmie R. Othman, Mohammed I. Younis, Mohd Hazli Mohamed Zabil', 'Practical adoptions of T-way strategies for interaction testing', 'Application', 'Tutorial', '2011 Communications in Computer and Information Science', 'CCIS', '', '', '1--14', '', '10.1007/978-3-642-22203-0_1', 'Combinatorial Testing', 'This paper discusses the practical adoption of t-way strategies (also termed interaction testing) for interaction testing. Unlike earlier work, this paper also highlights and unifies the different possible use of t-way strategies including uniform interaction, variable strength interaction, and input-output based relations. In order to help engineers make informed decision on the different use of t-way strategies, this paper discusses the main issues and shortcomings to be considered as well as demonstrates some practical results with a-step-by-step example. In doing so, this paper also analyzes the related works highlighting the current state-of-the-arts and capabilities of some of the existing t-way strategy implementations.', NULL);
INSERT INTO `list` VALUES (243, '0000-00-00', 2011, 'incollection', 'Sabira Khatun, Khandakar F. Rabbi, Che Y. Yaakub, Mohammad F.J. Klaib, Mohammad M. Ahmed', 'PS2Way: An efficient pairwise search approach for test data generation', 'Generation', 'Search Based', '2011 Communications in Computer and Information Science', 'CCIS', '', '', '99-108', '', '10.1007/978-3-642-22203-0_9', 'Combinatorial Testing', 'Testing is a very important task to build error free software. Usually, the resources and time to market a software product is limited, hence, it is impossible to perform exhaustive test i.e., to test all combinations of input data. Pairwise (2way) test data generation approach supports higher reduction of exhaustive numbers as well as low cost and effective. In pairwise approach, most of the software faults are caused by unusual combination of input data. Hence, optimization in terms of number of generated test-cases and execution time is in demand. This paper proposes an enhanced pairwise search approach (PS2Way) of input values for optimum test data generation. This approach searches the most coverable pairs by pairing parameters and adopts one-test-at-a-time strategy to construct final test suites. PS2Way is effective in terms of number of generated test cases and execution time compared to other existing strategies.', NULL);
INSERT INTO `list` VALUES (244, '0000-00-00', 2011, 'inproceedings', 'Martin F. Johansen, Oystein Haugen, Franck Fleurey', 'Bow tie testing: a testing pattern for product lines', 'Application', '', '2011 European Conference on Pattern Languages of Programs', 'EuroPLoP', '', '', '9:1-9:13', '', '10.1145/2396716.2396725', 'Combinatorial Testing', 'Verification of highly configurable systems poses a significant challenge, the challenge of knowing that every configuration works when there often are intractably many different configurations. When a homogeneous abstraction layer has many mutually exclusive alternative implementations, we might, according to the polymorphic server test pattern, test these implementations using one test suite targeted towards the abstraction layer which is then run for each concrete implementation of the abstraction layer. But, the pattern does not handle interaction testing. Combinatorial interaction testing is one of the more promising techniques for doing interaction testing of a software product line. The bow tie testing pattern describes how the configurations which differ only in the implementation layer require one test suite. In addition, comparing the execution results of one product with another provides for a test oracle. The pattern reduces the effort of testing a highly configurable system without reducing the error detection capabilities provided by ordinary combinatorial interaction testing. We present an example of a subset of the Eclipse IDE product line, and show that only 20 test suites is required to test 41 products, a significant reduction', NULL);
INSERT INTO `list` VALUES (245, '0000-00-00', 2011, 'inproceedings', 'Tanja E.J. Vos, Paolo Tonella, Joachim Wegener, Mark Harman, Wishnu Prasetya, Elisa Puoskari, Yarden Nir Buchbinder', 'Future Internet Testing with FITTEST', 'Application', '', '2011 European Conference on Software Maintenance and Reengineering', 'CSMR', '', '', '355-358', '', '10.1109/CSMR.2011.51', 'Combinatorial Testing', 'The complexity of the technologies involved in the Future Internet makes testing extremely challenging and demands for novel approaches and major advancement in the field. The overall aim of the FITTEST project is to address these testing challenges, by developing an integrated environment for automated testing, which can monitor the Future Internet application under test and adapt to the dynamic changes observed. Future Internet applications do not remain fixed after their release, services and components can be dynamically added by customers. Consequently, FITTEST testing will be continuous and post-release such that maintenance and quality assurance can cope with the changes in the intended use of an application after release. The testing environment will integrate, adapt and automate various techniques for continuous Future Internet testing (dynamic model inference, model-based testing, log-based diagnosis, oracle learning, combinatorial testing, concurrent testing, regression testing).', NULL);
INSERT INTO `list` VALUES (246, '0000-00-00', 2011, 'article', 'Renée C. Bryce, Sreedevi Sampath, Atif M. Memon', 'Developing a Single Model and Test Prioritization Strategies for Event-Driven Software', 'Optimization', 'Priority', '2011 IEEE Transactions on Software Engineering', 'TSE', '37', '1', '48-64', '', '10.1109/TSE.2010.12', 'Combinatorial Testing', 'Event-Driven Software (EDS) can change state based on incoming events; common examples are GUI and Web applications. These EDSs pose a challenge to testing because there are a large number of possible event sequences that users can invoke through a user interface. While valuable contributions have been made for testing these two subclasses of EDS, such efforts have been disjoint. This work provides the first single model that is generic enough to study GUI and Web applications together. In this paper, we use the model to define generic prioritization criteria that are applicable to both GUI and Web applications. Our ultimate goal is to evolve the model and use it to develop a unified theory of how all EDS should be tested. An empirical study reveals that the GUI and Web-based applications, when recast using the new model, show similar behavior. For example, a criterion that gives priority to all pairs of event interactions did well for GUI and Web applications; another criterion that gives priority to the smallest number of parameter value settings did poorly for both. These results reinforce our belief that these two subclasses of applications should be modeled and studied together.', NULL);
INSERT INTO `list` VALUES (247, '0000-00-00', 2011, 'article', 'Kamal Z. Zamli, Mohammad F.J. Klaib, Mohammed I. Younis, Nor Ashidi M. Isa, Rusli Abdullah', 'Design and implementation of a t-way test data generation strategy with automated execution tool support', 'Generation', '', '2011 Information Sciences', 'INFS', '181', '9', '1741-1758', '', '10.1016/j.ins.2011.01.002', 'Combinatorial Testing', 'To ensure an acceptable level of quality and reliability of a typical software product, it is desirable to test every possible combination of input data under various configurations. However, due to the combinatorial explosion problem, exhaustive testing is practically impossible. Resource constraints, cost factors, and strict time-to-market deadlines are some of the main factors that inhibit such a consideration. Earlier research has suggested that a sampling strategy (i.e., one that is based on a t-way parameter interaction) can be effective. As a result, many helpful t-way sampling strategies have been developed and can be found in the literature.\r\n\r\nSeveral advances have been achieved in the last 15 years, which have, in particular, served to facilitate the test planning process by systematically minimizing the test size required (based on certain t-way parameter interactions). Despite this significant progress, the integration and automation of strategies (from planning process to execution) are still lacking. Additionally, strategizing to sample (and construct) a minimum test set from the exhaustive test space is an NP-complete problem; that is, it is often unlikely that an efficient strategy exists that could regularly generate an optimal test set. Motivated by these challenges, this paper discusses the design, implementation, and validation of an efficient strategy for t-way testing, the GTWay strategy. The main contribution of GTWay is the integration of t-way test data generation with automated (concurrent) execution as part of its tool implementation. Unlike most previous methods, GTWay addresses the generation of test data for a high coverage strength (t > 6).', NULL);
INSERT INTO `list` VALUES (248, '0000-00-00', 2011, 'inproceedings', 'Rozmie R. Othman, Kamal Z. Zamli', 'Input-input relationship constraints in T-way testing', 'Generation', 'Constraint', '2011 Interational Symposium on Industrial Electronics and Applications', 'INDEL', '', '', '527-531', '', '10.1109/ISIEA.2011.6108767', 'Combinatorial Testing', 'T-way testing is designed to detect faults due to interaction. In order to be effective, all t combinations of input parameters must be tested. While many t-way strategies can be used to generate the t-way test data (e.g. IPOG, AETG, GT-Way, Jenny, TVG and MIPOG), most do not ensure that all t combinations of input parameters can be practically tested. Addressing this issue, this paper highlights a new type of constraints that might prevent some t-way parameter interactions from being tested (and hence compromising the effectiveness of t-way testing), termed input-input relationship constraints. Apart from ensuring all t combinations are properly tested, input-input relationship constraints can further optimize the generated test data since all impossible combinations are completely ignored. In addition, this paper also introduces a new strategy that supports input-input relationship constraints and demonstrates the correctness of the strategy as well as the effectiveness of test data with input-input relationship.', NULL);
INSERT INTO `list` VALUES (249, '0000-00-00', 2011, 'inproceedings', 'A.A. Alsewari, Kamal Z. Zamli', 'Interaction test data generation using Harmony Search Algorithm', 'Generation', 'Search Based', '2011 Interational Symposium on Industrial Electronics and Applications', 'INDEL', '', '', '559-564', '', '10.1109/ISIEA.2011.6108775', 'Combinatorial Testing', 'This paper describes the adoption of Harmony Search Algorithm based strategy, called HSS, for generating interaction test data. In a nutshell, HSS generates a set of test data (as a complete test suite) that covers the t-way interaction at least once in a greedy manner (i.e. here, t indicates the interaction strength). The main feature of HSS is the fact that it is the first t-way strategy that is based on the Harmony Search Algorithm. Preliminary results demonstrate that HSS gives comparable results with other existing t-way strategies.', NULL);
INSERT INTO `list` VALUES (250, '0000-00-00', 2011, 'inproceedings', 'Sebastian Oster, Ivan Zorcic, Florian Markert, Malte Lochau', 'MoSo-PoLiTe: tool support for pairwise and model-based software product line testing', 'Application', 'Software Product Line, Tool', '2011 Interational Workshop on Variability Modeling of Software-Intensive Systems', 'VaMoS', '', '', '79-82', '', '10.1145/1944892.1944901', 'Combinatorial Testing', 'Testing Software Product Lines is a very challenging task and approaches like combinatorial testing and model-based testing are frequently used to reduce the effort of testing Software Product Lines and to reuse test artifacts. In this contribution we present a tool chain realizing our MoSo-PoLiTe concept combining combinatorial and model-based testing. Our tool chain contains a pairwise configuration selection component on the basis of a feature model. This component implements an heuristic finding a minimal subset of configurations covering 100% pairwise interaction. Additionally, our tool chain allows the model-based test case generation for each configuration within this generated subset. This tool chain is based on commercial tools since it was developed within industrial cooperations. A non-commercial implementation of pairwise configuration selection is available and an integration with an Open Source model-based testing tool is under development.', NULL);
INSERT INTO `list` VALUES (251, '0000-00-00', 2011, 'inproceedings', 'Renée C. Bryce, Charles J. Colbourn, D. Richard Kuhn', 'Finding Interaction Faults Adaptively Using Distance-Based Strategies', 'Generation', '', '2011 International Conference and Workshops on Engineering of Computer-Based Systems', 'ECBS', '', '', '4--13', '', '10.1109/ECBS.2011.9', 'Combinatorial Testing', 'Software systems are typically large and exhaustive testing of all possible input parameters is usually not feasible. Testers select tests that they anticipate may catch faults, yet many unanticipated faults may be overlooked. This work complements current testing methodologies by adaptively dispensing one-test-at-a-time, where each test is as \"distant\" as possible from previous tests. Two types of distance measures are explored: (1) distance defined in relation to combinations of parameter-values not previously tested together and (2) distance computed as the maximum minimal Hamming distance from previous tests. Experiments compare the effectiveness of these two types of distance-based tests and random tests. Experiments include simulations, as well as examination of instrumented data from an actual system, the Traffic Collision Avoidance System (TCAS). Results demonstrate that the two instantiations of distance-based tests often find more faults sooner and in fewer tests than randomly generated tests.', NULL);
INSERT INTO `list` VALUES (253, '0000-00-00', 2011, 'inproceedings', 'Xiaoying Pan, Hao Chen', 'Using Organizational Evolutionary Particle Swarm Techniques to Generate Test Cases for Combinatorial Testing', 'Generation', 'Search Based', '2011 International Conference on Computational Intelligence and Security', 'CIS', '', '', '1580-1583', '', '10.1109/CIS.2011.354', 'Combinatorial Testing', 'Based on the analysis of the characteristics of combinatorial testing, an organizational evolutionary particle swarm algorithm (OEPST) to generate test cases for combinatorial testing is proposed. This algorithm is used to select the test cases of local optimal coverage in current environment based on these test cases, and then a test suite satisfying the pair-wise coverage criterion is built. The empirical results show that this approach can effectively reduce the number of test case.', NULL);
INSERT INTO `list` VALUES (254, '0000-00-00', 2011, 'inproceedings', 'Khandakar F. Rabbi, Sabira Khatun, Che Y. Yaakub, Mohammad F.J. Klaib', 'EasyA: Easy and Effective Way to Generate Pairwise Test Data', 'Generation', '', '2011 International Conference on Computational Intelligence, Communication Systems and Networks', 'CICSN', '', '', '164-167', '', '10.1109/CICSyN.2011.44', 'Combinatorial Testing', 'Testing is a very important task to build error free software. As the resources and time to market is limited for a software product, it is impossible to perform exhaustive test i.e., to test all combinations of input data. To reduce the number of test cases in an acceptable level, it is preferable to use higher interaction level (t way, where t = 2). Pairwise (2- way or t = 2) interaction can find most of the software faults. This paper proposes a matrix based calculation for pairwise test data generation algorithm named EasyA to optimize the number of test cases. Java program has been used to test the performance of the algorithm. The performance is better than the existing algorithms/tools in terms of number of generated test cases and time consumption.', NULL);
INSERT INTO `list` VALUES (255, '0000-00-00', 2011, 'inproceedings', 'Pedro Flores, Yoonsik Cheon', 'PWiseGen: Generating test cases for pairwise testing using genetic algorithms', 'Generation', 'Search Based', '2011 International Conference on Computer Science and Automation Engineering', 'CSAE', '', '', '747-752', '', '10.1109/CSAE.2011.5952610', 'Combinatorial Testing', 'Pairwise testing is a combinatorial testing technique that tests all possible pairs of input values. Although, finding a smallest set of test cases for pairwise testing is NP-complete, pairwise testing is regarded as a reasonable cost-benefit compromise among combinatorial testing methods. In this paper we formulate the problem of finding a pairwise test set as a search problem and apply a genetic algorithm to solve it. We also describe an open-source tool called PWiseGen for generating pairwise test sets. PWiseGen produces competitive results compared with existing pairwise testing tools. Besides, it provides a framework and a research platform for generating pairwise test sets using genetic algorithms; it is configurable, extensible, and reusable.', NULL);
INSERT INTO `list` VALUES (256, '0000-00-00', 2011, 'inproceedings', 'Wenhua Wang, Yu Lei, Donggang Liu, David Kung, Christoph Csallner, Dazhi Zhang, Raghu N. Kacker, D. Richard Kuhn', 'A combinatorial approach to detecting buffer overflow vulnerabilities', 'Application', '', '2011 International Conference on Dependable Systems and Networks', 'DSN', '', '', '269-278', '', '10.1109/DSN.2011.5958225', 'Combinatorial Testing', 'Buffer overflow vulnerabilities are program defects that can cause a buffer to overflow at runtime. Many security attacks exploit buffer overflow vulnerabilities to compromise critical data structures. In this paper, we present a black-box testing approach to detecting buffer overflow vulnerabilities. Our approach is motivated by a reflection on how buffer overflow vulnerabilities are exploited in practice. In most cases the attacker can influence the behavior of a target system only by controlling its external parameters. Therefore, launching a successful attack often amounts to a clever way of tweaking the values of external parameters. We simulate the process performed by the attacker, but in a more systematic manner. A novel aspect of our approach is that it adapts a general software testing technique called combinatorial testing to the domain of security testing. In particular, our approach exploits the fact that combinatorial testing often achieves a high level of code coverage. We have implemented our approach in a prototype tool called Tance. The results of applying Tance to five open-source programs show that our approach can be very effective in detecting buffer overflow vulnerabilities.', NULL);
INSERT INTO `list` VALUES (257, '0000-00-00', 2011, 'inproceedings', 'Sabira Khatun, Khandakar F. Rabbi, Che Y. Yaakub, Mohammad F.J. Klaib', 'A Random search based effective algorithm for pairwise test data generation', 'Generation', 'Search Based', '2011 International Conference on Electrical, Control and Computer Engineering', 'ICECCE', '', '', '293-297', '', '10.1109/INECCE.2011.5953894', 'Combinatorial Testing', 'Testing is a very important task to build error free software. As the resources and time to market is limited for a software product, it is impossible to perform exhaustive test i.e., to test all combinations of input data. To reduce the number of test cases in an acceptable level, it is preferable to use higher interaction level (t way, where t ≥ 2). Pairwise (2-way or t = 2) interaction can find most of the software faults. This paper proposes an effective random search based pairwise test data generation algorithm named R2Way to optimize the number of test cases. Java program has been used to test the performance of the algorithm. The algorithm is able to support both uniform and non-uniform values effectively with performance better than the existing algorithms/tools in terms of number of generated test cases and time consumption.', NULL);
INSERT INTO `list` VALUES (259, '0000-00-00', 2011, 'inproceedings', 'Martin F. Johansen, Oystein Haugen, Franck Fleurey', 'Properties of realistic feature models make combinatorial testing of product lines feasible', 'Generation', 'Software Product Line, Constraint', '2011 International conference on Model driven engineering languages and systems', 'MODELS', '', '', '638-652', '', '10.1007/978-3-642-24485-8_47', 'Combinatorial Testing', 'Feature models and associated feature diagrams allow modeling and visualizing the constraints leading to the valid products of a product line. In terms of their expressiveness, feature diagrams are equivalent to propositional formulas which makes them theoretically expensive to process and analyze. For example, satisfying propositional formulas, which translates into finding a valid product for a given feature model, is an NP-hard problem, which has no fast, optimal solution. This theoretical complexity could prevent the use of powerful analysis techniques to assist in the development and testing of product lines. However, we have found that satisfying realistic feature models is quick. Thus, we show that combinatorial interaction testing of product lines is feasible in practice. Based on this, we investigate covering array generation time and results for realistic feature models and find where the algorithms can be improved.', NULL);
INSERT INTO `list` VALUES (260, '0000-00-00', 2011, 'inproceedings', 'Beatriz Marín, Tanja E.J. Vos, Giovanni Giachetti, Arthur Baars, Paolo Tonella', 'Towards testing future Web applications', 'Application', '', '2011 International Conference on Research Challenges in Information Science', 'RCIS', '', '', '1--12', '', '10.1109/RCIS.2011.6006859', 'Combinatorial Testing', 'The current Web applications are in continuous evolution to provide new and more complex functionalities, which can improve the user experience by means of adaptivity and dynamic changes. Since testing is the most frequently used technique to evaluate the quality of software applications in industry, novel testing approaches will be necessary to evaluate the quality of future (and more complex) web applications. In this paper, we investigate the testing challenges of future web applications and propose a testing methodology that addresses these challenges by the integration of search-based testing, model-based testing, oracle learning, concurrency testing, combinatorial testing, regression testing, and coverage analysis. This paper also presents a testing metamodel that states testing concepts and their relationships, which are used as the theoretical basis of the proposed testing methodology.', NULL);
INSERT INTO `list` VALUES (261, '0000-00-00', 2011, 'inproceedings', 'Baiqiang Chen, Jian Zhang', 'Tuple density: a new metric for combinatorial test suites', 'Evaluation', '', '2011 International Conference on Software Engineering', 'ICSE', '', '', '876-879', '', '10.1145/1985793.1985931', 'Combinatorial Testing', 'We propose tuple density to be a new metric for combinatorial test suites. It can be used to distinguish one test suite from another even if they have the same size and strength. Moreover, it is also illustrated how a given test suite can be optimized based on this metric. The initial experimental results are encouraging. ', NULL);
INSERT INTO `list` VALUES (262, '0000-00-00', 2011, 'inproceedings', 'Sreedevi Sampath, Renée C. Bryce, Sachin Jain, Schuyler Manchester', 'A Tool for Combinatorial-based Prioritization and Reduction of User-Session-Based Test Suites', 'Application', 'Tool', '2011 International Conference on Software Maintenance', 'ICSM', '', '', '574-577', '', '10.1109/ICSM.2011.6080833', 'Combinatorial Testing', 'Test suite prioritization and reduction are two approaches to managing large test suites. They play an important role in regression testing, where a large number of tests accumulate over time from previous versions of the system. Accumulation of tests is exacerbated in user-session-based testing of web applications, where field usage data is continually logged and converted into test cases. This paper presents a tool that allows testers to easily collect, prioritize, and reduce user-session-based test cases. Our tool provides four contributions: (1) guidance to users on how to configure their web server to log important usage information, (2) automated parsing of web logs into XML formatted test cases that can be used by test replay tools, (3) automated prioritization of test cases by length-based and combinatorial-based criteria, and (4) automated reduction of test cases by combinatorial coverage.', NULL);
INSERT INTO `list` VALUES (263, '0000-00-00', 2011, 'inproceedings', 'D. Richard Kuhn, Raghu N. Kacker', 'Practical combinatorial (t-way) methods for detecting complex faults in regression testing', 'Application', '', '2011 International Conference on Software Maintenance', 'ICSM', '', '', '599-599', '', '10.1109/ICSM.2011.6080840', 'Combinatorial Testing', 'Regression testing can be among the most challenging of software assurance tasks because program changes often introduce faults, including unexpected interactions among different parts of the code. Unanticipated interactions may also occur when software is modified for a new platform. Techniques such as pairwise testing are not sufficient for detecting these faults, because empirical evidence shows that some errors are triggered only by the interaction of three, four, or more parameters. However, new algorithms and tools make it possible to generate tests that cover complex combinations of values (2-way to 6-way), or to analyze existing test suites and automatically generate tests that provide combinatorial coverage. The key advantage of this approach is that it produces better testing using a fraction of the tests required by other methods.', NULL);
INSERT INTO `list` VALUES (264, '0000-00-00', 2011, 'inproceedings', 'Elke Salecker, Robert Reicherdt, Sabine Glesner', 'Calculating prioritized interaction test sets with constraints using binary decision diagrams', 'Generation', 'Priority, Constraint', '2011 International Conference on Software Testing, Verification and Validation Workshops', 'ICSTW', '', '', '278-285', '', '10.1109/ICSTW.2011.79', 'Combinatorial Testing', 'Combinatorial interaction testing has become an established technique to systematically determine test sets for highly-configurable software systems. The generation of minimal test sets that fullfill the demanded coverage criteria is an NP-complete problem. Constraint handling and integrated test case prioritization, features necessary for practical use, further complicate the problem. We present a novel algorithm that exploits our observation that the combinatorial interaction testing problem with constraints can be modelled as a single propositional logic formula. Our test set calculation algorithm uses binary decision diagrams as efficient data structure for this formula. The algorithm supports constraints and prioritization. Our evaluation results prove its cost effectiveness. For many benchmark problems the algorithm calculates the best results compared to other greedy approaches.', NULL);
INSERT INTO `list` VALUES (265, '0000-00-00', 2011, 'inproceedings', 'G. Varvara, V. Sandu', 'Implementation and covering analysis for the T-way combinatorial testing strategy', 'Evaluation', '', '2011 International Conference on System Theory, Control, and Computing', 'ICSTCC', '', '', '1--6', '', 'not found', 'Combinatorial Testing', 'The paper stands from the general concepts of combinatorial testing in order to point out the benefits of the automatically generated tests based on the t-way combinatorial techniques. Then it implements an optimal strategy that reduce the necessary number of test cases and analysis its effectiveness on practical examples that involves a reduce number of correlated input parameters. Some remarks on the proposed implementations cost and test covering advantages conclude this work.', NULL);
INSERT INTO `list` VALUES (266, '0000-00-00', 2011, 'article', 'Ziyuan Wang, Lin Chen, Baowen Xu, Yan Huang', 'Cost-cognizant combinatorial test case prioritization', 'Optimization', 'Priority', '2011 International Journal of Software Engineering and Knowledge Engineering', 'IJSEKE', '21', '6', '829-854', '', '10.1142/S0218194011005499', 'Combinatorial Testing', 'Combinatorial testing has been widely used in practice. People usually assume all test cases in combinatorial test suite will run completely. However, in many scenarios where combinatorial testing is needed, for example the regression testing, the entire combinatorial test suite is not run completely as a result of test resource constraints. To improve the efficiency of testing, combinatorial test case prioritization technique is required. For the scenario of regression testing, this paper proposes a new cost-cognizant combinatorial test case prioritization technique, which takes both combination weights and test costs into account. Here we propose a series of metrics with physical meaning, which assess the combinatorial coverage efficiency of test suite, to guide the prioritization of combinatorial test cases. And two heuristic test case prioritization algorithms, which are based on total and additional techniques respectively, are utilized in our technique. Simulation experimental results illustrate some properties and advantages of proposed technique.', NULL);
INSERT INTO `list` VALUES (267, '0000-00-00', 2011, 'article', 'Vincent C. Hu, D. Richard Kuhn, Tao Xie, Jeehyun Hwang', 'Model Checking for Verification of Mandatory Access Control Models and Properties', 'Application', '', '2011 International Journal of Software Engineering and Knowledge Engineering', 'IJSEKE', '21', '1', '103-127', '', '10.1142/S021819401100513X', 'Combinatorial Testing', 'Mandatory access control (MAC) mechanisms control which users or processes have access to which resources in a system. MAC policies are increasingly specified to facilitate managing and maintaining access control. However, the correct specification of the policies is a very challenging problem. To formally and precisely capture the security properties that MAC should adhere to, MAC models are usually written to bridge the rather wide gap in abstraction between policies and mechanisms. In this paper, we propose a general approach for property verification for MAC models. The approach defines a standardized structure for MAC models, providing for both property verification and automated generation of test cases. The approach expresses MAC models in the specification language of a model checker and expresses generic access control properties in the property language. Then the approach uses the model checker to verify the integrity, coverage, and confinement of these properties for the MAC models and finally generates test cases via combinatorial covering array for the system implementations of the models.', NULL);
INSERT INTO `list` VALUES (268, '0000-00-00', 2011, 'article', 'Renée C. Bryce, Sreedevi Sampath, Jan B. Pedersen, Schuyler Manchester', 'Test suite prioritization by cost-based combinatorial interaction coverage', 'Optimization', 'Priority', '2011 International Journal of System Assurance Engineering and Management', 'JSAEM', '2', '2', '126-134', '', '10.1007/s13198-011-0067-4', 'Combinatorial Testing', 'Test suite prioritization techniques modify the order in which tests within a test suite run. The goal is to order tests such that they detect faults as early as possible in the test execution cycle. Prioritization by combinatorial interaction coverage is a recent criterion that has been useful for prioritizing test suites for GUI and web applications. While studies show that this prioritization criterion can be valuable, previous studies compute the interaction coverage without considering the cost of individual tests. This paper proposes a new cost-based combinatorial interaction coverage metric, an algorithm to compute the new metric, and an empirical study with three subject web applications. Two of our studies show that prioritization by the new metric improves the rate at which faults are detected in relation to cost. A third study reveals an interesting result that the success of the cost-based metric is influenced by the distribution of t-tuples in the selected test cases.', NULL);
INSERT INTO `list` VALUES (269, '0000-00-00', 2011, 'article', 'Rozmie R. Othman, Kamal Z. Zamli', 'T-Way Strategies and Its Applications for Combinatorial Testing', 'Application', '', '2011 International Journal on New Computer Architectures and Their Applications', 'IJNCAA', '1', '2', '459-473', '', 'not found', 'Combinatorial Testing', 'The demand for multi-functional software has grown drastically over the years. To cater for this demand, software engineers are forced to develop complex software with increasing number of input parameters. As a result, more and more dependencies between input parameters are to be expected, opening more possibilities of faults due to interactions. Although traditional static and dynamic testing strategies (e.g. boundary value analysis, cause and effect analysis and equivalent partitioning) are useful in fault detection and prevention [1], however they are not sufficiently effective to detect faults due to interaction. As a result, many researchers nowadays are focusing on sampling strategy that is based on interaction testing (termed t-way testing strategies where t indicates the interaction strength)', NULL);
INSERT INTO `list` VALUES (270, '0000-00-00', 2011, 'inproceedings', 'Sebastian Oster, Marius Zink, Malte Lochau, Mark Grechanik', 'Pairwise feature-interaction testing for SPLs: potentials and limitations', 'Application', '', '2011 International Software Product Line Conference', 'SPLC', '', '', '6:1-6:8', '', '10.1145/2019136.2019143', 'Combinatorial Testing', 'A fundamental problem of testing Software Product Lines (SPLs) is that variability enables the production of a large number of instances and it is difficult to construct and run test cases even for SPLs with a small number of variable features. Interacting features is a foundation of a fault model for SPLs, where faults are likely to be revealed at execution points where features exchange information with other features or influence one another. Therefore, a test adequacy criterion is to cover as many interactions among different features as possible, thus increasing the probability of finding bugs. Our approach combines a combinatorial designs algorithm for pairwise feature generation with model-based testing to reduce the size of the SPL required for comprehensive coverage of interacting features. We implemented our approach and applied it to an SPL from the automotive domain provided by one of our industrial partners. The results suggest that with our approach higher coverage of feature interactions is achieved at a fraction of cost when compared with a baseline approach of testing all feature interactions.', NULL);
INSERT INTO `list` VALUES (272, '0000-00-00', 2011, 'inproceedings', 'Ajay Kattepur, Sagar Sen, Benoit Baudry, Albert Benveniste, Claude Jard', 'Pairwise testing of dynamic composite services', 'Application', '', '2011 International Symposium on Software Engineering for Adaptive and Self-Managing Systems', 'SEAMS', '', '', '138-147', '', '10.1145/1988008.1988028', 'Combinatorial Testing', 'Online services encapsulate enterprises, people, software systems and often operate in poorly understood environments. Using such services in tandem to predictably orchestrate a complex task is one of the principal challenges of service-oriented computing. A composite service orchestration soliciting multiple atomic services is plagued by a number of sources of variation. For instance, availability of an atomic service and its response time are two important sources of variation. Moreover, the number of possible variations in a composite service increases exponentially with increase in the number of atomic services. Testing such a composite service presents a crucial challenge as its often very expensive to exhaustively examine the variation space. Can we effectively test the dynamic behavior of a composite service using only a subset of these variations? This is the question that intrigues us. In this paper, we first model composite service variability as a feature diagram (FD) that captures all valid configurations of its orchestration. Second, we apply pairwise testing to sample the set of all possible configurations to obtain a concise subset. Finally, we test the composite service for selected pairwise configurations for a variety of QoS metrics such as response time, data quality, and availability. Using two case studies, Car crash crisis management and eHealth management, we demonstrate that pairwise generation effectively samples the full range of QoS variations in a dynamic orchestration. The pairwise sampling technique eliminates over 99% redundancy in configurations, while still calling all atomic services at least once. We rigorously evaluate pairwise testing for the criteria such as: a) ability to sample the extreme QoS metrics of the service b) stable behavior of the extracted configurations c) compact set of configurations that can help evaluate QoS tradeoffs and d) comparison with random sampling.', NULL);
INSERT INTO `list` VALUES (273, '0000-00-00', 2011, 'inproceedings', 'Aymeric Hervieu, Benoit Baudry, Arnaud Gotlieb', 'PACOGEN: Automatic Generation of Pairwise Test Configurations from Feature Models', 'Generation', 'Software Product Line', '2011 International Symposium on Software Reliability Engineering', 'ISSRE', '', '', '120-129', 'IEEE', '10.1109/ISSRE.2011.31', 'Combinatorial Testing', 'Feature models are commonly used to specify variability in software product lines. Several tools support feature models for variability management at different steps in the development process. However, tool support for test configuration generation is currently limited. This test generation task consists in systematically selecting a set of configurations that represent a relevant sample of the variability space and that can be used to test the product line. In this paper we propose \\pw tool to analyze feature models and automatically generate a set of configurations that cover all pair wise interactions between features. \\pw tool relies on constraint programming to generate configurations that satisfy all constraints imposed by the feature model and to minimize the set of the tests configurations. This work also proposes an extensive experiment, based on the state-of-the art SPLOT feature models repository, showing that \\pw tool scales over variability spaces with millions of configurations and covers pair wise with less configurations than other available tools.', NULL);
INSERT INTO `list` VALUES (274, '0000-00-00', 2011, 'inproceedings', 'Zhiqiang Zhang, Jian Zhang', 'Characterizing failure-causing parameter interactions by adaptive testing', 'Diagnosis', '', '2011 International Symposium on Software Testing and Analysis', 'ISSTA', '', '', '331-341', '', '10.1145/2001420.2001460', 'Combinatorial Testing', 'Combinatorial testing is a widely used black-box testing technique, which is used to detect failures caused by parameter interactions (we call them faulty interactions). Traditional combinatorial testing techniques provide fault detection, but most of them provide weak fault diagnosis. In this paper, we propose a new fault characterization method called faulty interaction characterization (FIC) and its binary search alternative FIC_BS to locate one failure-causing interaction in a single failing test case. In addition, we provide a tradeoff strategy of locating multiple faulty interactions in one test case. Our methods are based on adaptive black-box testing, in which test cases are generated based on outcomes of previous tests. For locating a t-way faulty interaction, the number of test cases used is at most k (for FIC) or t(dlog2 k] + 1) + 1 (for FIC_BS), where k is the number of parameters. Simulation experiments show that our method needs smaller number of adaptive test cases than most existing methods for locating randomly-generated faulty interactions. Yet it has stronger or equivalent ability of locating faulty interactions.', NULL);
INSERT INTO `list` VALUES (275, '0000-00-00', 2011, 'inproceedings', 'Emine Dumlu, Cemal Yilmaz, Myra B. Cohen, Adam Porter', 'Feedback driven adaptive combinatorial testing', 'Application', '', '2011 International Symposium on Software Testing and Analysis', 'ISSTA', '', '', '243-253', '', '10.1145/2001420.2001450', 'Combinatorial Testing', 'The configuration spaces of modern software systems are too large to test exhaustively. Combinatorial interaction testing (CIT) approaches, such as covering arrays, systematically sample the configuration space and test only the selected configurations. The basic justification for CIT approaches is that they can cost-effectively exercise all system behaviors caused by the settings of t or fewer options. We conjecture, however, that in practice many such behaviors are not actually tested because of masking effects -- failures that perturb execution so as to prevent some behaviors from being exercised. In this work we present a feedback-driven, adaptive, combinatorial testing approach aimed at detecting and working around masking effects. At each iteration we detect potential masking effects, heuristically isolate their likely causes, and then generate new covering arrays that allow previously masked combinations to be tested in the subsequent iteration. We empirically assess the effectiveness of the proposed approach on two large widely used open source software systems. Our results suggest that masking effects do exist and that our approach provides a promising and efficient way to work around them.', NULL);
INSERT INTO `list` VALUES (276, '0000-00-00', 2011, 'inproceedings', 'Itai Segall, Rachel Tzoref-Brill, Eitan Farchi', 'Using binary decision diagrams for combinatorial test design', 'Generation', '', '2011 International Symposium on Software Testing and Analysis', 'ISSTA', '', '', '254-264', '', '10.1145/2001420.2001451', 'Combinatorial Testing', 'Combinatorial test design (CTD) is an effective test planning technique that reveals faulty feature interaction in a given system. The test space is modeled by a set of parameters, their respective values, and restrictions on the value combinations. A subset of the test space is then automatically constructed so that it covers all valid value combinations of every t parameters, where t is a user input. Various combinatorial testing tools exist, implementing different approaches to finding a set of tests that satisfies t-wise coverage. However, little consideration has been given to the process of defining the test space for CTD, which is usually a manual, labor-intensive, and error-prone effort. Potential errors include missing parameters and their values, wrong identification of parameters and of valid value combinations, and errors in the definition of restrictions that cause them not to capture the intended combinations. From our experience, lack of support for the test space definition process is one of the main obstacles in applying CTD to a wide range of testing domains.\r\n\r\nIn this work, we present a Cartesian product based methodology and technology that assist in defining a complete and consistent test space for CTD. We then show how using binary decision diagrams (BDDs) to represent and build the test space dramatically increases the scalability of our approach, making it applicable to large and complex real-life test design tasks, for which explicit representation of the test space is infeasible.\r\n\r\nFinally, we show how BDDs can be used also to solve the CTD problem itself. We present a new and highly effective BDD-based approach for solving CTD, which finds a set of tests that satisfies t-wise coverage by subset selection. Our approach supports also advanced requirements such as requirements on the distribution of values in the selected tests. We apply our algorithm to real-life testing problems of varying complexity, and show its superior performance.', NULL);
INSERT INTO `list` VALUES (277, '0000-00-00', 2011, 'article', 'Bestoun S. Ahmed, Kamal Z. Zamli', 'The development of a particle swarm based optimization strategy for pairwise testing', 'Generation', 'Search Based', '2011 Journal of Artificial Intelligence', 'AIJ', '4', '2', '156-165', '', '10.3923/jai.2011.156.165', 'Combinatorial Testing', 'Pairwise testing strategies are used to select test cases from a large search space considering the interactions of test input parameters in order to minimize the test suite size. We normally want that all 2-way interactions of parameters’ values occur in the test suit at least once. Due to the large and complex search space in the interaction problems, different techniques have been used to deal with this search space. Artificial intelligent techniques have been regarded as being especially adequate search strategies, since they are able to deal with search for optimization. Two of the well known algorithms are Genetic Algorithm (GA) and Ant Colony Algorithm (ACA). However, other heuristic search techniques have started to compete with GA and ACA such as Particle Swarm Optimization (PSO) in the context of algorithm simplicity and performance. This study presents the development of a new pairwise test data generation strategy based on PSO, called Pairwise Particle Swarm-based Test Generator (PPSTG). In doing so, this study also highlights PPSTG design as well as compares its performance in terms of test size against other existing strategies. PPSTG serves as our research vehicle to investigate the effectiveness of PSO for pairwise test data generation. The experimental results and comparisons of our strategy showed that our strategy can generate comparable results as far as the size of the test suite is concerned.', NULL);
INSERT INTO `list` VALUES (278, '0000-00-00', 2011, 'article', 'Bestoun S. Ahmed, Kamal Z. Zamli', 'A Variable Strength Interaction Test Suites Generation Strategy Using Particle Swarm Optimization', 'Generation', 'Search Based', '2011 Journal of Systems and Software', 'JSS', '84', '12', '2171-2185', '', '10.1016/j.jss.2011.06.004', 'Combinatorial Testing', 'This paper highlights a novel strategy for generating variable-strength (VS) interaction test suites, called VS Particle Swarm Test Generator (VS-PSTG). As the name suggests, VS-PSTG adopts Particle Swarm Optimization to ensure optimal test size reduction. To determine its efficiency in terms of the size of the generated test suite, VS-PSTG was subjected to well-known benchmark configurations. Comparative results indicate that VS-PSTG gives competitive results as compared to existing strategies. An empirical case study was conducted on a non-trivial software system to show the applicability of the strategy and to determine the effectiveness of the generated test suites to detect faults.', NULL);
INSERT INTO `list` VALUES (279, '0000-00-00', 2011, 'incollection', 'Mohammad F.J. Klaib, Sangeetha Muthuraman, Noraziah Ahmad', 'A Parallel Tree Based Strategy for T-Way Combinatorial Interaction Testing', 'Generation', '', '2011 Software Engineering and Computer Systems', 'other', '', '', '91-98', 'Springer Berlin Heidelberg', '10.1007/978-3-642-22203-0_8', 'Combinatorial Testing', 'All software systems are built with basic components which interact with each other through predefined combination rules. As the number of components increases, the interactions between the components also increases exponentially which cause the combinatorial explosion problem. This mean complete (exhaustive) testing becomes unreasonable due to the huge number of possible combinations. Although 2-way interaction testing (i.e. pairwise testing) can relief and detect 50-97 percent of errors, empirical evidence has proved that 2-way interaction testing is a poor strategy for testing highly interactive systems and it has been showed that most of the errors are triggered by the interaction of 2-6 input parameters. In this paper we enhanced our previous strategy, “A Tree Based Strategy for Test Data Generation and Cost Calculation” by applying parallel algorithms to go beyond pairwise testing. The proposed strategy can support higher interaction testing. The designed algorithms are described in details with efficient empirical results.', NULL);
INSERT INTO `list` VALUES (280, '0000-00-00', 2011, 'article', 'James Lawrence, Raghu N. Kacker, Yu Lei, D. Richard Kuhn, Michael Forbes', 'A Survey of Binary Covering Arrays', 'Other', 'Survey', '2011 The Electronic Journal of Combinatorics', 'other', '18', '1', '1--30', '', '10.37236/571', 'Combinatorial Testing', 'Binary covering arrays of strength $t$ are 0–1 matrices having the property that for each $t$ columns and each of the possible $2^t$ sequences of $t$ 0\'s and 1\'s, there exists a row having that sequence in that set of $t$ columns. Covering arrays are an important tool in certain applications, for example, in software testing. In these applications, the number of columns of the matrix is dictated by the application, and it is desirable to have a covering array with a small number of rows. Here we survey some of what is known about the existence of binary covering arrays and methods of producing them, including both explicit constructions and search techniques. ', NULL);
INSERT INTO `list` VALUES (281, '0000-00-00', 2011, 'article', 'Elizabeth Maltais, Lucia Moura', 'Hardness results for covering arrays avoiding forbidden edges and error-locating arrays', 'Generation', 'Constraint', '2011 Theoretical Computer Science', 'TCS', '412', '46', '6517-6530', '', '10.1016/j.tcs.2011.07.010', 'Combinatorial Testing', 'Covering arrays avoiding forbidden edges (CAFEs) are used in testing applications (software, networks, circuits, drug interaction, material mixtures, etc.) where certain combinations of parameter values are forbidden. Danziger et al. (2009) [8] have studied this problem and shown some computational complexity results. Around the same time, Martinez et al. (2009) [19] defined and studied error-locating arrays (ELAs), which are closely related to CAFEs. Both papers left some computational complexity questions. In particular, these papers showed polynomial-time solvability of the existence of CAFEs and ELAs for binary alphabets (\r\n), and the NP-hardness of these problems for \r\n. In this paper, we prove that optimizing CAFEs and ELAs is indeed NP-hard even when restricted to the case of binary alphabets, using a reduction from edge clique covers of graphs (ECCs). We also provide a hardness of approximation result. We explore important relationships between ECCs and CAFEs and give some new bounds for uniform ECCs and CAFEs.', NULL);
INSERT INTO `list` VALUES (282, '0000-00-00', 2012, 'inproceedings', 'Atlee M. Cunningham Jr, Jon Hagar, Ryan J. Holman', 'A System Analysis Study Comparing Reverse Engineered Combinatorial Testing to Expert Judgment', 'Application', '', '2012 1st International Workshop on Combinatorial Testing', 'IWCT', '', '', '630-635', 'IEEE', '10.1109/ICST.2012.151', 'Combinatorial Testing', 'The Lockheed Martin F-16 ventral fin redesign-combinatorial test study effort was to demonstrate how Combinatorial Testing (CT) could have been applied to system hardware design flaw analysis. The historic analysis was able to determine a set of combinations, which isolated the problem and tested a solution. However, the original effort was expensive, time consuming, and required highly specialized knowledge from the expert to be effective. The new study was an effort to understand if combinatorial test could be applied to similar situations using the original data but conducted by a less senior person without an expert\'s knowledgebase. The situation and CT approaches are detailed in this paper. In the study, a series of iterations created combinatorial test cases which could have \"replicated\" the original highly optimized and successful test program, without the expert.', NULL);
INSERT INTO `list` VALUES (283, '0000-00-00', 2012, 'inproceedings', 'Angelo Gargantini, Paolo Vavassori', 'CITLAB: A Laboratory for Combinatorial Interaction Testing', 'Application', 'Tool', '2012 1st International Workshop on Combinatorial Testing', 'IWCT', '', '', '559-568', 'IEEE', '10.1109/ICST.2012.141', 'Combinatorial Testing', 'Although the research community around combinatorial interaction testing has been very active for several years, it has failed to find common solutions on some issues. First of all, there is not a common abstract nor concrete language to express combinatorial problems. Combinatorial testing generator tools are strongly decoupled making difficult their interoperability and the exchange of models and data. In this paper, we propose an abstract and concrete specific language for combinatorial problems. It features and formally defines the concepts of parameters and types, constraints, seeds, and test goals. The language is defined by means of XTEXT, a framework for the definition of domain-specific languages. XTEXT is used to derive a powerful editor integrated with eclipse and with all the expected features of a modern editor. Eclipse is also used to build an extensible framework in which test generators, importers, and exporters can be easily added as plugins.', NULL);
INSERT INTO `list` VALUES (284, '0000-00-00', 2012, 'inproceedings', 'Elke Salecker, Sabine Glesner', 'Combinatorial Interaction Testing for Test Selection in Grammar-Based Testing', 'Application', '', '2012 1st International Workshop on Combinatorial Testing', 'IWCT', '', '', '610-619', 'IEEE', '10.1109/ICST.2012.148', 'Combinatorial Testing', 'Systematically enumerating derivations of a grammar yields for realistic grammars test sets that are to large to be tested with reasonable costs. Existing reduction techniques for grammar-based testing guide the enumeration process to restrict the number of generated test cases. However, they do not provide a rule coverage criterion, i.e., they do not aim at providing a test set that ensures coverage of t-wise rule combinations. Selecting derivations such that all possible t-wise rule combinations are covered with at least one test case allows for the generation of small test sets. We employ combinatorial interaction testing to generate the test sets and derive the necessary test specification from the grammar specification automatically. Our evaluation results are twofold. First, they demonstrate the efficiency of our approach. Second, they reveal shortcomings of existing tools for combinatorial interaction testing with constraints.', NULL);
INSERT INTO `list` VALUES (285, '0000-00-00', 2012, 'inproceedings', 'D. Richard Kuhn, James M. Higdon, James Lawrence, Raghu N. Kacker, Yu Lei', 'Combinatorial Methods for Event Sequence Testing', 'Application', 'Sequence CA', '2012 1st International Workshop on Combinatorial Testing', 'IWCT', '', '', '601-609', 'IEEE', '10.1109/ICST.2012.147', 'Combinatorial Testing', 'Many software testing problems involve sequences of events. This paper applies combinatorial methods to testing problems that have n distinct events, where each event occurs exactly once. The methods described in this paper were motivated by testing needs for systems that may accept multiple communication or sensor connections and generate output to several communication links and other interfaces, where it is important to test the order in which connections occur. Although pair wise event order testing (both A followed by B and B followed by A) has been described, our algorithm ensures that any t events will be tested in every possible t-way order.', NULL);
INSERT INTO `list` VALUES (286, '0000-00-00', 2012, 'inproceedings', 'Rudolf Ramler, Theodorich Kopetzky, Wolfgang Platz', 'Combinatorial Test Design in the TOSCA Testsuite: Lessons Learned and Practical Implications', 'Application', '', '2012 1st International Workshop on Combinatorial Testing', 'IWCT', '', '', '569-572', 'IEEE', '10.1109/ICST.2012.142', 'Combinatorial Testing', 'The advantage of combinatorial techniques over less structured approaches is supported by the experience from numerous real-world projects where a significant reduction of the number of test cases has been achieved without compromising functional coverage. However, to fully benefit from combinatorial testing, the applied techniques and tools have to satisfy the requirements and needs of testers and practitioners. In this paper we explore such requirements distilled from testing software systems for over 15 years across a wide range of projects in business and industry. Their practical implications span from mastering the combinatorial explosion over support for fault localization to understandability, changeability and maintainability. Finally, the paper illustrates how the different combinatorial techniques are able to meet these requirements. The combinatorial techniques discussed in this paper are part of the TOSCA Test suite developed by TRICENTIS.', NULL);
INSERT INTO `list` VALUES (287, '0000-00-00', 2012, 'inproceedings', 'Mehra N. Borazjany, Linbin Yu, Yu Lei, Raghu N. Kacker, D. Richard Kuhn', 'Combinatorial Testing of ACTS: A Case Study', 'Application', '', '2012 1st International Workshop on Combinatorial Testing', 'IWCT', '', '', '591-600', 'IEEE', '10.1109/ICST.2012.146', 'Combinatorial Testing', 'In this paper we present a case study of applying combinatorial testing to test a combinatorial test generation tool called ACTS. The purpose of this study is two-fold. First, we want to gain experience and insights about how to apply combinatorial testing in practice. Second, we want to evaluate the effectiveness of combinatorial testing applied to a real-life system. ACTS has 24637 lines of uncommented code, and provides a command line interface and a fairly sophisticated graphic user interface. The main challenge of this study was to model the input space in terms of a set of parameters and values. Once the model was designed, we generated test cases using ACTS, which were then later used to test ACTS. The results of this study show that input space modeling can be a significant undertaking, and needs to be carefully managed. The results also show that combinatorial testing is effective in terms of achieving high code coverage and fault detection.', NULL);
INSERT INTO `list` VALUES (288, '0000-00-00', 2012, 'inproceedings', 'Zhiqiang Zhang, Xiaojian Liu, Jian Zhang', 'Combinatorial Testing on ID3v2 Tags of MP3 Files', 'Application', '', '2012 1st International Workshop on Combinatorial Testing', 'IWCT', '', '', '587-590', 'IEEE', '10.1109/ICST.2012.145', 'Combinatorial Testing', 'In this paper, we study the testing of ID3v2 tags for MP3 files. We construct two combinatorial testing (CT) models for two test goals. One is for testing the audio players\' recognition and display of variously encoded text information, and the other is for testing its robustness against bad header and frame sizes. We have conducted experiment son an on-vehicle leisure and entertainment system and a portable MP3player. We present some experimental results in this paper.', NULL);
INSERT INTO `list` VALUES (289, '0000-00-00', 2012, 'inproceedings', 'Itai Segall, Rachel Tzoref-Brill, Aviad Zlotnick', 'Common Patterns in Combinatorial Models', 'Model', '', '2012 1st International Workshop on Combinatorial Testing', 'IWCT', '', '', '624-629', 'IEEE', '10.1109/ICST.2012.150', 'Combinatorial Testing', 'Combinatorial test design (CTD) is an effective test planning technique that systematically exercises interactions between parameters of the test space. The test space is manually modeled by a set of parameters, their respective values, and restrictions on the value combinations. A subset of the test space is then automatically constructed so that it covers all valid value combinations of every t parameters, where t is a user input. This paper describes patterns that we have found to be recurring in combinatorial models, i.e., recurring properties of the modeled test spaces. These patterns are often hard to identify and capture correctly in a model, thus are common pitfalls in combinatorial modeling. We describe these patterns, supply methods for identifying them, and suggest simple yet effective solutions for them.', NULL);
INSERT INTO `list` VALUES (290, '0000-00-00', 2012, 'inproceedings', 'William Alton Ballance, Sergiy Vilkomir, William Jenkins', 'Effectiveness of Pair-wise Testing for Software with Boolean Inputs', 'Evaluation', '', '2012 1st International Workshop on Combinatorial Testing', 'IWCT', '', '', '580-586', 'IEEE', '10.1109/ICST.2012.144', 'Combinatorial Testing', 'The pair-wise approach is a software testing technique, which generates test cases that consist of all combinations of pairs of input variable values. This paper investigates the effectiveness of the pair-wise approach for one practically important case -- testing logical expressions in software. Pair-wise effectiveness is experimentally evaluated in general terms and separately for specific types of faults. Two freely available software tools are used for pair-wise test set generation. Fault Evaluator, a software tool developed by the authors, is used for fault simulation and effectiveness evaluation. The experimental results are contrasted with data from other researchers, and the effectiveness of the pair-wise approach is compared with random testing. Quantitative analysis of pair-wise effectiveness depending on the size of expressions is also provided.', NULL);
INSERT INTO `list` VALUES (291, '0000-00-00', 2012, 'inproceedings', 'Kiran Shakya, Tao Xie, Nuo Li, Yu Lei, Raghu N. Kacker, D. Richard Kuhn', 'Isolating Failure-Inducing Combinations in Combinatorial Testing Using Test Augmentation and Classification', 'Diagnosis', '', '2012 1st International Workshop on Combinatorial Testing', 'IWCT', '', '', '620-623', 'IEEE', '10.1109/ICST.2012.149', 'Combinatorial Testing', 'Combinatorial Testing (CT) is a systematic way of sampling input parameters of the software under test (SUT). A t-way combinatorial test set can exercise all behaviors of the SUT caused by interactions between t input parameters or less. Although combinatorial testing can provide fault detection capability, it is often desirable to isolate the input combinations that cause failures. Isolating these failure-inducing combinations aids developers in understanding the causes of failures. Previous work directly uses classification tree analysis on the results of combinatorial testing to model the failure inducing combinations. But in many scenarios, the effectiveness of classification depends upon whether the analyzed test set is sufficient for classification. In addition, generating combinatorial tests for more-than-6-way combination is generally expensive. To address these issues, we propose an approach that uses existing combinatorial testing results to generate additional tests that enhance the effectiveness of classification. In addition, our approach also includes a technique to reduce the complexity of the resulting classification tree so that developers can understand the nature of failure-inducing combinations. We present the preliminary results of our approach applied on the TCAS benchmark.', NULL);
INSERT INTO `list` VALUES (292, '0000-00-00', 2012, 'inproceedings', 'Itai Segall, Rachel Tzoref-Brill, Aviad Zlotnick', 'Simplified Modeling of Combinatorial Test Spaces', 'Model', '', '2012 1st International Workshop on Combinatorial Testing', 'IWCT', '', '', '573-579', 'IEEE', '10.1109/ICST.2012.143', 'Combinatorial Testing', 'Combinatorial test design (CTD) is an effective test planning technique that reveals faults that result from feature interactions in a system. The test space is manually modeled by a set of parameters, their respective values, and restrictions on the value combinations. A subset of the test space is then automatically constructed so that it covers all valid value combinations of every t parameters, where t is usually a user input. In many real-life testing problems, the relationships between the different test parameters are complex. Thus, precisely capturing them by restrictions in the CTD model might be a very challenging and time consuming task. From our experience, this is one of the main obstacles in applying CTD to a wide range of testing problems. In this paper, we introduce two new constructs to the CTD model, counters and value properties, that considerably reduce the complexity of the modeling task, allowing one to easily model testing problems that were practically impossible to model before. We demonstrate the impact of these constructs on two real-life case studies.', NULL);
INSERT INTO `list` VALUES (296, '0000-00-00', 2012, 'incollection', 'Himer Avila-George, Jose Torres-Jimenez, Vicente Hernández', 'Constructing Real Test-Suites Using an Enhanced Simulated Annealing', 'Generation', '', '2012 Advances in Artificial Intelligence', 'AI Adv', '7637', '', '611-620', 'Springer Berlin Heidelberg', '10.1007/978-3-642-34654-5_62', 'Combinatorial Testing', 'In software systems, a common source of bugs are unexpected interactions among systems components. This risk is increased when the number of software components increases. To reduce this risk and ensure software quality, it may be necessary to test all interactions among the components. Combinatorial testing is a method that can reduce cost and increase the effectiveness of software testing for many applications. Covering arrays are combinatorial structures which can be used to represent test-suites. This paper presents a metaheuristic approach based on a simulated annealing algorithm for constructing covering arrays. The experimental design solved a benchmark reported in the literature and it is proposed a new bechkmark based on real test-cases. Experimental evidence showed that the simulated annealing algorithm equals or improves the obtained results by other approaches reported in the literature, finding the optimal solution in some of the solved cases.', NULL);
INSERT INTO `list` VALUES (297, '0000-00-00', 2012, 'inproceedings', 'J. Jenny Li, Colin L. Mallows, Jim Landwehr', 'Capacity evaluation of multi-modal network notification service', 'Application', '', '2012 Annual Computer Software and Applications Conference', 'COMPSAC', '', '', '62-71', '', '10.1109/COMPSAC.2012.16', 'Combinatorial Testing', 'A notification service alerts a large number of recipients to attend to important or emergency events. Prompt notification using multiple modes is critical to handle a disaster. This paper proposes an \"escalation hierarchy\" method as an enhancement to the combinatorial testing approach to provide capacity evaluation of a notification service involving interaction of multiple factors. Our trial of the method on an industrial large-scale notification service showed the effectiveness of our method in reducing testing efforts through automating both consistency checking of measurement data and identification of causes for capacity overflow.', NULL);
INSERT INTO `list` VALUES (298, '0000-00-00', 2012, 'article', 'Bestoun S. Ahmed, Kamal Z. Zamli, Chee Peng Lim', 'Application of Particle Swarm Optimization to uniform and variable strength covering array construction', 'Generation', 'Search Based', '2012 Applied Soft Computing', 'ASOC', '12', '4', '1330-1347', '', '10.1016/j.asoc.2011.11.029', 'Combinatorial Testing', 'Recently, researchers have started to explore the use of Artificial Intelligence (AI)-based algorithms as t-way (where t indicates the interaction strength) testing strategies. Many AI-based strategies have been developed, such as Ant Colony, Simulated Annealing, Genetic Algorithm, and Tabu Search. Although useful, most existing AI-based t-way testing strategies adopt complex search processes and require heavy computations. For this reason, existing AI-based t-way testing strategies have been confined to small interaction strengths (i.e., t ≤ 3) and small test configurations. Recent studies demonstrate the need to go up to t = 6 in order to capture most faults. In this paper, we demonstrate the effectiveness of our proposed Particle Swarm-based t-way Test Generator (PSTG) for generating uniform and variable strength covering arrays. Unlike other existing AI-based t-way testing strategies, the lightweight computation of the particle swarm search process enables PSTG to support high interaction strengths of up to t = 6. The performance of our proposed PSTG is evaluated using several sets of benchmark experiments. Comparatively, PSTG consistently outperforms its AI counterparts and other existing testing strategies as far as the size of the array is concerned. Furthermore, our case study demonstrates the usefulness of PSTG for facilitating fault detection owing to interactions of the input components.', NULL);
INSERT INTO `list` VALUES (299, '0000-00-00', 2012, 'inproceedings', 'Changhai Nie, Huayao Wu, Yalan Liang, Hareton Leung, Fei-Ching Kuo, Zheng Li', 'Search Based Combinatorial Testing', 'Generation', 'Search Based', '2012 Asia-Pacific Software Engineering Conference', 'APSEC', '', '', '778-783', '', '10.1109/APSEC.2012.16', 'Combinatorial Testing', 'Search techniques can dramatically change our ability to solve a host of problems in applied science and engineering, many search techniques have been developed and applied successfully in many fields, including search based software engineering (SBSE). As a key problem of combinatorial testing, covering array generation has been widely studied and many search techniques have been applied which can be named as search based combinatorial testing (SBCT). SBCT is a branch of search based software testing (SBST) within SBSE. In this paper, to explore the applicability and effectiveness of SBCT, we design six variants from existing search algorithms: Genetic Algorithm, Particle Swarm Optimization and Ant Colony Algorithm by reversing and randomizing their mechanisms. We study their effectiveness in terms of generating a covering array and compare their performance. Experiments show that these search techniques can work well with distinct performance in covering array generation. We believe that these search techniques can be further improved by fine-tuning their configuration and used in broad ranges of area.', NULL);
INSERT INTO `list` VALUES (300, '0000-00-00', 2012, 'incollection', 'Khandakar F. Rabbi, Abul H. Beg, Tutut Herawan', 'MT2Way: A novel strategy for pair-wise test data generation', 'Generation', '', '2012 Communications in Computer and Information Science', 'CCIS', '', '', '180-191', '', '10.1007/978-3-642-34289-9_21', 'Combinatorial Testing', 'Reducing the number of test cases by utilizing minimum possible amount of time during the testing process of software and hardware is highly desirable. For ensuring the reliability of the method the combination of a complete set of available inputs is recommended to be executed. But generally an exhaustive numbers of test cases are hard to execute. Besides, test data generation is an NP-hard (non-deterministic polynomial-time hard) problem. This is likely to present considerable difficulties in defining the best possible method for generating the test data. The reduction of test cases depends on the interaction level, 2-way interaction or pair-wise test data can reduce high number of test cases and it efficiently addresses most of the software errors. This paper presents MT2Way, an effective 2-way interaction algorithm to generate the test data which is more acceptable in terms of the number of test cases and execution time. The performance tests show that MT2Way achieve better results in terms of system configuration, generated test size, and executing time as compared to other techniques.', NULL);
INSERT INTO `list` VALUES (303, '0000-00-00', 2012, 'incollection', 'Himer Avila-George, Jose Torres-Jimenez, Vicente Hernández, Loreto Gonzalez-Hernandez', 'Simulated Annealing for Constructing Mixed Covering Arrays', 'Generation', 'Search Based', '2012 Distributed Computing and Artificial Intelligence', 'DCAI', '151', '', '657-664', 'Springer Berlin Heidelberg', '10.1007/978-3-642-28765-7_79', 'Combinatorial Testing', 'Combinatorial testing is a method that can reduce costs and increase the effectiveness of software testing for many applications. It is based on constructing test-suites of economical size, which provide coverage of the most prevalent configurations of parameters. Mixed Covering Arrays (MCAs) are combinatorial structures which can be used to represent these test-suites. This paper presents a new Simulated Annealing (SA) algorithm for Constructing MCAs. This algorithm incorporates several distinguishing features including an efficient heuristic to generate good quality initial solutions, a compound neighborhood function which carefully combines two designed neighborhoods and a fine-tuned cooling schedule. The experimental evidence showed that our SA algorithm improves the obtained results by other approaches reported in the literature, finding the optimal solution in some of the solved cases.', NULL);
INSERT INTO `list` VALUES (304, '0000-00-00', 2012, 'inbook', 'D. Richard Kuhn, Raghu N. Kacker, Yu Lei', 'Combinatorial Testing', 'Other', '', '2012 Encyclopedia of Software Engineering', 'Book', '', '', '1--30', 'Taylor and Francis', 'not found', 'Combinatorial Testing', 'not found', NULL);
INSERT INTO `list` VALUES (305, '0000-00-00', 2012, 'inproceedings', 'Peter M. Kruse, Ina Schieferdecker', 'Comparison of approaches to prioritized test generation for combinatorial interaction testing', 'Optimization', 'Priority', '2012 Federated Conference on Computer Science and Information Systems', 'FedCSIS', '', '', '1357-1364', '', 'not found', 'Combinatorial Testing', 'Due to limited test resources, it is often necessary to prioritize and select test cases for a given system under test. Although test case prioritization is well studied and understood, its combination with test data generation is difficult and not completely solved yet. For example, the Classification Tree Method is a well established method for test data generation, however the application of prioritization techniques to it is a current research topic. We present an extension of the classification tree method that allows the generation of optimized test suites, containing test cases ordered according to their importance with respect to test goals. The presented algorithms are incorporated into the Classification Tree Editor and empirically evaluated on a set of benchmarks.', NULL);
INSERT INTO `list` VALUES (306, '0000-00-00', 2012, 'incollection', 'Taha Triki, Yves Ledru, Lydie du Bousquet, Frederic Dadeau, Julien Botella', 'Model-Based filtering of combinatorial test suites', 'Generation', '', '2012 Fundamental Approaches to Software Engineering', 'FASE', '', '', '439-454', 'Springer Berlin Heidelberg', '10.1007/978-3-642-28872-2_30', 'Combinatorial Testing', 'Tobias is a combinatorial test generation tool which can efficiently generate a large number of test cases by unfolding a test pattern and computing all combinations of parameters. In this paper, we first propose a model-based testing approach where Tobias test cases are first run on an executable UML/OCL specification. This animation of test cases on a model allows to filter out invalid test sequences produced by blind enumeration, typically the ones which violate the pre-conditions of operations, and to provide an oracle for the valid ones. We then introduce recent extensions of the Tobias tool which support an incremental unfolding and filtering process, and its associated toolset. This allows to address explosive test patterns featuring a large number of invalid test cases, and only a small number of valid ones. For instance, these new constructs could mandate test cases to satisfy a given predicate at some point or to follow a given behavior. The early detection of invalid test cases improves the calculation time of the whole generation and execution process, and helps fighting combinatorial explosion.', NULL);
INSERT INTO `list` VALUES (307, '0000-00-00', 2012, 'article', 'Andrea Arcuri, Lionel Briand', 'Formal Analysis of the Probability of Interaction Fault Detection Using Random Testing', 'Evaluation', '', '2012 IEEE Transactions on Software Engineering', 'TSE', '38', '5', '1088-1099', '', '10.1109/TSE.2011.85', 'Combinatorial Testing', 'Modern systems are becoming highly configurable to satisfy the varying needs of customers and users. Software product lines are hence becoming a common trend in software development to reduce cost by enabling systematic, large-scale reuse. However, high levels of configurability entail new challenges. Some faults might be revealed only if a particular combination of features is selected in the delivered products. But testing all combinations is usually not feasible in practice, due to their extremely large numbers. Combinatorial testing is a technique to generate smaller test suites for which all combinations of t features are guaranteed to be tested. In this paper, we present several theorems describing the probability of random testing to detect interaction faults and compare the results to combinatorial testing when there are no constraints among the features that can be part of a product. For example, random testing becomes even more effective as the number of features increases and converges toward equal effectiveness with combinatorial testing. Given that combinatorial testing entails significant computational overhead in the presence of hundreds or thousands of features, the results suggest that there are realistic scenarios in which random testing may outperform combinatorial testing in large systems. Furthermore, in common situations where test budgets are constrained and unlike combinatorial testing, random testing can still provide minimum guarantees on the probability of fault detection at any interaction level. However, when constraints are present among features, then random testing can fare arbitrarily worse than combinatorial testing. As a result, in order to have a practical impact, future research should focus on better understanding the decision process to choose between random testing and combinatorial testing, and improve combinatorial testing in the presence of feature constraints.', NULL);
INSERT INTO `list` VALUES (308, '0000-00-00', 2012, 'article', 'Cemal Yilmaz', 'Test Case-Aware Combinatorial Interaction Testing', 'Generation', '', '2012 IEEE Transactions on Software Engineering', 'TSE', '39', '5', '684-706', '', '10.1109/TSE.2012.65', 'Combinatorial Testing', 'The configuration spaces of modern software systems are too large to test exhaustively. Combinatorial interaction testing (CIT) approaches, such as covering arrays, systematically sample the configuration space and test only the selected configurations by using a battery of test cases. Traditional covering arrays, while taking system-wide interoption constraints into account, do not provide a systematic way of handling test case-specific interoption constraints. The basic justification for $(t)$-way covering arrays is that they can cost effectively exercise all system behaviors caused by the settings of $(t)$ or fewer options. In this paper, we hypothesize, however, that in the presence of test case-specific interoption constraints, many such behaviors may not be tested due to masking effects caused by the overlooked test case-specific constraints. For example, if a test case refuses to run in a configuration due to an unsatisfied test case-specific constraint, none of the valid option setting combinations appearing in the configuration will be tested by that test case. To account for test case-specific constraints, we introduce a new combinatorial object, called a test case-aware covering array. A $(t)$-way test case-aware covering array is not just a set of configurations, as is the case in traditional covering arrays, but a set of configurations, each of which is associated with a set of test cases such that all test case-specific constraints are satisfied and that, for each test case, each valid combination of option settings for every combination of $(t)$ options appears at least once in the set of configurations that the test case is associated with. We furthermore present three algorithms to compute test case-aware covering arrays. Two of the algorithms aim to minimize the number of configurations required (one is fast, but produces larger arrays, the other is slower, but produces smaller arrays), whereas the remaining algorithm aims to minimize the number of test runs required. The results of our empirical studies conducted on two widely used highly configurable software systems suggest that test case-specific constraints do exist in practice, that traditional covering arrays suffer from masking effects caused by ignorance of such constraints, and that test case-aware covering arrays are better than other approaches in handling test case-specific constraints, thus avoiding masking effects.', NULL);
INSERT INTO `list` VALUES (309, '0000-00-00', 2012, 'article', 'A.A. Alsewari, Kamal Z. Zamli', 'Design and implementation of a harmony-search-based variable-strength t-way testing strategy with constraints support', 'Generation', 'Search Based', '2012 Information and Software Technology', 'IST', '54', '6', '553-568', '', '10.1016/j.infsof.2012.01.002', 'Combinatorial Testing', 'Context: Although useful, AI-based variable strength t-way strategies are lacking in terms of the support for high interaction strength. Additionally, most AI-based strategies generally do not address the support for constraints. Addressing the aforementioned issues, this paper elaborates the design, implementation, and evaluation of a novel variable-strength-based on harmony search algorithm, called Harmony Search Strategy (HSS). Objective: The objective of this work is to investigate the adoption of harmony search algorithm for constructing variable-strength t-way strategy. Method: Implemented in Java, HSS integrates the harmony search algorithm as parts of its search engine. Result: Benchmarking results demonstrate that HSS gives competitive results against most existing AI-based (and pure computational) counterparts. However, unlike other AI-based counterparts, HSS addresses the support for high interaction strength and permits the support for constraints. Conclusion: AI-based t-way strategies tend to outperform the pure computational-based strategies in terms of test size.', NULL);
INSERT INTO `list` VALUES (310, '0000-00-00', 2012, 'article', 'Jose Torres-Jimenez, Eduardo Rodriguez-Tello', 'New bounds for binary covering arrays using simulated annealing', 'Generation', 'Search Based', '2012 Information Sciences', 'INFS', '185', '1', '137-152', '', '10.1016/j.ins.2011.09.020', 'Combinatorial Testing', 'Covering arrays (CAs) are combinatorial structures specified as a matrix of N rows and k columns over an alphabet on v symbols such that for each set of t columns (called the strength of the array) every t-tuple of symbols is covered. Recently they have been used to represent interaction test suites for software testing given that they provide economical sized test cases while still preserving important fault detection capabilities.\r\n\r\nThis paper introduces an improved implementation of a simulated annealing algorithm, called ISA, for constructing CAs of strengths three through six over a binary alphabet (i.e., binary CAs). Extensive experimentation is carried out, using 127 well-known benchmark instances, for assessing its performance with respect to an existing simulated annealing implementation, a greedy method, and five state-of-the-art algorithms. The results show that our algorithm attains 104 new bounds and equals the best-known solutions for the other 23 instances consuming reasonable computational time. Furthermore, the implications of using these results as ingredients to recursive constructions are also analyzed.', NULL);
INSERT INTO `list` VALUES (311, '0000-00-00', 2012, 'inproceedings', 'Jeremy S. Bradbury, Itai Segall, Eitan Farchi, Kevin Jalbert, David Kelk', 'Using combinatorial benchmark construction to improve the assessment of concurrency bug detection tools', 'Evaluation', '', '2012 Interational Workshop on Parallel and Distributed Systems: Testing, Analysis, and Debugging', 'PADTAD', '', '', '25-35', '', '10.1145/2338967.2336812', 'Combinatorial Testing', 'Many different techniques for testing and analyzing concurrency programs have been proposed in the literature. Currently, it is difficult to assess the fitness of a particular concurrency bug detection method and to compare it to other bug detection methods due to a lack of unbiased data that is representative of the kinds of concurrency programs that are used in practice. To address this problem we propose a new benchmark of concurrent Java programs that is constructed using combinatorial test design. In this paper we present our combinatorial model for creating a benchmark, we propose a new concurrency benchmark and we discuses the relationship between our new benchmarks and existing benchmarks. Specific combinations of the model parameters define different interleaving spaces, thus differentiating between different test tools.', NULL);
INSERT INTO `list` VALUES (312, '0000-00-00', 2012, 'inproceedings', 'Rubing Huang, Xiaodong Xie, Tsong Yueh Chen, Yansheng Lu', 'Adaptive Random Test Case Generation for Combinatorial Testing', 'Generation', '', '2012 International Computers, Software & Applications Conference', 'COMPSAC', '', '', '52-61', '', '10.1109/COMPSAC.2012.15', 'Combinatorial Testing', 'Random testing (RT), a fundamental software testing technique, has been widely used in practice. Adaptive random testing (ART), an enhancement of RT, performs better than original RT in terms of fault detection capability. However, not much work has been done on effectiveness analysis of ART in the combinatorial test spaces. In this paper, we propose a novel family of ART-based algorithms for generating combinatorial test suites, mainly based on fixed-size-candidate-set ART and restricted random testing (that is, ART by exclusion). We use an empirical approach to compare the effectiveness of test sets obtained by our proposed methods and random selection strategy. Experimental data demonstrate that the ART-based tests cover all possible combinations at a given strength more quickly than randomly chosen tests, and often detect more failures earlier and with fewer test cases in simulations.', NULL);
INSERT INTO `list` VALUES (313, '0000-00-00', 2012, 'inproceedings', 'Gulsen Demiroz, Cemal Yilmaz', 'Cost-aware combinatorial interaction testing', 'Optimization', 'Priority', '2012 International Conference on Advances in System Testing and Validation Lifecycle', 'VALID', '', '', '2015/9/16 0:00:00', '', 'https://doi.org/10.1145/2771783.2784775', 'Combinatorial Testing', 'The configuration spaces of software systems are often too large to test exhaustively. Combinatorial interaction testing approaches, such as covering arrays, systematically sample the configuration space and test only the selected configurations. Traditional t-way covering arrays aim to cover all t-way combinations of option settings in a minimum number of configurations. By doing so, they assume that the testing cost of a configuration is the same for all configurations. In my thesis work, we however argue that, in practice, the actual testing cost may differ from one configuration to another and that accounting for these differences can improve the cost-effectiveness of covering arrays. To this end, we introduced a new novel combinatorial object, called a cost-aware covering array where a t-way cost-aware covering array is a t-way covering array that minimizes a given cost function. As part of progress, we developed an algorithm for a simple, yet important scenario, and the results of our empirical studies suggest that cost-aware covering arrays can greatly reduce the actual cost of testing compared to traditional covering arrays. We also defined a framework for defining the cost function but then we observed that manually creating these cost models is impractical. Hence our first future goal is to develop an approach for automatically discovering cost models for complex configuration spaces. Our second future goal is then to develop algorithms to generate cost-aware covering arrays for more general cost scenarios. Our focus is currently on meta-heuristic search algorithms such as simulated annealing and genetic algorithms to construct cost-aware covering arrays. Another goal is to expand the cost framework to be test-case aware where not every test case is valid for a configuration, hence the cost of running the test suite is actually different for each configuration.', NULL);
INSERT INTO `list` VALUES (314, '0000-00-00', 2012, 'inproceedings', 'Yves Ledru, German Vega, Taha Triki, Lydie du Bousquet', 'Test suite selection based on traceability annotations', 'Application', 'Tool', '2012 International Conference on Automated Software Engineering', 'ASE', '', '', '342-345', '', '10.1145/2351676.2351742', 'Combinatorial Testing', 'This paper describes the Tobias tool. Tobias is a combinatorial test generator which unfolds a test pattern provided by the test engineer, and performs various combinations and repetitions of test parameters and methods. Tobias is available on-line at tobias.liglab.fr . This website features recent improvements of the tool including a new input language, a traceability mechanism, and the definition of various ``selectors\'\' which achieve test suite reduction.', NULL);
INSERT INTO `list` VALUES (315, '0000-00-00', 2012, 'inproceedings', 'Longshu Li, Yingxia Cui, Yun Yang', 'Combinatorial test cases with constraints in software systems', 'Generation', 'Constraint', '2012 International Conference on Computer Supported Cooperative Work in Design', 'CSCWD', '', '', '195-199', '', '10.1109/CSCWD.2012.6221818', 'Combinatorial Testing', 'Combinatorial testing has become an important approach in software testing, and many algorithms have been developed for generating combinatorial test cases. However, few have considered the constraints between the input parameters. In this paper, we summarize existing combinatorial testing strategies with constraints and propose two novel algorithms, namely, the CCS (construct constraint set) algorithm and the CTWC (combinatorial testing with constraints) algorithm. We first utilize CCS to compute implied constraints, and then facilitate CTWC to generate test cases for the system under test. We evaluate the CCS algorithm using a case study and compare the results of the CTWC algorithm with some existing strategies. Experimental results show that our algorithm outperformed them in terms of the number of test cases.', NULL);
INSERT INTO `list` VALUES (316, '0000-00-00', 2012, 'inproceedings', 'Linbin Yu, Yu Lei, Raghu N. Kacker, D. Richard Kuhn, James Lawrence', 'Efficient Algorithms for T-way Test Sequence Generation', 'Generation', 'Sequence CA', '2012 International Conference on Engineering of Complex Computer Systems', 'ICECCS', '', '', '220-229', '', '10.1109/ICECCS20050.2012.6299217', 'Combinatorial Testing', 'Combinatorial testing has been shown to be a very effective testing strategy. Most work on combinatorial testing focuses on t-way test data generation, where each test is an unordered set of parameter values. In this paper, we study the problem of t-way test sequence generation, where each test is an ordered sequence of events. Using a general labeled transition system as the system model, we formally define the notion of t-way sequence coverage, and introduce an efficient algorithm to compute all valid t-way target sequences, i.e., sequences of t events that must be covered by at least one test sequence. We then report several algorithms to generate a set of test sequences that achieves the proposed t-way sequence coverage. These algorithms are developed as the result of a systematic exploration of the possible approaches to t-way test sequence generation, and are compared both analytically and experimentally. The results show that while these algorithms have their own advantages and disadvantages, one of them is more scalable than others while exhibiting very good performance.', NULL);
INSERT INTO `list` VALUES (317, '0000-00-00', 2012, 'inproceedings', 'Javier Ferrer, Peter M. Kruse, Francisco Chicano, Enrique Alba', 'Evolutionary algorithm for prioritized pairwise test data generation', 'Optimization', 'Priority', '2012 International conference on Genetic and evolutionary computation conference', 'GECCO', '', '', '1213-1220', '', '10.1145/2330163.2330331', 'Combinatorial Testing', 'Combinatorial Interaction Testing (CIT) is a technique used to discover faults caused by parameter interactions in highly configurable systems. These systems tend to be large and exhaustive testing is generally impractical. Indeed, when the resources are limited, prioritization of test cases is a must. Important test cases are assigned a high priority and should be executed earlier. On the one hand, the prioritization of test cases may reveal faults in early stages of the testing phase. But, on the other hand the generation of minimal test suites that fulfill the demanded coverage criteria is an NP-hard problem. Therefore, search based approaches are required to find the (near) optimal test suites. In this work we present a novel evolutionary algorithm to deal with this problem. The experimental analysis compares five techniques on a set of benchmarks. It reveals that the evolutionary approach is clearly the best in our comparison. The presented algorithm can be integrated into a professional tool for CIT.', NULL);
INSERT INTO `list` VALUES (318, '0000-00-00', 2012, 'inproceedings', 'Hao Chen, Shuyan Wang, Xiaoying Pan', 'An optimal combination test suite construction method', 'Generation', '', '2012 International Conference on Natural Computation', 'ICNC', '', '', '649-653', '', '10.1109/ICNC.2012.6234766', 'Combinatorial Testing', 'Test data generation is a key problem of combination software testing. However, the complexity of test case generation problem for combinatorial testing is NP-complete. In this study, we propose a global optimization and generation method to construct combinatorial testing data. Firstly, an encoding mechanism is used to map the combinatorial testing problem domain to a binary coding space. Then, an improving ethnic group evolution algorithm (EGEA/H) is used to search the binary coding space in order to find the optimal code schema. After that, a decoding mechanism is used to read out the composition information of combinatorial testing data from the optimal code schema and construct optimal combinatorial testing suite according to it. The simulation results show this method is simple and effective, and it has the characteristics of less producing test data and time consumption.', NULL);
INSERT INTO `list` VALUES (319, '0000-00-00', 2012, 'inproceedings', 'Jie Li, Changhai Nie, Yu Lei', 'Improved Delta Debugging Based on Combinatorial Testing', 'Diagnosis', '', '2012 International Conference on Quality Software', 'QSIC', '', '', '102-105', '', '10.1109/QSIC.2012.28', 'Combinatorial Testing', 'Software fault diagnosis is a process of locating the source of faults based on the testing result (pass or fail) of each test case. It plays an important role in software debugging. However, because of the continuous expansion in software size and complexity, it becomes more and more difficult to diagnose software faults quickly and effectively. Combinatorial testing (CT) is a widely used black-box testing method. Currently, there exist some fault diagnosis methods based on CT to locate the source of faults. But they have not made full use of all information resulted from the CT process, and thus have not been very cost-effective in fault localization. This paper studies how to locate faults based on the test results of CT using a method of Delta Debugging (called Isolation). Two isolation methods, Repetitive Isolation (RI) and Strengthened Repetitive Isolation (SRI), are proposed. These two algorithms differ in the amount of CT information utilized by them. A series of experiments show that comparing to existing debug algorithm, the SRI algorithm is more cost-effective.', NULL);
INSERT INTO `list` VALUES (320, '0000-00-00', 2012, 'inproceedings', 'Itai Segall, Rachel Tzoref-Brill', 'Interactive refinement of combinatorial test plans', 'Application', '', '2012 International Conference on Software Engineering', 'ICSE', '', '', '1371-1374', '', '10.1109/ICSE.2012.6227245', 'Combinatorial Testing', 'Combinatorial test design (CTD) is an effective test planning technique that reveals faulty feature interactions in a given system. The test space is modeled by a set of parameters, their respective values, and restrictions on the value combinations. A subset of the test space is then automatically constructed so that it covers all valid value combinations of every $t$ parameters, where $t$ is a user input.\r\n\r\nWhen applying CTD to real-life testing problems, it can often occur that the result of CTD cannot be used as is, and manual modifications to the tests are performed. One example is very limited resources that significantly reduce the number of tests that can be used. Another example is complex restrictions that are not captured in the model of the test space. The main concern is that manually modifying the result of CTD might potentially introduce coverage gaps that the user is unaware of. In this paper we present a tool that supports interactive modification of a combinatorial test plan, both manually and with tool assistance. For each modification, the tool displays the new coverage gaps that will be introduced, and enables the user to take educated decisions on what to include in the final set of tests.', NULL);
INSERT INTO `list` VALUES (321, '0000-00-00', 2012, 'inproceedings', 'Charles Song, Adam Porter, Jeffrey S. Foster', 'iTree: efficiently discovering high-coverage configurations using interaction trees', 'Generation', '', '2012 International Conference on Software Engineering', 'ICSE', '', '', '903-913', '', '10.1109/TSE.2013.55', 'Combinatorial Testing', 'Modern software systems are increasingly configurable. While this has many benefits, it also makes some software engineering tasks,such as software testing, much harder. This is because, in theory,unique errors could be hiding in any configuration, and, therefore,every configuration may need to undergo expensive testing. As this is generally infeasible, developers need cost-effective technique for selecting which specific configurations they will test. One popular selection approach is combinatorial interaction testing (CIT), where the developer selects a strength t and then computes a covering array (a set of configurations) in which all t-way combinations of configuration option settings appear at least once. In prior work, we demonstrated several limitations of the CIT approach. In particular, we found that a given system\'s effective configuration space - the minimal set of configurations needed to achieve a specific goal - could comprise only a tiny subset of the system\'s full configuration space. We also found that effective configuration space may not be well approximated by t-way covering arrays. Based on these insights we have developed an algorithm called interaction tree discovery (iTree). iTree is an iterative learning algorithm that efficiently searches for a small set of configurations that closely approximates a system\'s effective configuration space. On each iteration iTree tests the system on a small sample of carefully chosen configurations, monitors the system\'s behaviors, and then applies machine learning techniques to discover which combinations of option settings are potentially responsible for any newly observed behaviors. This information is used in the next iteration to pick a new sample of configurations that are likely to reveal further new behaviors. In prior work, we presented an initial version of iTree and performed an initial evaluation with promising results. This paper presents an improved iTree algorithm in greater detail. The key improvements are based on our use of composite proto-interactions - a construct that improves iTree\'s ability to correctly learn key configuration option combinations, which in turn significantly improves iTree\'s running time, without sacrificing effectiveness. Finally, the paper presents a detailed evaluation of the improved iTree algorithm by comparing the coverage it achieves versus that of covering arrays and randomly generated configuration sets, including a significantly expanded scalability evaluation with the ~ 1M-LOC MySQL. Our results strongly suggest that the improved iTree algorithm is highly scalable and can identify a high-coverage test set of configurations more effectively than existing methods.', NULL);
INSERT INTO `list` VALUES (322, '0000-00-00', 2012, 'inproceedings', 'Xiao Qu, Mithun Acharya, Brian Robinson', 'Configuration selection using code change impact analysis for regression testing', 'Optimization', 'Selection', '2012 International Conference on Software Maintenance', 'ICSM', '', '', '129-138', '', '10.1109/ICSM.2012.6405263', 'Combinatorial Testing', 'Configurable systems that let users customize system behaviors are becoming increasingly prevalent. Testing a configurable system with all possible configurations is very expensive and often impractical. For a single version of a configurable system, sampling approaches exist that select a subset of configurations from the full configuration space for testing. However, when a configurable system changes and evolves, existing approaches for regression testing select all configurations that are used to test the old versions for testing the new version. As demonstrated in our experiments, this retest-all approach for regression testing configurable systems turns out to be highly redundant. To address this redundancy, we propose a configuration selection approach for regression testing. Formally, given two versions of a configurable system, S (old) and S\' (new), and given a set of configurations C S for testing S, our approach selects a subset C S\' of C S for regression testing S\'. Our study results on two open source systems and a large industrial system show that, compared to the retest-all approach, our approach discards 15% to 60% of configurations as redundant. Our approach also saves 20% to 55% of the regression testing time, while retaining the same fault detection capability and code coverage of the retest-all approach.', NULL);
INSERT INTO `list` VALUES (323, '0000-00-00', 2012, 'inproceedings', 'Laleh Sh. Ghandehari, Yu Lei, Tao Xie, D. Richard Kuhn, Raghu N. Kacker', 'Identifying Failure-Inducing Combinations in a Combinatorial Test Set', 'Diagnosis', '', '2012 International Conference on Software Testing, Verification and Validation', 'ICST', '', '', '370-379', '', '10.1109/ICST.2012.117', 'Combinatorial Testing', 'A t-way combinatorial test set is designed to detect failures that are triggered by combinations involving no more than t parameters. Assume that we have executed a t-way test set and some tests have failed. A natural question to ask is: What combinations have caused these failures? Identifying such combinations can facilitate the debugging effort, e.g., by reducing the scope of the code that needs to be inspected. In this paper, we present an approach to identifying failure-inducing combinations, i.e., combinations that have caused some tests to fail. Given a t-way test set, our approach first identifies and ranks a set of suspicious combinations, which are candidates that are likely to be failure-inducing combinations. Next, it generates a set of new tests, which can be executed to refine the ranking of suspicious combinations in the next iteration. This process can be repeated until a stopping condition is satisfied. We conducted an experiment in which our approach was applied to several benchmark programs. The experimental results show that our approach can effectively and efficiently identify failure-inducing combinations in these programs.', NULL);
INSERT INTO `list` VALUES (324, '0000-00-00', 2012, 'inproceedings', 'Peter M. Kruse, Jurgen Bauer, Joachim Wegener', 'Numerical Constraints for Combinatorial Interaction Testing', 'Generation', 'Constraint', '2012 International Conference on Software Testing, Verification and Validation', 'ICST', '', '', '758-763', '', '10.1109/ICST.2012.170', 'Combinatorial Testing', 'Constraints can be found in many specifications of a software system. The impact of constraints varies with the test problem, but their presence causes problems for many existing combinatorial interaction testing (CIT) tools. Of the numerous existing tools supporting CIT design only a few offer full constraints support. Of these few tools those with full published details are even rarer. In extension to existing Boolean constraints we propose numerical constraints. We discuss definition, usage and handling in this work and integrate results with the classification tree method.', NULL);
INSERT INTO `list` VALUES (325, '0000-00-00', 2012, 'inproceedings', 'Peter M. Kruse, Joachim Wegener', 'Test sequence generation from classification trees', 'Generation', '', '2012 International Conference on Software Testing, Verification and Validation', 'ICST', '', '', '539-548', '', '10.1109/ICST.2012.139', 'Combinatorial Testing', 'The combinatorial test design and combinatorial interaction testing are well studied topics. For the generation of dynamic test sequences from a formal specification of combinatorial problems, there has not been much work yet. The classification tree method implements aspects from the field of combinatorial testing. This paper extends the classification tree with additional information to allow the interpretation of the classification tree as a hierarchical concurrent state machine. Using this state machine, our new approach then uses a Multi-agent System to generate test sequences by finding and rating valid paths through the state machine.', NULL);
INSERT INTO `list` VALUES (326, '0000-00-00', 2012, 'inproceedings', 'Jian Zhang, Feifei Ma, Zhiqiang Zhang', 'Faulty interaction identification via constraint solving and optimization', 'Diagnosis', 'Constraint', '2012 International conference on Theory and Applications of Satisfiability Testing', 'SAT', '', '', '186-199', '', '10.1007/978-3-642-31612-8_15', 'Combinatorial Testing', 'Combinatorial testing (CT) is an important black-box testing method. In CT, the behavior of the system under test (SUT) is affected by several parameters/components. Then CT generates a combinatorial test suite. After the user executes a test suite and starts debugging, some test cases fail and some pass. From the perspective of a black box, the failures are caused by interaction of several parameters. It will be helpful if we can identify a small set of interacting parameters that caused the failures. This paper proposes a new automatic approach to identifying faulty interactions. It uses (pseudo-Boolean) constraint solving and optimization techniques to analyze the execution results of the combinatorial test suite. Experimental results show that the method is quite efficient and it can find faulty combinatorial interactions quickly. They also shed some light on the relation between the size of test suite and the ability of fault localization.', NULL);
INSERT INTO `list` VALUES (327, '0000-00-00', 2012, 'inproceedings', 'Mario Brcic, Damir Kalpic', 'Combinatorial testing in software projects', 'Other', 'Survey', '2012 Proceedings of the 35th International Convention MIPRO', 'MIPRO', '', '', '1508-1513', '', 'not found', 'Combinatorial Testing', 'Software systems continuously grow in size and code complexity, the latter most evident through greater component interconnectedness. This leaves more space for bugs which introduce risks such as exposure to security threats. Combinatorial testing looks for interaction failures in order to improve the system security and effectiveness guarantees. One of the most effective test selection approaches under combinatorial testing are experimental design extensions for software testing. Covering array test sets are compact while maintaining at the same time complete combinatorial coverage up to the desired level. Smaller test sets with customizable level of assurance can drive testing costs down substantially. The paper presents a survey of research into combinatorial testing suite factors while also identifying possible future research ideas.', NULL);
INSERT INTO `list` VALUES (328, '0000-00-00', 2012, 'inproceedings', 'Martin F. Johansen, Oystein Haugen, Franck Fleurey', 'An algorithm for generating t-wise covering arrays from large feature models', 'Generation', '', '2012 International Software Product Line Conference', 'SPLC', '', '', '46-55', '', '10.1145/2362536.2362547', 'Combinatorial Testing', 'A scalable approach for software product line testing is required due to the size and complexity of industrial product lines. In this paper, we present a specialized algorithm (called ICPL) for generating covering arrays from feature models. ICPL makes it possible to apply combinatorial interaction testing to software product lines of the size and complexity found in industry. For example, ICPL allows pair-wise testing to be readily applied to projects of about 7,000 features and 200,000 constraints, the Linux Kernel, one of the largest product lines where the feature model is available. ICPL is compared to three of the leading algorithms for t-wise covering array generation. Based on a corpus of 19 feature models, data was collected for each algorithm and feature model when the algorithm could finish 100 runs within three days. These data are used for comparing the four algorithms. In addition to supporting large feature models, ICPL is quick, produces small covering arrays and, even though it is non-deterministic, produces a covering array of a similar size within approximately the same time each time it is run with the same feature model.', NULL);
INSERT INTO `list` VALUES (329, '0000-00-00', 2012, 'inproceedings', 'Cu D. Nguyen, Alessandro Marchetto, Paolo Tonella', 'Combining model-based and combinatorial testing for effective test case generation', 'Generation', '', '2012 International Symposium on Software Testing and Analysis', 'ISSTA', '', '', '100-110', '', '10.1145/2338965.2336765', 'Combinatorial Testing', 'Model-based testing relies on the assumption that effective adequacy criteria can be defined in terms of model coverage achieved by a set of test paths. However, such test paths are only abstract test cases and input test data must be specified to make them concrete. We propose a novel approach that combines model-based and combinatorial testing in order to generate executable and effective test cases from a model. Our approach starts from a finite state model and applies model-based testing to generate test paths that represent sequences of events to be executed against the system under test. Such paths are transformed to classification trees, enriched with domain input specifications such as data types and partitions. Finally, executable test cases are generated from those trees using t-way combinatorial criteria.\r\n\r\nWhile test cases that satisfy a combinatorial criterion can be generated for each individual test path obtained from the model, we introduce a post-optimization algorithm that can guarantee the combinatorial criterion of choice on the whole set of test paths extracted from the model. The resulting test suite is smaller, but it still satisfies the same adequacy criterion. We developed a tool and used it to evaluate our approach on 6 subject systems of various types and sizes, to study the effectiveness of the generated test suites, the reduction achieved by the post-optimization algorithm, as well as the effort required to produce them.', NULL);
INSERT INTO `list` VALUES (330, '0000-00-00', 2012, 'inproceedings', 'Andrea Calvagna, Giuseppe Pappalardo, Emiliano Tramontana', 'A Novel Approach to Effective Parallel Computing of t-Wise Covering Arrays', 'Generation', '', '2012 International Workshop on Enabling Technologies: Infrastructure for Collaborative Enterprises', 'other', '', '', '149-153', '', '10.1109/WETICE.2012.106', 'Combinatorial Testing', 'In this paper we present a novel parallel technique to compute t-wise covering arrays. The massive computational work, implied by the considered task when large configuration spaces are modeled, is distributed over a scalable set of parallel computing resources by means of an MPI-compliant algorithm. Due to NP-completeness of the covering array problem, existing research on combinatorial generation algorithms commonly assumes this computation task as strictly sequential. Conversely, basing on inherent combinatorial properties, we show that it is possible to scatter the overall workload into several and independent processing sub-tasks, and then collect all outcomes into a global solution whose size is still comparable to that of a sequentially computed solution. Reported results show that in this way significant speed-up is achieved on the computation times with respect to the sequential computation of the same task.', NULL);
INSERT INTO `list` VALUES (331, '0000-00-00', 2012, 'inproceedings', 'Michaela Steffens, Sebastian Oster, Malte Lochau, Thomas Fogdal', 'Industrial evaluation of pairwise SPL testing with MoSo-PoLiTe', 'Application', '', '2012 International Workshop on Variability Modeling of Software-Intensive Systems', 'other', '', '', '55-62', '', '10.1145/2110147.2110154', 'Combinatorial Testing', 'Testing Software Product Lines is a very challenging task due to variability. Frequently, approaches such as combinatorial testing are used to generate representative sets of products for testing purposes instead of testing each individual product of the SPL under test. In this contribution we present the results of applying the MoSo-PoLiTe framework at Danfoss Power Electronics A/S to calculate a representative set of product configurations for black box testing purposes. Within this evaluation we use MoSo-PoLiTe\'s pairwise configuration selection component on the basis of a feature model. This component implements a heuristics finding a minimal subset of configurations covering 100% T-wise feature interaction. According to the best of our knowledge, this is the first publication providing industrial results about pairwise SPL testing.', NULL);
INSERT INTO `list` VALUES (332, '0000-00-00', 2012, 'inproceedings', 'Akhil R. Shah, Siddhartha R. Dalal', 'Combinatorial enlargement of ground-truth datasets and efficient evaluation of segmentation algorithms', 'Application', '', '2012 International Workshop on Visual Interfaces for Ground Truth Collection in Computer Vision Applications', 'other', '', '', '41-43', '', '10.1145/2304496.2304508', 'Combinatorial Testing', 'We propose a method to exponentially enlarge a small dataset of domain specific ground truth segmentation labels to evaluate the performance of segmentation algorithms. Furthermore, we adapt ideas from combinatorial software testing to efficiently infer statistics of segmentation performance by evaluating performance on only a certain subset of the combinatorially generated images. Extensions of this work to optimal sequence for performance testing and algorithm selection are also suggested.', NULL);
INSERT INTO `list` VALUES (333, '0000-00-00', 2012, 'article', 'Bestoun S. Ahmed, Kamal Z. Zamli', 'A greedy particle swarm optimization strategy for T-way software testing', 'Generation', 'Search Based', '2012 Journal of Artificial Intelligence', 'AIJ', '5', '2', '85-90', '', '10.3923/jai.2012.85.90', 'Combinatorial Testing', 'Combinatorial strategies are used as methods or mechanisms for selecting test cases using combinations of test input parameters. We normally want that all t-way combinations of parameter values occur in the test suit at least once. Artificial intelligence base search algorithms have been used within strategies for constructing near optimal test suites. In this paper, we propose a new test generation strategy, for combinatorial testing based on greedy Particle Swarm Optimization. The basic design concepts of the strategy are demonstrated through the paper. The experimental results and comparisons of our strategy showed impressive results as far as the test suite size is considered.', NULL);
INSERT INTO `list` VALUES (335, '0000-00-00', 2012, 'incollection', 'Martin F. Johansen, Oystein Haugen, Franck Fleurey, Erik Carlson, Jan Endresen, Tormod Wien', 'A technique for agile and automatic interaction testing for product lines', 'Application', 'Software Product Line', '2012 Lecture Notes in Computer Science', 'Book', '', '', '39-54', '', '10.1007/978-3-642-34691-0_5', 'Combinatorial Testing', 'Product line developers must ensure that existing and new features work in all products. Adding to or changing a product line might break some of its features. In this paper, we present a technique for automatic and agile interaction testing for product lines. The technique enables developers to know if features work together with other features in a product line, and it blends well into a process of continuous integration. The technique is evaluated with two industrial applications, testing a product line of safety devices and the Eclipse IDEs. The first case shows how existing test suites are applied to the products of a 2-wise covering array to identify two interaction faults. The second case shows how over 400,000 test executions are performed on the products of a 2-wise covering array using over 40,000 existing automatic tests to identify potential interactions faults.', NULL);
INSERT INTO `list` VALUES (336, '0000-00-00', 2012, 'incollection', 'Penghui Fan, Shuyan Wang, Jiaze Sun', 'An auto-adapted method to generate pairwise test data set', 'Generation', '', '2012 Lecture Notes in Computer Science', 'Book', '', '', '239-246', '', '10.1007/978-3-642-33478-8_30', 'Combinatorial Testing', 'The pairwise test data set generation is one of key issues of combinatorial testing. This paper presents a novel auto-adapted method to generate a pairwise test data set. In this method, all test cases are made at a time, which is called “all-tests-at-a-time”. Firstly, generate a certain number of test data sets; these test data sets have the same number of test cases. Secondly, chose the best data set and check whether it satisfy the requirements, if not ,go to next step, else the best is selected and the algorithm is end. Thirdly, update every data set: calculate the “repeat number” of each test case in a data set, chose two or three test cases according to the “repeat number”; update the selected test cases relies on “main factors” of each data set. Moreover, the classic examples are used to illustrate the performance of the proposed method. Compared with the existing algorithms, this paper provides an effective pairwise test suite generation method which updates test cases depend on the data set’s coverage not any one independent case; it takes into the relationship of every test case consideration not like the traditional methods which also find the current best case. It can help the data set improve its coverage quickly.', NULL);
INSERT INTO `list` VALUES (338, '0000-00-00', 2012, 'incollection', 'Priyanka, Inderveer Chana, Ajay Rana', 'An effective approach to build optimal T-way interaction test suites over cloud using particle swarm optimization', 'Generation', 'Search Based', '2012 Lecture Notes of the Institute for Computer Sciences, Social-Informatics and Telecommunications Engineering', 'Book', '108', '', '193-198', '', '10.1007/978-3-642-35615-5_28', 'Combinatorial Testing', 'Software testing is an expensive and time consuming activity that is often restricted by limited project budgets. There is a need for advanced software testing techniques that offer a solid cost-benefit ratio in identifying defects. Interaction testing is one such method that may offer a benefit. Combinatorial or Interaction Testing is a practical test generation technique that offers a benefit when used to complement current test generation techniques such as equivalence partitioning, boundary value analysis. There are many existing issues which have not been fully addressed. One of the key issues of Combinatorial Testing is Combinatorial Explosion problem which can be addressed through Parallelization. In this paper, we propose an effective approach to build optimal t-way interaction test suites over the cloud environment which could further reduce time and cost.', NULL);
INSERT INTO `list` VALUES (339, '0000-00-00', 2012, 'incollection', 'Martin F. Johansen, Oystein Haugen, Franck Fleurey, Anne Grete Eldegard, Torbjorn Syversen', 'Generating better partial covering arrays by modeling weights on sub-product lines', 'Generation', '', '2012 Model Driven Engineering Languages and Systems', 'Book', '7590', '', '269-284', 'Springer Berlin Heidelberg', '10.1007/978-3-642-33666-9_18', 'Combinatorial Testing', 'Generating Better Partial Covering Arrays by Modeling Weights on Sub-product Lines', NULL);
INSERT INTO `list` VALUES (340, '0000-00-00', 2012, 'inproceedings', 'Yuan Shuai, Ye Gang, Cui Jingyan, Ma Shilong', 'Research on the pairwise test case generation of two-dimensional expansion', 'Generation', '', '2012 National Conference on Information Technology and Computer Science', 'CITCS', '', '', '554-557', '', '10.2991/citcs.2012.217', 'Combinatorial Testing', 'The recently widely-spreading usage of combinatorial interaction testing is dramatically improving the effectiveness of highly-configurable software. Conventional techniques based on greedy or heuristic algorithms can lead to suboptimal result in the size of the built test suite with unstability. In this paper, a strategy for the construction of pairwise covering test cases is presented on the basis of research on previous 2-dimensional expansion algorithm to eliminate randomness and optimize efficiency that caused by itself. The proposed approach IPO_S_R is supported by symmetry property and lower bound theory. In addition, experimental assessment is also presented.', NULL);
INSERT INTO `list` VALUES (341, '0000-00-00', 2012, 'article', 'Malte Lochau, Sebastian Oster, Ursula Goltz, Andy Schurr', 'Model-based pairwise testing for feature interaction coverage in software product line engineering', 'Application', 'Software Product Line', '2012 Software Quality Journal', 'Softw. Qual. J', '20', '', '567-604', '', '10.1007/s11219-011-9165-4', 'Combinatorial Testing', 'Testing software product lines (SPLs) is very challenging due to a high degree of variability leading to an enormous number of possible products. The vast majority of today’s testing approaches for SPLs validate products individually using different kinds of reuse techniques for testing. Because of their reusability and adaptability capabilities, model-based approaches are suitable to describe variability and are therefore frequently used for implementation and testing purposes of SPLs. Due to the enormous number of possible products, individual product testing becomes more and more infeasible. Pairwise testing offers one possibility to test a subset of all possible products. However, according to the best of our knowledge, there is no contribution discussing and rating this approach in the SPL context. In this contribution, we provide a mapping between feature models describing the common and variable parts of an SPL and a reusable test model in the form of statecharts. Thereby, we interrelate feature model-based coverage criteria and test model-based coverage criteria such as control and data flow coverage and are therefore able to discuss the potentials and limitations of pairwise testing. We pay particular attention to test requirements for feature interactions constituting a major challenge in SPL engineering. We give a concise definition of feature dependencies and feature interactions from a testing point of view, and we discuss adequacy criteria for SPL coverage under pairwise feature interaction testing and give a generalization to the T-wise case. The concept and implementation of our approach are evaluated by means of a case study from the automotive domain.', NULL);
INSERT INTO `list` VALUES (343, '0000-00-00', 2012, 'article', 'Andrea Calvagna, Angelo Gargantini', 'T-wise combinatorial interaction test suites construction based on coverage inheritance', 'Generation', '', '2012 Software Testing, Verification and Reliability', 'STVR', '22', '7', '507-526', 'John Wiley', '10.1002/stvr.466', 'Combinatorial Testing', 'Combinatorial interaction testing (CIT) is a testing technique that requires covering all t-sized tuples of values out of n parameter attributes or properties modelled after the input parameters or the configuration domain of a system under test. CIT test suites have shown to be very effective in software testing already at pairwise (t  =  2) level, and the effectiveness of CIT grows with the tuple width t. Unfortunately, the number of tuples to be tested also does grow. In order to reduce the testing effort, researchers addressed the issue of computing minimal-sized CIT test suites with effective and scalable algorithms. However, still very few generally applicable t-wise covering construction algorithms (and tools) do exist in literature. This paper presents an original greedy algorithm to compute t-wise covering mixed covering arrays with constant space complexity, irrespective of the number of involved parameters and strength of interaction. The proposed algorithm has been implemented in a prototype tool, featuring also support for user constraints over the inputs. Assessment of the tool performance on a set of large, real-world test systems is reported, with results encouraging its adoption in industrial production environments. Copyright © 2011 John Wiley & Sons, Ltd.', NULL);
INSERT INTO `list` VALUES (344, '0000-00-00', 2012, 'article', 'Himer Avila-George, Jose Torres-Jimenez, Nelson Rangel-Valdez, Abel Carrión, Vicente Hernández', 'Supercomputing and grid computing on the verification of covering arrays', 'Evaluation', '', '2012 The Journal of Supercomputing', 'J Supercomput', '62', '2', '916-945', '', '10.1007/s11227-012-0763-0', 'Combinatorial Testing', 'The Covering Arrays (CAs) are mathematical objects with minimal coverage and maximum cardinality that are a good tool for the design of experiments. A covering array is an N×k matrix over an alphabet v s.t. each N×k subset contains at least one time each combination from {0,1,…,v−1}t, given a positive integer value t. The process of ensuring that a CA contains each of the v t combinations is called verification of CA. In this paper, we present an algorithm for CA verification and its implementation details in three different computation paradigms: (a) sequential approach (SA); (b) parallel approach (PA); and (c) Grid approach (GA). Four different PAs were compared in their performance of verifying a matrix as a CA; the PA with the best performance was included in a different experimentation where the three paradigms, SA, PA, and GA were compared in a benchmark composed by 45 possible CA instances. The results showed the limitations of the different paradigms when solving the verification of CA problem, and points out the necessity of a Grid approach to solve the problem when the size of a CA grows.', NULL);
INSERT INTO `list` VALUES (345, '0000-00-00', 2013, 'inproceedings', 'Dusica Marijan, Arnaud Gotlieb, Sagar Sen, Aymeric Hervieu', 'Practical Pairwise Testing for Software Product Lines', 'Generation', 'Software Product Line, Constraint', '2013 17th International Software Product Line Conference', 'SPLC', '', '', '227--235', '', '10.1145/2491627.2491646', 'Combinatorial Testing', 'One key challenge for software product lines is efficiently managing variability throughout their lifecycle. In this paper, we address the problem of variability in software product lines testing. We (1) identify a set of issues that must be addressed to make software product line testing work in practice and (2) provide a framework that combines a set of techniques to solve these issues. The framework integrates feature modelling, combinatorial interaction testing and constraint programming techniques. First, we extract variability in a software product line as a feature model with specified feature interdependencies. We then employ an algorithm that generates a minimal set of valid test cases covering all 2-way feature interactions for a given time interval. Furthermore, we evaluate the framework on an industrial SPL and show that using the framework saves time and provides better test coverage. In particular, our experiments show that the framework improves industrial testing practice in terms of (i) 17% smaller set of test cases that are (a) valid and (b) guarantee all 2-way feature coverage (as opposite to 19.2% 2-way feature coverage in the hand made test set), and (ii) full flexibility and adjustment of test generation to available testing time.', NULL);
INSERT INTO `list` VALUES (346, '0000-00-00', 2013, 'inproceedings', 'Christopher Henard, Mike Papadakis, Gilles Perrouin, Jacques Klein, Yves Le Traon', 'PLEDGE: A Product Line Editor and Test Generation Tool', 'Generation', 'Tool, Priority, Software Product Line', '2013 17th International Software Product Line Conference Workshops', 'SPLC', '', '', '126--129', '', '10.1145/2499777.2499778', 'Combinatorial Testing', 'Specific requirements of clients lead to the development of variants of the same software. These variants form a Software Product Line (SPL). Ideally, testing a SPL involves testing all the software products that can be configured through the combination of features. This, however, is intractable in practice since a) large SPLs can lead to millions of possible software variants and b) the testing process is usually limited by budget and time constraints. To overcome this problem, this paper introduces PLEDGE, an open source tool that selects and prioritizes the product configurations maximizing the feature interactions covered. The uniqueness of PLEDGE is that it bypasses the computation of the feature interactions, allowing to scale to large SPLs.', NULL);
INSERT INTO `list` VALUES (347, '0000-00-00', 2013, 'inproceedings', 'Roberto E. Lopez-Herrejon, Alexander Egyed', 'Towards interactive visualization support for pairwise testing software product lines', 'Application', 'Software Product Line', '2013 1st IEEE Working Conference on Software Visualization', 'VISSOFT ', '', '', '1--4', '', '10.1109/VISSOFT.2013.6650543', 'Combinatorial Testing', 'Software Product Lines (SPLs) are families of related software products. SPL practices have proven substantial technological and economical benefits such as improved software reuse and reduced time to market. Software testing is a key development activity in SPLs, and it is uniquely challenging because of the usually large number of feature combinations present in typical SPLs. Pairwise testing is a combinatorial testing technique that aims at selecting products to test based on the pairs of feature combinations such products provide. Our previous work on evolutionary approaches for SPL testing and their comparative analysis has yielded a large amount of data that prompted us to explore ways by which to convey and represent this information. In this paper we present our early results in this effort. We describe three basic visualization applications to pairwise testing and highlight some of the open questions that we foresee. But most importantly, our driving goal is both to raise the awareness of the visualization problems in this area and to spark the interest of the software visualization community.', NULL);
INSERT INTO `list` VALUES (348, '0000-00-00', 2013, 'inproceedings', 'Xiao Qu, Myra B. Cohen', 'A Study in Prioritization for Higher Strength Combinatorial Testing', 'Optimization', 'Priority', '2013 2nd International Workshop on Combinatorial Testing', 'IWCT', '', '', '285-294', '', '10.1109/ICSTW.2013.40', 'Combinatorial Testing', 'Recent studies have shown that combinatorial interaction testing (CIT) is an effective fault detection technique and that early fault detection can be improved by ordering test suites by interaction based prioritization approaches. Despite research that has shown that higher strength CIT improves fault detection, there have been fewer studies that aim to understand the impact of prioritization based on higher strength criteria. In this paper, we aim to understand how interaction based prioritization techniques perform, in terms of early fault detection when we prioritize based on 3-way interactions. We generalize prior work on prioritizing using 2-way interactions to t-way prioritization, and empirically evaluate this on three open source subjects, across multiple versions of each. We examine techniques that prioritize both existing CIT suites as well as generate new ones in prioritized order. We find that early fault detection can be improved when prioritizing 3-way CIT test suites by interactions that cover more code, and to a lesser degree when generating tests in prioritized order. Our techniques that work only from the specification, appear to work best with 2-way generation.', NULL);
INSERT INTO `list` VALUES (349, '0000-00-00', 2013, 'inproceedings', 'Mehra N. Borazjany, Laleh Sh. Ghandehari, Yu Lei, Raghu N. Kacker, D. Richard Kuhn', 'An Input Space Modeling Methodology for Combinatorial Testing', 'Model', '', '2013 2nd International Workshop on Combinatorial Testing', 'IWCT', '', '', '372-381', '', '10.1109/ICSTW.2013.48', 'Combinatorial Testing', 'The input space of a system must be modeled before combinatorial testing can be applied to this system. The effectiveness of combinatorial testing to a large extent depends on the quality of the input space model. In this paper we introduce an input space modeling methodology for combinatorial testing. The main idea is to consider the process of input space modeling as two steps, namely, input structure modeling and input parameter modeling. The first step tries to capture the structural relationship among different components in the input space. The second step tries to identify parameters, values, relations and constraints for individual components. We also suggest strategies about how to perform unit and integration testing based on the input space structure. We applied the proposed methodology to two real-life programs. We report our experience and results that demonstrate the effectiveness of the proposed methodology.', NULL);
INSERT INTO `list` VALUES (350, '0000-00-00', 2013, 'inproceedings', 'Manish Mehta, Roji Philip', 'Applications of Combinatorial Testing Methods for Breakthrough Results in Software Testing', 'Application', '', '2013 2nd International Workshop on Combinatorial Testing', 'IWCT', '', '', '348-351', '', '10.1109/ICSTW.2013.46', 'Combinatorial Testing', 'In last three decades, lot of research work has been done by statisticians and academicians (D. Richard Kuhn, Raghu N. Kacker, Vu Lei, Ljubomir Lazic, Sloane, Neil J. A., Madhav Phadke, D. M. Cohen, James Bach and others) in the field of Combinatorial testing (CT) and its use in software testing. However, its tremendous potential in terms of test optimization and fault detection is yet to be exploited to its fullest. This paper showcases some of the real-world examples from iGATE Corporation, where CT has been used successfully to achieve breakthrough results in software testing. The paper, through three case studies taken from different domains describes the challenges faced by testing teams in terms of test scenario complexities, schedule and budget constraints; and how CT helped resolve those challenges successfully. Our experience shows 60 to 70 percent benefits in terms of optimization of test efforts while enhancing test case coverage. In the end, the paper highlights some learnings from our experiences in implementing CT approach which may be of help to fellow practitioners.', NULL);
INSERT INTO `list` VALUES (351, '0000-00-00', 2013, 'inproceedings', 'Laleh Sh. Ghandehari, Mehra N. Borazjany, Yu Lei, Raghu N. Kacker, D. Richard Kuhn', 'Applying Combinatorial Testing to the Siemens Suite', 'Application', '', '2013 2nd International Workshop on Combinatorial Testing', 'IWCT', '', '', '362-371', '', '10.1109/ICSTW.2013.47', 'Combinatorial Testing', 'Combinatorial testing has attracted a lot of attention from both industry and academia. A number of reports suggest that combinatorial testing can be effective for practical applications. However, there are few systematic, controlled studies on the effectiveness of combinatorial testing. In particular, input parameter modeling is a key step in the combinatorial testing process. But most studies do not report the details of the modeling process. In this paper, we report an experiment that applies combinatorial testing to the Siemens suite. The Siemens suite has been used as a benchmark to evaluate the effectiveness of many testing techniques. Each program in the suite has a number of faulty versions. The effectiveness of combinatorial testing is measured in terms of the number of faulty versions that are detected. The experimental results show that combinatorial testing is effective in terms of detecting most of the faulty versions with a small number of tests. In addition, we report the details of our modeling process, which we hope to shed some lights on this critical, yet often ignored step, in the combinatorial testing process.', NULL);
INSERT INTO `list` VALUES (352, '0000-00-00', 2013, 'inproceedings', 'Oded Margalit', 'Better Bounds for Event Sequencing Testing', 'Generation', '', '2013 2nd International Workshop on Combinatorial Testing', 'IWCT', '', '', '281-284', '', '10.1109/ICSTW.2013.39', 'Combinatorial Testing', 'A permutation of a sequence of events is a common construction in many testing environments. Covering all possible permutations has clearly an exponential behavior; so one can ask for partial (easier) requirement, to cover all possible orders: permutations induced on of a small cardinality subset of elements. In our paper we show better (both lower and upper) bounds on this event sequencing testing problem. We also discuss another variant of the problem where we impose restrictions on the permutations. In this case we show how to achieve an exponential growth in the complexity of the problem. We also give solutions for specific cases of the problem.', NULL);
INSERT INTO `list` VALUES (353, '0000-00-00', 2013, 'inproceedings', 'Yong Zhao, Zhiqiang Zhang, Jun Yan, Jian Zhang', 'Cascade: A Test Generation Tool for Combinatorial Testing', 'Generation', 'Tool', '2013 2nd International Workshop on Combinatorial Testing', 'IWCT', '', '', '267-270', '', '10.1109/ICSTW.2013.37', 'Combinatorial Testing', 'Combinatorial Testing (CT) is a black-box testing technique, which is used to test parameterized systems. Real applications often have some special testing requirements, especially parameter constraints. Our experimental results show that existing CT test generators cannot deal with constraints very well as the number of constraints increases. This is due to their constraint solving mechanisms, where constraint solving and parameter assignment are separated. In this paper, we propose a new CT test generation method based on constrained optimization, which combines these two together to mitigate the effect brought by the growing complexity of constraints. Our approach is implemented in a tool called \"Cascade\", which can deal with common CT usage scenarios.', NULL);
INSERT INTO `list` VALUES (354, '0000-00-00', 2013, 'inproceedings', 'D. Richard Kuhn, Itzel D. Mendoza, Raghu N. Kacker, Yu Lei', 'Combinatorial Coverage Measurement Concepts and Applications', 'Evaluation', '', '2013 2nd International Workshop on Combinatorial Testing', 'IWCT', '', '', '352-361', '', '10.1109/ICSTW.2013.77', 'Combinatorial Testing', 'Empirical data demonstrate the value of t-way coverage, but in some testing situations, it is not practical to use covering arrays. However any set of tests covers at least some proportion of t-way combinations. This paper describes a variety of measures of combinatorial coverage that can be used in evaluating aspects of t-way coverage of a test suite. We also provide lower bounds on t-way coverage of several widely-used testing strategies, and describe a tool that analyzes test suites using the measures discussed in the paper.', NULL);
INSERT INTO `list` VALUES (355, '0000-00-00', 2013, 'inproceedings', 'Sachin Patel, Priya Gupta, Vipul Shah', 'Combinatorial Interaction Testing with Multi-perspective Feature Models', 'Model', '', '2013 2nd International Workshop on Combinatorial Testing', 'IWCT', '', '', '321-330', '', '10.1109/ICSTW.2013.43', 'Combinatorial Testing', 'Testing product lines and similar software involves the important task of testing feature interactions. The challenge is to test all those feature interactions that result in testing of all variations across all dimensions of variation. In this context, we propose the use of combinatorial test generation, with Multi-Perspective Feature Models (MPFM) as the input model. MPFMs are a set of feature models created to achieve Separation of Concerns within the model. We believe that the MPFM is useful as an input model for combinatorial testing and it is easy to create and understand. This approach helps achieve a better coverage of variability in the product line. Results from an experiment on a real-life case show that up to 37% of the test effort could be reduced and up to 79% defects from the live system could be detected.', NULL);
INSERT INTO `list` VALUES (356, '0000-00-00', 2013, 'inproceedings', 'Yasuharu Nishi, Tetsuro Katayama, Satomi Yoshizawa', 'Combinatorial Test Architecture Design Using Viewpoint Diagram', 'Model', '', '2013 2nd International Workshop on Combinatorial Testing', 'IWCT', '', '', '295-300', '', '10.1109/ICSTW.2013.82', 'Combinatorial Testing', 'Software test has recently been a large-scale and complicated artifact, as is the software itself. It is necessary to reduce huge combinatorial test cases. This paper focuses on reduction of test parameters and combinations in test architectural design. First we will mention the test architecture design phase in TDLC: Test Development Life Cycle. Second we will introduce NGT: Notation for Generic Testing, which is a set of concepts or notation for design of software test architecture. This paper shows four examples of test architecture design patterns: Interaction-Viewpoint Conversion pattern, Interaction Cluster Partitioning Pattern, Interaction Demotion Pattern and Interaction Necessity Analysis.', NULL);
INSERT INTO `list` VALUES (357, '0000-00-00', 2013, 'inproceedings', 'Andrea Calvagna, Angelo Gargantini, Paolo Vavassori', 'Combinatorial Testing for Feature Models Using CitLab', 'Model', '', '2013 2nd International Workshop on Combinatorial Testing', 'IWCT', '', '', '338-347', '', '10.1109/ICSTW.2013.45', 'Combinatorial Testing', 'Feature models are commonly used to represent product lines and systems with a set of features interrelated each others. Test generation from feature models, i.e. generating a valid and representative subset of all the possible product configurations, is still an open challenge. A common approach is to build combinatorial interaction test suites, for instance achieving pairwise coverage among the features. In this paper we show how standard feature models can be translated to combinatorial interaction models in our framework CITLAB, with all the advantages of having a combinatorial testing environment (in terms of a clear semantics, editing facilities, language for seeds and test goals, and generation algorithms). We present our translation which gives a precise semantics to feature models and it tries to minimize the number of parameter and constraints while preserving the original semantics of the feature model. Experiments show the advantages of our approach.', NULL);
INSERT INTO `list` VALUES (358, '0000-00-00', 2013, 'inproceedings', 'Preeti Satish, K. Sheeba, Krishnan Rangarajan', 'Deriving Combinatorial Test Design Model from UML Activity Diagram', 'Model', '', '2013 2nd International Workshop on Combinatorial Testing', 'IWCT', '', '', '331-337', '', '10.1109/ICSTW.2013.44', 'Combinatorial Testing', 'Combinatorial test design model consists of parameters, values and the associated constraints. This model is the input for test generators. In this paper we present a rule based approach for deriving combinatorial test design model from UML activity diagrams resulting from requirement analysis. We have explored this approach on few sample cases. Our initial results suggest that this automated approach augmented with manual review and refinement step can make the test design task less effort intensive and more effective.', NULL);
INSERT INTO `list` VALUES (359, '0000-00-00', 2013, 'inproceedings', 'Changhai Nie, Jing Jiang, Huayao Wu, Hareton Leung, Charles J. Colbourn', 'Empirically Identifying the Best Greedy Algorithm for Covering Array Generation', 'Generation', '', '2013 2nd International Workshop on Combinatorial Testing', 'IWCT', '', '', '239-248', '', '10.1109/ICSTW.2013.36', 'Combinatorial Testing', 'Covering array generation is a key issue in combinatorial testing. A number of researchers have been applying greedy algorithms for covering array construction. A greedy framework has been built to integrate most greedy algorithms and evaluate new approaches derived from this framework. However, this framework is affected by multiple factors, which makes its deployment and optimization very challenging. In order to identify the best configuration, we propose a search method that combines pairwise coverage with either base choice or hill climbing techniques. We conduct three different groups of experiments based on six decisions of the greedy framework. The influence of these decisions and their interactions are studied systematically, and the selected greedy algorithm for covering array generation is shown to be better than the existing greedy algorithms.', NULL);
INSERT INTO `list` VALUES (360, '0000-00-00', 2013, 'inproceedings', 'Sergiy Vilkomir, Oleksii Starov, Ranjan Bhambroo', 'Evaluation of t-wise Approach for Testing Logical Expressions in Software', 'Evaluation', '', '2013 2nd International Workshop on Combinatorial Testing', 'IWCT', '', '', '249-256', '', '10.1109/ICSTW.2013.83', 'Combinatorial Testing', 'Pair-wise and, more generally, t-wise testing are the most common and powerful combinatorial testing approaches. This paper investigates the effectiveness of the t-wise approach for testing logical expressions in software in terms of its faultdetecting capabilities. Effectiveness is evaluated experimentally using special software tools for generating logical expressions and t-wise test cases, simulating faults in expressions, testing faulty expressions, and evaluating effectiveness of the testing. T-wise testing effectiveness is measured in its totality and for specific types of faults; it is then compared with random testing. A detailed analysis of the experimental results is also provided.', NULL);
INSERT INTO `list` VALUES (361, '0000-00-00', 2013, 'inproceedings', 'Yvan Labiche, Faezeh Rafsanjani Sadeghi', 'Experimenting with Category Partition\'s 1-Way and 2-Way Test Selection Criteria', 'Evaluation', '', '2013 2nd International Workshop on Combinatorial Testing', 'IWCT', '', '', '301-310', '', '10.1109/ICSTW.2013.41', 'Combinatorial Testing', 'The Category Partition (CP) black-box testing method has shown to be effective in a number of situations. There is however little support for automating its use and little is known about the cost effectiveness of its associated selection criteria. In this paper, we report on a tool to automatically create test frames, i.e., test case specifications, for three wellknown criteria associated with the CP method, including the application of 1-way and 2-way interactions. We then report on the cost, in terms of number of test cases, and the effectiveness, in terms of mutation score, of adequate test suites for these criteria. The main lesson learnt is that, in addition to the intuition that the CP specification does impact effectiveness, a significant part of the effectiveness is also due to the test input selection procedure for test frames.', NULL);
INSERT INTO `list` VALUES (362, '0000-00-00', 2013, 'inproceedings', 'Xintao Niu, Changhai Nie, Yu Lei, Alvin T.S. Chan', 'Identifying Failure-Inducing Combinations Using Tuple Relationship', 'Diagnosis', '', '2013 2nd International Workshop on Combinatorial Testing', 'IWCT', '', '', '271-280', '', '10.1109/ICSTW.2013.38', 'Combinatorial Testing', 'Combinatorial testing (CT) aims at detecting interaction failures between parameters in a system. Identifying the failure-inducing combinations of a failing test configuration can help developers find the cause of this failure. However, most studies in CT focus on detecting the failures rather than identifying failure-inducing combinations. In this paper, we propose the notion of a tuple relationship tree (TRT) to describe the relationships among all the candidate parameter interactions. TRT reduces additional test configurations that need to be generated in the fault localization process, and it also provides a clear view of all possible candidate interactions. As a result, our approach will not omit any possible interaction that could be the cause of a failure. In particular, we can identify multiple failure-inducing combinations that overlap with each other. Moreover, we extend our approach to handle the case where additional failure-inducing combinations may be introduced by newly generated test configurations.', NULL);
INSERT INTO `list` VALUES (363, '0000-00-00', 2013, 'inproceedings', 'Jacek Czerwonka', 'On Use of Coverage Metrics in Assessing Effectiveness of Combinatorial Test Designs', 'Evaluation', '', '2013 2nd International Workshop on Combinatorial Testing', 'IWCT', '', '', '257-266', '', '10.1109/ICSTW.2013.76', 'Combinatorial Testing', 'Combinatorial test suite design is a test generation technique, popular in part due to its ability to achieve coverage and defect finding power approximating that of exhaustive testing while keeping test suite sizes constrained. In recent years, there have been numerous advances in combinatorial test design techniques, in terms of efficiency and usability of methods used to create them as well as in understanding of their benefits and limitations when applied to real world software. Numerous case studies have appeared presenting practical applications of the combinatorial test suite design techniques, often comparing them with manually-created, random, or exhaustive suites. These comparisons are done either in terms of defects found or by applying some code coverage metric. Since many different and valid combinatorial test suites of strength t can be created for a given test domain, the question whether they all have the same coverage properties is a pertinent one. In this paper we explore the stability of size and coverage of combinatorial test suites. We find that in general coverage levels increase and coverage variability decreases with increasing order of combinations t; however we also find exceptions with implications for practitioners. In addition, we explore cases where coverage achieved by combinatorial test suites of order t applied to the same program is not different from test suites of order t-1. Lastly, we discuss these findings in context of the ongoing practice of applying code coverage metrics to measure effectiveness of combinatorial test suites.', NULL);
INSERT INTO `list` VALUES (364, '0000-00-00', 2013, 'inproceedings', 'Eitan Farchi, Itai Segall, Rachel Tzoref-Brill', 'Using Projections to Debug Large Combinatorial Models', 'Model', '', '2013 2nd International Workshop on Combinatorial Testing', 'IWCT', '', '', '311-320', '', '10.1109/ICSTW.2013.42', 'Combinatorial Testing', 'Combinatorial test design (CTD) is an effective test planning technique that reveals faults resulting from parameters interactions in a system. The test space is manually modeled by a set of parameters, their respective values, and restrictions on the value combinations - referred to as a CTD model. Each possible combination of values in the cross product of the parameters, that is not excluded by restrictions, represents a valid test. A subset of the test space is then automatically constructed so that it covers all valid value combinations of every t parameters, where t is usually a user input. In many real-life testing problems, the relationships between the different test parameters are complex. Thus, precisely capturing them by restrictions in the CTD model might be a very challenging and time consuming task. Since the test space is of exponential size in the number of parameters, it is impossible to exhaustively review all potential tests. In this paper, we present technology that supports the modeling process by enabling repeated reviews of projections of the test space on a subset of the parameters, while indicating how the value combinations under review are affected by the restrictions. In addition, we generate explanations as to why the restrictions exclude specific value combinations of the subsets of parameters under review. These explanations can be used to identify modeling mistakes, as well as to increase the understanding of the test space. Furthermore, we identify specific excluded combinations that may require special attention, and list them for review together with their corresponding exclusion explanation. To enable the review of subsets of the exponential test space, indicate their status, and identify excluded combinations for review, we use a compact representation of the test space that is based on Binary Decision Diagrams. For the generation of explanations we use satisfiability solvers. We evaluate the proposed technology on real-life CTD models and demonstrate its effectiveness.', NULL);
INSERT INTO `list` VALUES (366, '0000-00-00', 2013, 'inproceedings', 'Sachin Patel, Priya Gupta, Vipul Shah', 'Feature interaction testing of variability intensive systems', 'Application', '', '2013 4th International Workshop on Product LinE Approaches in Software Engineering', 'PLEASE', '', '', '53-56', '', '10.1109/PLEASE.2013.6608666', 'Combinatorial Testing', 'Testing variability intensive systems is a formidable task due to the combinatorial explosion of feature interactions that result from all variations. We developed and validated an approach of combinatorial test generation using Multi-Perspective Feature Models (MPFM). MPFMs are a set of feature models created to achieve Separation of Concerns within the model. This approach improves test coverage of variability. Results from an experiment on a real-life case show that up to 37% of the test effort could be reduced and up to 79% defects from the live system could be detected. We discuss the learning from this experiment and further research potential in testing variability intensive systems.', NULL);
INSERT INTO `list` VALUES (368, '0000-00-00', 2013, 'inproceedings', 'Linbin Yu, Yu Lei, Raghu N. Kacker, D. Richard Kuhn', 'ACTS: A combinatorial test generation tool', 'Generation', 'Tool', '2013 6th International Conference on Software Testing, Verification and Validation', 'ICST', '', '', '370-375', '', '10.1109/ICST.2013.52', 'Combinatorial Testing', 'In this paper, we introduce a combinatorial test generation tool called Advanced Combinatorial Testing System (or ACTS). ACTS supports t-way combinatorial test generation with several advanced features such as mixed-strength test generation and constraint handling. To facilitate its use and integration with other tools, ACTS provides three types of external interface, including a graphic user interface, a command line interface, and an application programming interface. ACTS is a freely distributed research tool and has been downloaded by more than 1200 companies and organizations.', NULL);
INSERT INTO `list` VALUES (369, '0000-00-00', 2013, 'inproceedings', 'Redge Bartholomew', 'An industry proof-of-concept demonstration of automated combinatorial test', 'Application', '', '2013 8th International Workshop on Automation of Software Test', 'AST', '', '', '118-124', '', '10.1109/IWAST.2013.6595802', 'Combinatorial Testing', 'Studies have found that the largest single cost and schedule component of safety-critical, embedded system development is software rework: locating and fixing software defects found during test. In many such systems these defects are the result of interactions among no more than 6 variables, suggesting that 6-way combinatorial testing would be sufficient to trigger and detect them. The National Institute of Standards and Technology developed an approach to automatically generating, executing, and analyzing such tests. This paper describes an industry proof-of-concept demonstration of automated unit and integration testing using this approach. The goal was to see if it might cost-effectively reduce rework by reducing the number of software defects escaping into system test - if it was adequately accurate, scalable, mature, easy to learn, and easy to use and still was able to achieve the required level of structural coverage. Results were positive - e.g., 2775 test input vectors were generated in 6 seconds, expected outputs were generated in 60 minutes, and executing and analyzing them took 8 minutes. Tests detected all seeded defects and in the proof-of-concept demonstration achieved nearly 100% structural coverage.', NULL);
INSERT INTO `list` VALUES (370, '0000-00-00', 2013, 'incollection', 'Xiao Qu', 'Testing of Configurable Systems', 'Application', '', '2013 Advances in Computers', 'Adv. Comput.', '89', '', '141-162', '', '10.1016/B978-0-12-408094-2.00004-7', 'Combinatorial Testing', 'Configurable software system allows users to customize its applications in various ways, and is becoming increasingly prevalent. Testing configurable software requires extra effort over testing traditional software because there is evidence that running the same test case under different configurations may detect different faults. Differentiating test cases and configurations as two independent factors for testing, we must consider not just which test case to utilize, but also which configurations to test. Ideally, an exhaustive testing approach would combine every test case with every possible configuration. But since the full configuration space of most software systems is huge, it is infeasible to test all possible configurations with all test cases. Instead, selection techniques are necessary to select configurations for testing a software system, and to select test cases for the different configurations under test.\r\n\r\nDespite successful selection techniques, sometimes it is still costly to run only selected configurations and test cases. In particular, the cost is magnified when new features and functionality are added as a system evolves, and the new version is regression tested. Regression testing is an important but expensive way to build confidence that software changes do not introduce new faults as the software evolves, and many efforts have been made to improve its performance given limited resources. Test case prioritization has been extensively researched to determine which test cases should be run first, but has rarely been considered for configurations. In this chapter we introduce issues relevant to testing configurable software systems, we then present techniques for both selection and prioritization of these systems.\r\n\r\n', NULL);
INSERT INTO `list` VALUES (372, '0000-00-00', 2013, 'incollection', 'Loreto Gonzalez-Hernandez, Jose Torres-Jimenez, Nelson Rangel-Valdez', 'MiTS in Depth: An Analysis of Distinct Tabu Search Configurations for Constructing Mixed Covering Arrays', 'Generation', 'Search Based', '2013 Artificial Intelligence, Evolutionary Computing and Metaheuristics', 'Book', '', '', '371-402', 'Springer Berlin Heidelberg', '10.1007/978-3-642-29694-9_15', 'Combinatorial Testing', 'Alan turing work is related with the first use of heuristic algorithms. His work on broking the Nazi code of the Enigma cipher was oriented by a guided search whose expected result in most of the times would be the deciphering of the codes, even though sometimes it might not work. This idea reflects the modern meaning of an heuristic, and represents the main relationship with this chapter, as it involves the use of metaheuristics to try to guide the search to find a solution faster, or a better solution of a problem. The metaheuristic is Tabu Search (TS), and it is used to solve the Mixed Covering Array Problem (MCAP). This problem focuses on the construction of optimal test sets for software testing. The metaheuristic is designed through a fine tuning process that involves the parameters: initialization function, tabu list size, stop criterion, and neighborhood functions. The contributions are: a) a more robust fine tune process to design a new TS approach; b) the analys is of parameter values of the TS; and, c) new bounds over a benchmark reported in the literature.', NULL);
INSERT INTO `list` VALUES (373, '0000-00-00', 2013, 'inproceedings', 'Satoshi Fujimoto, Hideharu Kojima, Tatsuhiro Tsuchiya', 'A Value Weighting Method for Pair-wise Testing', 'Optimization', 'Priority', '2013 Asia-Pacific Software Engineering Conference', 'APSEC', '', '', '99-105', '', '10.1109/APSEC.2013.24', 'Combinatorial Testing', 'In this paper, we propose a weighting method for pair-wise testing. Pair-wise testing is a software testing strategy that tests every pair of parameter values at least once. Weighting allows the tester to specify desired frequency of occurrence in a test suite for each parameter value. Pair-wise testing is a widely used strategy because of its effectiveness in finding faults in software. Weighting makes this strategy more effective by allowing the tester to have more control over the resulting test suite. However, there is not much research on weighting. To our knowledge, all existing weighting methods treat weights as a second class requirement and cannot generate a test suite that sufficiently respects the given weights. The proposed method aims to overcome the problem. By taking into consideration the parameter value distribution in the current test suite and the ideal one specified by the given weights, the method generates each test case so that the resulting test suite can reflect the weights as accurately as possible. We implement the method in our testing tool and show some results to demonstrate how accurately test suites generated by this tool satisfy given weights.', NULL);
INSERT INTO `list` VALUES (374, '0000-00-00', 2013, 'article', 'Peyman Nayeri, Charles J. Colbourn, Goran Konjevod', 'Randomized post-optimization of covering arrays', 'Optimization', 'Reduction', '2013 European Journal of Combinatorics', 'EJC', '34', '1', '91-103', '', '10.1016/j.ejc.2012.07.017', 'Combinatorial Testing', 'The construction of covering arrays with the fewest rows remains a challenging problem. Most computational and recursive constructions result in extensive repetition of coverage. While some is necessary, some is not. By reducing the repeated coverage, metaheuristic search techniques typically outperform simpler computational methods, but they have been applied in a limited set of cases. Time constraints often prevent them from finding an array of competitive size. We examine a different approach. Having used a simple computation or construction to find a covering array, we employ a post-optimization technique that repeatedly adjusts the array in an attempt to reduce its number of rows. At every stage the array retains full coverage. We demonstrate its value on a collection of previously best known arrays by eliminating, in some cases, 10% of their rows. In the well-studied case of strength two with twenty factors having ten values each, post-optimization produces a covering array with only 162 rows, improving on a wide variety of computational and combinatorial methods. We identify certain important features of covering arrays for which post-optimization is successful.', NULL);
INSERT INTO `list` VALUES (375, '0000-00-00', 2013, 'inproceedings', 'Shuai Wang, Shaukat Ali, Arnaud Gotlieb', 'Minimizing test suites in software product lines using weight-based genetic algorithms', 'Generation', 'Software Product Line', '2013 Genetic and Evolutionary Computation Conference', 'GECCO', '', '', '1493-1500', '', '10.1145/2463372.2463545', 'Combinatorial Testing', 'Test minimization techniques aim at identifying and eliminating redundant test cases from test suites in order to reduce the total number of test cases to execute, thereby improving the efficiency of testing. In the context of software product line, we can save effort and cost in the selection and minimization of test cases for testing a specific product by modeling the product line. However, minimizing the test suite for a product requires addressing two potential issues: 1) the minimized test suite may not cover all test requirements compared with the original suite; 2) the minimized test suite may have less fault revealing capability than the original suite. In this paper, we apply weight-based Genetic Algorithms (GAs) to minimize the test suite for testing a product, while preserving fault detection capability and testing coverage of the original test suite. The challenge behind is to define an appropriate fitness function, which is able to preserve the coverage of complex testing criteria (e.g., Combinatorial Interaction Testing criterion). Based on the defined fitness function, we have empirically evaluated three different weight-based GAs on an industrial case study provided by Cisco Systems, Inc. Norway. We also presented our results of applying the three weight-based GAs on five existing case studies from the literature. Based on these case studies, we conclude that among the three weight-based GAs, Random-Weighted GA (RWGA) achieved significantly better performance than the other ones.', NULL);
INSERT INTO `list` VALUES (376, '0000-00-00', 2013, 'article', 'Himer Avila-George, Jose Torres-Jimenez, Loreto Gonzalez-Hernandez, Vicente Hernández', 'Metaheuristic approach for constructing functional test-suites', 'Generation', 'Search Based', '2013 IET Software', 'IET Softw', '7', '2', '104-117', '', '10.1049/iet-sen.2012.0074', 'Combinatorial Testing', 'Today, software systems are complex and have many possible configurations. A deficient software testing process often leads to unfortunate consequences, including data losses, large economic losses, security breaches, and even bodily harm. Thus, the problem of performing effective and economical testing is a key issue. Combinatorial testing is a method that can reduce cost and increase the effectiveness of software testing for many applications. It is based on constructing economical sized test-suites that provide coverage of the most prevalent configurations. Mixed covering arrays (MCAs) are combinatorial structures that can be used to represent these test-suites. MCAs are combinatorial objects represented as matrices having a test case per row. MCAs are small, in comparison to an exhaustive approach, and guarantee a level of interaction coverage among the parameters involved. This study presents a metaheuristic approach based on a simulated annealing (SA) algorithm for constructing MCAs. This algorithm incorporates several distinguishing features, including an efficient heuristic to generate good quality initial solutions, and a compound neighbourhood function that combines two carefully designed neighbourhood functions. The experimental design involved a benchmark reported in the literature and two real cases of software components. The experimental evidence showed that the SA algorithm equals or improves the obtained results by other approaches reported in the literature, and also finds the optimal solution in some of the solved cases.', NULL);
INSERT INTO `list` VALUES (377, '0000-00-00', 2013, 'inproceedings', 'Rubing Huang, Jinfu Chen, Tao Zhang, Rongcun Wang, Yansheng Lu', 'Prioritizing Variable-Strength Covering Array', 'Optimization', 'Priority', '2013 International Computers, Software & Applications Conference', 'COMPSAC', '', '', '502-511', '', '10.1109/COMPSAC.2013.84', 'Combinatorial Testing', 'Combinatorial interaction testing is a well-studied testing strategy, and has been widely applied in practice. Combinatorial interaction test suite, such as fixed-strength and variable-strength interaction test suite, is widely used for combinatorial interaction testing. Due to constrained testing resources in some applications, for example in combinatorial interaction regression testing, prioritization of combinatorial interaction test suite has been proposed to improve the efficiency of testing. However, nearly all prioritization techniques may only support fixed-strength interaction test suite rather than variable-strength interaction test suite. In this paper, we propose two heuristic methods in order to prioritize variable-strength interaction test suite by taking advantage of its special characteristics. The experimental results show that our methods are more effective for variable-strength interaction test suite by comparing with the technique of prioritizing combinatorial interaction test suites according to test case generation order, the random test prioritization technique, and the fixed-strength interaction test suite prioritization technique. Besides, our methods have additional advantages compared with the prioritization techniques for fixed-strength interaction test suite.', NULL);
INSERT INTO `list` VALUES (378, '0000-00-00', 2013, 'inproceedings', 'Changhai Nie, Siyang Chen, Hareton Leung, Kai-Yuan Cai', 'A Case Study of Adaptive Combinatorial Testing', 'Application', 'Adaptive CT', '2013 International Computers, Software & Applications Conference Workshop', 'ICSAW', '', '', '47-52', '', '10.1109/COMPSACW.2013.22', 'Combinatorial Testing', 'The ability of Combinatorial Testing (CT) to detect and locate the interaction triggered failure has been well studied. But CT still suffers from many challenges, such as modeling for CT, sampling mechanisms for test generation, applicability and effectiveness. To overcome these issues of CT, adaptive combinatorial testing (ACT) is proposed in this paper, which improves the traditional CT with a well established adaptive testing method as the counter part of adaptive control and aims to make CT more flexible and practical. ACT can significantly enhance testing quality, software reliability and support testing strategy adjustment dynamically. To support further investigation, a preliminary form of concrete strategy for ACT is given as a heuristic guideline, and a case study is presented to illustrate its operations.', NULL);
INSERT INTO `list` VALUES (379, '0000-00-00', 2013, 'inproceedings', 'Andrea Calvagna, Emiliano Tramontana', 'Incrementally Applicable t-Wise Combinatorial Test Suites for High-Strength Interaction Testing', 'Generation', '', '2013 International Computers, Software & Applications Conference Workshop', 'ICSAW', '', '', '77-82', '', '10.1109/COMPSACW.2013.25', 'Combinatorial Testing', 'In this paper we first show that the combinatorial task of enumerating t-wise tuples out of a given set of elements is the recursive iteration of the simpler task of computing pairs out of the same set of elements. We then show how to apply this result to the design of a general framework for incremental construction of a Combinatorial Interaction test suite, that is, producing at each iteration an additional set of tuples required to increase the coverage interaction degree just by one. As a last contribution, we show that in the presented construction framework, the covering array minimization problem and its inherent complexity can be encapsulated inside a delegate task of merging two given smaller covering array, while minimizing rows redundancy.', NULL);
INSERT INTO `list` VALUES (380, '0000-00-00', 2013, 'inproceedings', 'Cu D. Nguyen, Paolo Tonella', 'Automated inference of classifications and dependencies for combinatorial testing', 'Model', '', '2013 International Conference on Automated Software Engineering', 'ASE', '', '', '622-627', '', '10.1109/ASE.2013.6693123', 'Combinatorial Testing', 'Even for small programs, the input space is huge - often unbounded. Partition testing divides the input space into disjoint equivalence classes and combinatorial testing selects a subset of all possible input class combinations, according to criteria such as pairwise coverage. The down side of this approach is that the partitioning of the input space into equivalence classes (input classification) is done manually. It is expensive and requires deep domain and implementation understanding. In this paper, we propose a novel approach to classify test inputs and their dependencies automatically. Firstly, random (or automatically generated) input vectors are sent to the system under test (SUT). For each input vector, an observed \"hit vector\" is produced by monitoring the execution of the SUT. Secondly, hit vectors are grouped into clusters using machine learning. Each cluster contains similar hit vectors, i.e., similar behaviors, and from them we obtain corresponding clusters of input vectors. Input classes are then extracted for each input parameter straightforwardly. Our experiments with a number of subjects show good results as the automatically generated classifications are the same or very close to the expected ones.', NULL);
INSERT INTO `list` VALUES (381, '0000-00-00', 2013, 'inproceedings', 'Wei-Tek Tsai, Qingyang Li, Charles J. Colbourn, Xiaoying Bai', 'Adaptive fault detection for testing tenant applications in multi-tenancy SaaS systems', 'Application', '', '2013 International Conference on Cloud Engineering', 'other', '', '', '183-192', '', '10.1109/IC2E.2013.44', 'Combinatorial Testing', 'SaaS (Software-as-a-Service) often uses multi-tenancy architecture (MTA) where tenant developers compose their applications online using the components stored in the SaaS database. Tenant applications need to be tested, and combinatorial testing can be used. While numerous combinatorial testing techniques are available, most of them produce static sequences of test configurations and their goal is often to provide sufficient coverage such as 2-way interaction coverage. But the goal of SaaS testing is to identify those compositions that are faulty for tenant applications. This paper proposes an adaptive test configuration generation algorithm AR (Adaptive Reasoning) that can rapidly identify those faulty combinations so that those faulty combinations cannot be selected by tenant developers for composition. The AR algorithm has been evaluated by both simulation and real experimentation using a MTA SaaS sample running on GAE (Google App Engine). Both the simulation and experiment showed show that the AR algorithm can identify those faulty combinations rapidly. Whenever a new component is submitted to the SaaS database, the AR algorithm can be applied so that any faulty interactions with new components can be identified to continue to support future tenant applications.', NULL);
INSERT INTO `list` VALUES (382, '0000-00-00', 2013, 'inproceedings', 'Jian Yang, Huanguo Zhang, Jianmin Fu', 'A fuzzing framework based on symbolic execution and combinatorial testing', 'Application', '', '2013 International Conference on Green Computing and Communications', 'other', '', '', '2076-2080', '', '10.1109/GreenCom-iThings-CPSCom.2013.389', 'Combinatorial Testing', 'In order to simulate the attacks at multi input points for the fuzzing, in this paper, we present a white-box combinatorial fuzzing framework based on symbolic execution and combinatorial testing. According to the attack attributes plug-in gained by means of static analysis in advance, our fuzzing framework exploits symbolic execution to collect constraint conditions of attack points where the program may contain an error and to identify the input vector that influence attack points and the constraint interval of every input in input vector, uses constraint solving or interval computation to identify the feasibility of attack points, applies combinatorial coverage strategies to searching interval combination of input vector for the feasible attack points, chooses corresponding strategies of test case generation to generate test case from the interval combination of input vector, and finally injects the combinatorial test case vector to find security vulnerabilities in programs according to the attack strategies in the attack attributes plug-in. Our experimental results indicate that our fuzzing framework can not only effectively expose errors located deep within large applications, but also can avoid the combination explosion to a certain extent.', NULL);
INSERT INTO `list` VALUES (383, '0000-00-00', 2013, 'inproceedings', 'Changhai Nie, Hareton Leung, Kai-Yuan Cai', 'Adaptive Combinatorial Testing', 'Application', 'Adaptive CT', '2013 International Conference on Quality Software', 'QSIC', '', '', '284-287', '', '10.1109/QSIC.2013.22', 'Combinatorial Testing', 'Combinatorial Testing (CT) has been proven to be effective in detecting and locating the interaction triggered failure in the last 20 years. But CT still suffers from many challenges, such as modeling for CT, sampling mechanisms for test generation, applicability and effectiveness. To overcome these issues of CT, adaptive combinatorial testing (ACT) is proposed in this paper, which improves the traditional CT with a well established adaptive testing method as the counter part of adaptive control and aims to make CT more flexible and practical. ACT can significantly enhance testing quality, software reliability and support testing strategy adjustment dynamically. To support further investigation, a preliminary form of concrete strategy for ACT is given as a heuristic guideline.', NULL);
INSERT INTO `list` VALUES (384, '0000-00-00', 2013, 'inproceedings', 'Dale Blue, Itai Segall, Rachel Tzoref-Brill, Aviad Zlotnick', 'Interaction-Based Test-Suite Minimization', 'Optimization', 'Reduction', '2013 International Conference on Software Engineering', 'ICSE', '', '', '182-191', '', '10.1109/ICSE.2013.6606564', 'Combinatorial Testing', 'Combinatorial Test Design (CTD) is an effective test planning technique that reveals faults resulting from feature interactions in a system. The standard application of CTD requires manual modeling of the test space, including a precise definition of restrictions between the test space parameters, and produces a test suite that corresponds to new test cases to be implemented from scratch.\r\n\r\nIn this work, we propose to use Interaction-based Test-Suite Minimization (ITSM) as a complementary approach to standard CTD. ITSM reduces a given test suite without impacting its coverage of feature interactions. ITSM requires much less modeling effort, and does not require a definition of restrictions. It is appealing where there has been a significant investment in an existing test suite, where creating new tests is expensive, and where restrictions are very complex. We discuss the tradeoffs between standard CTD and ITSM, and suggest an efficient algorithm for solving the latter. We also discuss the challenges and additional requirements that arise when applying ITSM to real-life test suites. We introduce solutions to these challenges and demonstrate them through two real-life case studies.', NULL);
INSERT INTO `list` VALUES (385, '0000-00-00', 2013, 'inproceedings', 'Xiaofang Qi, Jun He, Peng Wang', 'A Mixed-way Combinatorial Testing for Concurrent Programs', 'Application', '', '2013 International Conference on Software Engineering and Knowledge Engineering', 'SEKE', '', '', '699-702', '', 'not found', 'Combinatorial Testing', 'Reachability testing is an important approach to testing concurrent programs. It can generate and exercise all partially-ordered synchronization sequences automatically and on-the-fly without constructing any static models. However, it suffers from the problem that the number in synchronization sequences is too large to be exhaustively exercised. In this paper, we present a new combinatorial testing strategy, called mixedway reachability testing, which adopts the dynamic framework of reachability testing but reduces the number in synchronization sequences that are exercised. The reduction is based on the mixed-way combinatorial strategy, which covers all the valid combinations of receiving events in each subsystem of a concurrent program. We present an algorithm that implements the mixed-way testing and conduct our experiment on an industrial control simulator program. The preliminary experimental results indicate that the mixed-way reachability testing can keep the same effectiveness of fault detection as exhaustive testing while substantially reducing the number in synchronization sequences. Compared to the other existing reachability testing approaches, it achieves a good tradeoff between the effectiveness and efficiency of testing.', NULL);
INSERT INTO `list` VALUES (386, '0000-00-00', 2013, 'inproceedings', 'Ziyuan Wang, Ting Guo, Wujie Zhou, Weifeng Zhang, Baowen Xu', 'Generating partial covering array for locating faulty interactions in combinatorial testing', 'Diagnosis', '', '2013 International Conference on Software Engineering and Knowledge Engineering', 'SEKE', '', '', '578-583', '', 'not found', 'Combinatorial Testing', 'Abstract\r\nCombinatorial testing is widely used to detect failures caused by interactions among parameters. After detecting faults, the subsequent problem in combinatorial testing is characterizing faulty interactions that cause these detected failures. In order to characterize faulty interactions accurately and efficiently, a test suite that usually differ from the original combinatorial test suite is required in fault diagnosis. By assuming the number of faulty interactions is under control, the partial covering array, whose size grows logarithmically with the number of parameters, can serve as a test suite for locating faulty interactions in the nonadaptive faulty interaction locating process. In this paper, we extend the one-test-at-a-time framework, which is widely used in combinatorial test generation, for generating partial covering arrays. We combine this framework with greedy methods and meta-heuristic search methods respectively. An experiment shows that partial covering array needs smaller number of test cases than existing non-adaptive methods.', NULL);
INSERT INTO `list` VALUES (387, '0000-00-00', 2013, 'inproceedings', 'Roberto E. Lopez-Herrejon, Francisco Chicano, Javier Ferrer, Alexander Egyed, Enrique Alba', 'Multi-objective optimal test suite computation for software product line pairwise testing', 'Generation', 'Search Based, Software Product Line', '2013 International Conference on Software Maintenance', 'ICSM', '', '', '404-407', '', '10.1109/ICSM.2013.58', 'Combinatorial Testing', 'Software Product Lines (SPLs) are families of related software products, which usually provide a large number of feature combinations, a fact that poses a unique set of challenges for software testing. Recently, many SPL testing approaches have been proposed, among them pair wise combinatorial techniques that aim at selecting products to test based on the pairs of feature combinations such products provide. These approaches regard SPL testing as an optimization problem where either coverage (maximize) or test suite size (minimize) are considered as the main optimization objective. Instead, we take a multi-objective view where the two objectives are equally important. In this exploratory paper we propose a zero-one mathematical linear program for solving the multi-objective problem and present an algorithm to compute the true Pareto front, hence an optimal solution, from the feature model of a SPL. The evaluation with 118 feature models revealed an interesting trade-off between reducing the number of constraints in the linear program and the runtime which opens up several venues for future research.', NULL);
INSERT INTO `list` VALUES (388, '0000-00-00', 2013, 'inproceedings', 'Linbin Yu, Yu Lei, Mehra N. Borazjany, Raghu N. Kacker, D. Richard Kuhn', 'An Efficient Algorithm for Constraint Handling in Combinatorial Test Generation', 'Generation', 'Constraint', '2013 International Conference on Software Testing, Verification and Validation', 'ICST', '', '', '242-251', '', '10.1109/ICST.2013.35', 'Combinatorial Testing', 'Combinatorial testing has been shown to be a very effective testing strategy. An important problem in combinatorial testing is dealing with constraints, i.e., restrictions that must be satisfied in order for a test to be valid. In this paper, we present an efficient algorithm, called IPOG-C, for constraint handling in combinatorial testing. Algorithm IPOG-C modifies an existing combinatorial test generation algorithm called IPOG to support constraints. The major contribution of algorithm IPOG-C is that it includes three optimizations to improve the performance of constraint handling. These optimizations can be generalized to other combinatorial test generation algorithms. We implemented algorithm IPOG-C in a combinatorial test generation tool called ACTS. We report experimental results that demonstrate the effectiveness of algorithm IPOG-C. The three optimizations increased the performance by one or two orders of magnitude for most subject systems in our experiments. Furthermore, a comparison of ACTS to three other tools suggests that ACTS can perform significantly better for systems with more complex constraints.', NULL);
INSERT INTO `list` VALUES (389, '0000-00-00', 2013, 'inproceedings', 'Andrea Calvagna, Angelo Gargantini, Paolo Vavassori', 'Combinatorial Interaction Testing with CITLAB', 'Application', 'Tool', '2013 International Conference on Software Testing, Verification and Validation', 'ICST', '', '', '376-382', '', '10.1109/ICST.2013.53', 'Combinatorial Testing', 'In this paper the CITLAB tool for Combinatorial Interaction Testing is presented. The tool allows importing/exporting models of combinatorial problems from/to different application domains, by means of a common interchange syntax notation and a corresponding interoperable semantic metamodel. Moreover, the tool is a framework allowing embedding and transparent invocation of multiple, different implementations of combinatorial algorithms. CITLAB has been designed tightly integrated with the Eclipse IDE framework, by means of its plug-in extension mechanism. It is intended to easy the spread of CIT testing both in industrial practice and in academic research, by allowing users and researchers to apply multiple test suite generation algorithms, each with its peculiarities, on the same problem models, and let them compare the results in order to select the one that best fits their needs, while alleviating from the pain of knowing all the different details and notations of the underlying CIT tools. ', NULL);
INSERT INTO `list` VALUES (390, '0000-00-00', 2013, 'article', 'Rubing Huang, Xiaodong Xie, Dave Towey, Tsong Yueh Chen, Yansheng Lu, Jinfu Chen', 'Prioritization of Combinatorial Test Cases by Incremental Interaction Coverage', 'Optimization', 'Priority', '2013 International Journal of Software Engineering and Knowledge Engineering', 'IJSEKE', '23', '10', '1427-1458', '', '10.1142/S0218194013500459', 'Combinatorial Testing', 'Combinatorial interaction testing is a well-recognized testing method, and has been widely applied in practice, often with the assumption that all test cases in a combinatorial test suite have the same fault detection capability. However, when testing resources are limited, an alternative assumption may be that some test cases are more likely to reveal failure, thus making the order of executing the test cases critical. To improve testing cost-effectiveness, prioritization of combinatorial test cases is employed. The most popular approach is based on interaction coverage, which prioritizes combinatorial test cases by repeatedly choosing an unexecuted test case that covers the largest number of uncovered parameter value combinations of a given strength (level of interaction among parameters). However, this approach suffers from some drawbacks. Based on previous observations that the majority of faults in practical systems can usually be triggered with parameter interactions of small strengths, we propose a new strategy of prioritizing combinatorial test cases by incrementally adjusting the strength values. Experimental results show that our method performs better than the random prioritization technique and the technique of prioritizing combinatorial test suites according to test case generation order, and has better performance than the interaction-coverage-based test prioritization technique in most cases.', NULL);
INSERT INTO `list` VALUES (391, '0000-00-00', 2013, 'inproceedings', 'Itzel D. Mendoza, D. Richard Kuhn, Raghu N. Kacker, Yu Lei', 'CCM: A tool for measuring combinatorial coverage of system state space', 'Evaluation', 'Tool', '2013 International Symposium on Empirical Software Engineering and Measurement', 'ESEM', '', '', '291', '', '10.1109/ESEM.2013.44', 'Combinatorial Testing', 'This poster presents some measures of combinatorial coverage that can be helpful in estimating residual risk related to insufficient testing of rare interactions, and a tool for computing these measures.', NULL);
INSERT INTO `list` VALUES (392, '0000-00-00', 2013, 'inproceedings', 'Peter M. Kruse, Nelly Condori-Fernandez, Tanja E.J. Vos, Alessandra Bagnato, Etienne Brosse', 'Combinatorial Testing Tool Learnability in an Industrial Environment', 'Application', '', '2013 International Symposium on Empirical Software Engineering and Measurement', 'ESEM', '', '', '304-312', '', '10.1109/ESEM.2013.49', 'Combinatorial Testing', '[Context] Numerous combinatorial testing techniques are available for generating test cases. However, many of them are never used in practice. [Objective] Considering that learn ability plays a vital role in initial adoption or rejection of a technology, in this paper we aim to investigate the learnability of a combinatorial testing tool in an industrial environment. [Method] A case study research method was designed and conducted, by including i) the definition of learnability measures for test cases models built using a combinatorial testing tool. ii) A training program was also implemented. iii) Qualitative and quantitative evaluation based on a three-level strategy was carried out (Reaction, Learning, and Performance). [Results] At the first level, the tool was perceived as easy to learn by the trainees (from a five-point ordinal scale). However, at the second level, during hands-on learning, it changed slightly: According to the working diaries, there were major difficulties. At third level, analyzing the learning curve of each trainee, we observe that semantic errors made per each subject were reduced slightly over the time.', NULL);
INSERT INTO `list` VALUES (393, '0000-00-00', 2013, 'inproceedings', 'Laleh Sh. Ghandehari, Yu Lei, David Kung, Raghu N. Kacker, D. Richard Kuhn', 'Fault localization based on failure-inducing combinations', 'Diagnosis', '', '2013 International Symposium on Software Reliability Engineering', 'ISSRE', '', '', '168-177', '', '10.1109/ISSRE.2013.6698916', 'Combinatorial Testing', 'Combinatorial testing has been shown to be a very effective testing strategy. After a failure is detected, the next task is to identify the actual fault that causes the failure. In this paper, we present an approach to fault localization that leverages the result of combinatorial testing. Our approach is based on a notion called failure-inducing combinations. A combination is failure- inducing if it causes any test in which it appears to fail. Given a failure-inducing combination, our approach derives a group of tests that are likely to exercise similar traces but produce different outcomes. These tests are then analyzed to locate the faults. We conducted an experiment in which our approach was applied to a suite of programs with seeded errors often used in testing research. The experimental results show that our approach can effectively and efficiently localize the faults in these programs.', NULL);
INSERT INTO `list` VALUES (394, '0000-00-00', 2013, 'inproceedings', 'Jose Torres-Jimenez, Idelfonso Izquierdo-Marquez', 'Survey of Covering Arrays', 'Other', 'Survey', '2013 International Symposium on Symbolic and Numeric Algorithms for Scientific Computing', 'other', '', '', '20-27', '', '10.1109/SYNASC.2013.10', 'Combinatorial Testing', 'Covering Arrays(CA) are combinatorial objects that have been used succesfully to automate the generation of test cases for software testing. The CAs have the features of being of minimal cardinality (i.e. minimize the number of test cases), and maximum coverage (i.e. they guarantee to cover all combinations of certain size between the input parameters). Only in few cases there is known an optimal solution to construct CAs, but in general the problem of constructing optimal CAs is a hard combinatorial optimization problem. For this reason, a number of methods to solve the construction of covering arrays have been developed. This paper gives a survey of the state of the art of the methods to construct covering arrays. The methods analyzed were grouped in four categories: exact methods (Section II), greedy methods (Section III), metaheuristic methods (Section IV), and algebraic methods (Section V). The paper ends with a summary of the methods analyzed.', NULL);
INSERT INTO `list` VALUES (395, '0000-00-00', 2013, 'inproceedings', 'Hongli Yang, Kai Ma, Cheng Deng, Husheng Liao, Jun Yan, Jian Zhang', 'Towards conformance testing of choreography based on scenario', 'Application', '', '2013 International Symposium on Theoretical Aspects of Software Engineering', 'TASE', '', '', '59-62', '', '10.1109/TASE.2013.23', 'Combinatorial Testing', 'Web service choreography specifies the interaction among multiple participant, aiming to achieve common business goals. An issue is to check for the conformance of the implementation with reference to the choreography specification. To achieve that, we seek to develop software tools and a methodology to enable conformance testing of choreography. In this paper, we present our first step in that direction. Particularly, we reduce choreography scenario in order to obtain effective testing scenarios, which will greatly decrease the cost of testing. Concretely, based on XML Schema type definition of a choreography scenario, we partition XML Schema type into subtypes, which will be transformed into the input model of combinatorial tool Cascade for generating a set of combinations of variable values. The output of Cascade will be transformed to generate reduced scenarios for testing. Moreover, a purchase order choreography example is presented to demonstrate the reduction process of choreography scenarios, and a tool has been developed for supporting automatic implementation of the testing scenarios reduction.', NULL);
INSERT INTO `list` VALUES (396, '0000-00-00', 2013, 'inproceedings', 'Wei-Tek Tsai, Charles J. Colbourn, Jie Luo, Guanqiu Qi, Qingyang Li, Xiaoying Bai', 'Test algebra for combinatorial testing', 'Diagnosis', '', '2013 International Workshop on Automation of Software Test', 'IWAST', '', '', '19-25', '', '10.1109/IWAST.2013.6595786', 'Combinatorial Testing', 'This paper proposes a new algebraic system, Test Algebra (TA), for identifying faults in combinatorial testing for SaaS (Software-as-a-Service) applications. SaaS as a part of cloud computing is a new software delivery model, and mission-critical applications are composed, deployed, and executed in cloud platforms. Testing SaaS applications is a challenging task because new applications need to be tested when they are composed before they can be deployed for execution. Combinatorial testing algorithms can be used to identify faulty configurations and interactions from 2-way all the way to k-way where k is the number of components in the application. The TA defines rules to identify faulty configurations and interactions. Using the rules defined in the TA, a collection of configurations can be tested concurrently in different servers and in any order and the results obtained will be still same due to the algebraic constraints.', NULL);
INSERT INTO `list` VALUES (397, '0000-00-00', 2013, 'inproceedings', 'Andrea Calvagna, Emiliano Tramontana', 'Combinatorial Validation Testing of Java Card Byte Code Verifiers', 'Application', '', '2013 International Workshop on Enabling Technologies: Infrastructure for Collaborative Enterprises', 'other', '', '', '347-352', '', '10.1109/WETICE.2013.35', 'Combinatorial Testing', 'We present a technique to fully automate validation of a byte code verifier (BCV) implementation by testing. The technique is based on the use of a finite state machine model of the JVM specifications to systematically explore the set of legal JVM states from which one or more illegal states are immediately reachable. All possible sequences of instructions bringing to illegal states reachable from each legal state are combinatorially enumerated to generate a suite of tests, consisting of valid Java programs. For tests to stress the BCV type inference algorithm, each test program has been purposely designed with a large number of intertwined execution flows. The illegal state in the instruction sequence is hidden inside one of those paths.', NULL);
INSERT INTO `list` VALUES (399, '0000-00-00', 2013, 'inproceedings', 'Evelyn Nicole Haslinger, Roberto E. Lopez-Herrejon, Alexander Egyed', 'Using feature model knowledge to speed up the generation of covering arrays', 'Generation', '', '2013 International Workshop on Variability Modelling of Software-intensive Systems', 'VaMoS', '', '', '16:1-16:6', '', '10.1145/2430502.2430524', 'Combinatorial Testing', 'Combinatorial Interaction Testing has shown great potential for effectively testing Software Product Lines (SPLs). An important part of this type of testing is determining a subset of SPL products in which interaction errors are more likely to occur. Such sets of products are obtained by computing a so called t-wise Covering Array (tCA), whose computation is known to be NP-complete. Recently, the ICPL algorithm has been proposed to compute these covering arrays. In this research-in-progress paper, we propose a set of rules that exploit basic feature model knowledge to reduce the number of elements (i.e. t-sets) required by ICPL without weakening the strength of the generated arrays. We carried out a comparison of runtime performance that shows a significant reduction of the needed execution time for the majority of our SPL case studies.', NULL);
INSERT INTO `list` VALUES (400, '0000-00-00', 2013, 'inproceedings', 'Justyna Petke, Shin Yoo, Myra B. Cohen, Mark Harman', 'Efficiency and early fault detection with lower and higher strength combinatorial interaction testing', 'Evaluation', 'Constraint', '2013 International Symposium on the Foundations of Software Engineering', 'FSE', '', '', '26-36', '', '10.1145/2491411.2491436', 'Combinatorial Testing', 'Combinatorial Interaction Testing (CIT) is important because it tests the interactions between the many features and parameters that make up the configuration space of software systems. However, in order to be practically applicable, it must be able to cater for soft and hard real-world constraints and should, ideally, report a test priority order that maximises earliest fault detection. We show that we can achieve the highest strength CIT in 5.65 minutes on average. This was previously thought to be too computationally expensive to be feasible. Furthermore, we show that higher strength suites find more faults, while prioritisations using lower strengths are no worse at achieving early fault revelation.', NULL);
INSERT INTO `list` VALUES (401, '0000-00-00', 2013, 'article', 'Charles J. Colbourn, Jose Torres-Jimenez', 'Profiles of covering arrays of strength two', 'Generation', '', '2013 Journal of Algorithms and Computation', 'JACO', '44', '0', '31-60', '', 'not found', 'Combinatorial Testing', 'Covering arrays of strength two have been widely studied as combinatorial models of software interaction test suites for pairwise testing. While numerous algorithmic techniques have been developed for the generation of covering arrays with few columns (factors), the construction of covering arrays with many factors and few tests by these techniques is problematic. Random generation techniques can overcome these computational difficulties, but for strength two do not appear to yield a number of tests that is competitive with the fewest known. ', NULL);
INSERT INTO `list` VALUES (403, '0000-00-00', 2013, 'article', 'Ziyuan Wang, Haixiao He', 'Generating Variable Strength Covering Array for Combinatorial Software Testing with Greedy Strategy', 'Generation', '', '2013 Journal of Software', 'J. Softw.', '8', '12', '3173-3181', '', 'not found', 'Combinatorial Testing', 'Combinatorial testingis a practical and efficient software testing techniques, which could detectthe faults that triggered by interactions among factors in software. Comparedto the classic fixed strength combinatorial testing, the variable strengthcombinatorial testing usually uses less test cases to detect more interactionfaults, because it considers the actual interaction relationship in softwaresufficiently. For a model of variable strength combinatorial testing that hasbeen propose previously, two heuristic algorithms, which are based onone-test-at-a-time greedy strategy, are proposed in this paper to generatevariable strength covering arrays as test suites in software testing.Experimental results show that, compared to some existed algorithms and tools,the two proposed algorithms have advantages onboth the execution effectiveness and the optimality of the size of generatedtest suite.', NULL);
INSERT INTO `list` VALUES (405, '0000-00-00', 2013, 'article', 'Saswat Anand, Edmund K. Burke, Tsong Yueh Chen, John Clark, Myra B. Cohen, Wolfgang Grieskamp, Mark Harman, Mary Jean Harrold, Phil McMinn', 'An orchestrated survey of methodologies for automated software test case generation', 'Other', 'Survey', '2013 Journal of Systems and Software', 'JSS', '86', '8', '1978-2001', '', '10.1016/j.jss.2013.02.061', 'Combinatorial Testing', 'Test case generation is among the most labour-intensive tasks in software testing. It also has a strong impact on the effectiveness and efficiency of software testing. For these reasons, it has been one of the most active research topics in software testing for several decades, resulting in many different approaches and tools. This paper presents an orchestrated survey of the most prominent techniques for automatic generation of software test cases, reviewed in self-standing sections. The techniques presented include: (a) structural testing using symbolic execution, (b) model-based testing, (c) combinatorial testing, (d) random testing and its variant of adaptive random testing, and (e) search-based testing. Each section is contributed by world-renowned active researchers on the technique, and briefly covers the basic ideas underlying the method, the current state of the art, a discussion of the open research problems, and a perspective of the future development of the approach. As a whole, the paper aims at giving an introductory, up-to-date and (relatively) short overview of research in automatic test case generation, while ensuring a comprehensive and authoritative treatment.', NULL);
INSERT INTO `list` VALUES (407, '0000-00-00', 2013, 'inproceedings', 'Loreto Gonzalez-Hernandez, Jose Torres-Jimenez, Nelson Rangel-Valdez, Josue Bracho-Rios', 'A Post-optimization Strategy for Combinatorial Testing: Test Suite Reduction through the Identification of Wild Cards and Merge of Rows', 'Optimization', 'Reduction', '2013 Mexican International Conference on Artificial Intelligence', 'MICAI', '', '', '127-138', '', '10.1007/978-3-642-37798-3_12', 'Combinatorial Testing', 'The development of a new software system involves extensive tests on the software functionality in order to identify possible failures. It will be ideal to test all possible input cases (configurations), but the exhaustive approach usually demands too large cost and time. The test suite reduction problem can be defined as the task of generating small set of test cases under certain requirements. A way to design test suites is through interaction testing using a matrix called Covering Array, CA(N;t,k,v), which guarantees that all configurations among every t parameters are covered. This paper presents a simple strategy that reduces the number of rows of a CA. The algorithms represent a post-optimization process which detects wild cards (values that can be changed arbitrarily without the CA losses its degree of coverage) and uses them to merge rows. In the experiment, 667 CAs, created by a state-of-the-art algorithm, were subject to the reduction process. The results report a reduction in the size of 347 CAs (52% of the cases). As part of these results, we report the matrix for CA(42;2,8,6) constructed from CA(57;2,8,6) with an impressive reduction of 15 rows, which is the best upper bound so far.', NULL);
INSERT INTO `list` VALUES (408, '0000-00-00', 2013, 'inproceedings', 'Sergio Luna, Amit Lopes, Hoong Yan See Tao, Francisco Zapata, Ricardo Pineda', 'Integration, Verification, Validation, Test, and Evaluation (IVVT&E) Framework for System of Systems (SoS) ', 'Application', '', '2013 Procedia Computer Science', 'other', '20', '', '298-305', '', '10.1016/j.procs.2013.09.276', 'Combinatorial Testing', 'The traditional systems engineering (SE) methodologies for integration, verification, validation, test and evaluation (IVVT&E) throughout the lifecycle are focused on expected outcomes (behavior, capabilities), which may not necessarily apply for system of systems (SoS), where some emergent behavior and knowledge may be needed in untested scenarios (unknown environments). Next-generation SoS consisting of partially or fully decentralized systems are incorporating advances in computing, sensing, and communications operations to address uncertainty and emergence in SoS. Thus, current standardized and formalized IVVT&E methodologies will need to be modified, adapted, or an evolutionary IVVT&E framework for SoS is required to test and evaluate integrated SoS capabilities in unknown scenarios. This paper discusses several potential strategies and explores possible methodologies that may be applied to develop a SoS IVVT&E framework, as applied to an unmanned aerial system (UAS), based on existing architectural frameworks such as Department of Defense Architecture Framework (DoDAF).', NULL);
INSERT INTO `list` VALUES (411, '0000-00-00', 2013, 'inproceedings', 'Ngoc Thi Bich Do, Takashi Kitamura, Van Tang Nguyen, Goro Hatayama, Shinya Sakuragi, Hitoshi Ohsaki', 'Constructing Test Cases for N-wise Testing from Tree-Based Test Models', 'Generation', '', '2013 Symposium on Information and Communication Technology', 'other', '', '', '275-284', 'ACM', '10.1145/2542050.2542074', 'Combinatorial Testing', 'In our previous work [17], we proposed a model-based combinatorial testing method, called FOT. It provides a technique to design test-models for combinatorial testing based on extended logic trees. In this paper, we introduce pair-wise testing (and by extension, n-wise testing, where n = 1, 2, ...) to FOT, by developing a technique to construct a test-suite of n-wise strategies from the test models in FOT. We take a \"transformation approach\" to realize this technique. To construct test suites, this approach first transforms test-models in FOT, represented as extended logic trees, to those in the formats which the existing n-wise testing tools (such as PICT [9], ACTS [30], CIT-BACH [31], etc.) accept to input, and then applies transformed test-models to any of these tools. In this transformation approach, an algorithm, called \"flattening algorithm\", plays a key role. We prove the correctness of the algorithm, and implement the algorithm to automate such test-suite constructions, providing a tool called FOT-nw (FOT with n-wise). Further, to show the effectiveness of the technique, we conduct a case study, where we apply FOT-nw to design test models and automatically construct test suites of n-wise strategies for an embedded system of stationary services for real-use in industry.', NULL);
INSERT INTO `list` VALUES (412, '0000-00-00', 2014, 'inproceedings', 'Roberto E. Lopez-Herrejon, Javier Ferrer, Francisco Chicano, Alexander Egyed, Enrique Alba', 'Comparative analysis of classical multi-objective evolutionary algorithms and seeding strategies for pairwise testing of Software Product Lines', 'Generation', 'Search Based, Software Product Line', '2014  IEEE Congress on Evolutionary Computation', 'CEC', '', '', '387-396', '', '10.1109/CEC.2014.6900473', 'Combinatorial Testing', 'Software Product Lines (SPLs) are families of related software products, each with its own set of feature combinations. Their commonly large number of products poses a unique set of challenges for software testing as it might not be technologically or economically feasible to test of all them individually. SPL pairwise testing aims at selecting a set of products to test such that all possible combinations of two features are covered by at least one selected product. Most approaches for SPL pairwise testing have focused on achieving full coverage of all pairwise feature combinations with the minimum number of products to test. Though useful in many contexts, this single-objective perspective does not reflect the prevailing scenario where software engineers do face trade-offs between the objectives of maximizing the coverage or minimizing the number of products to test. In contrast and to address this need, our work is the first to propose a classical multi-objective formalisation where both objectives are equally important. In this paper, we study the application to SPL pairwise testing of four classical multi-objective evolutionary algorithms. We developed three seeding strategies — techniques that leverage problem domain knowledge — and measured their performance impact on a large and diverse corpus of case studies using two well-known multi-objective quality measures. Our study identifies the performance differences among the algorithms and corroborates that the more domain knowledge leveraged the better the search results. Our findings enable software engineers to select not just one solution (as in the case of single-objective techniques) but instead to select from an array of test suite possibilities the one that best matches the economical and technological constraints of their testing context.', NULL);
INSERT INTO `list` VALUES (413, '0000-00-00', 2014, 'inproceedings', 'Vesela Angelova', 'Early concept of classification test and contemporary approach to diagnostic test and combinatorial test', 'Diagnosis', '', '2014 15th International Conference on Computer Systems and Technologies', 'CompSysTech', '', '', '240-247', '', '10.1145/2659532.2659618', 'Combinatorial Testing', 'In this work we show the relationship between three types of tasks -- classification, fault diagnosis and combinatorial testing. We show that these tasks have common idea to find the minimal test sets, which are sufficient for their goals. The first task is classification on the base of terminal tests voting. The second task is to identify the category with minimal, but unique vector of values. The third task is to find minimal number of configurations of parameters for testing, which include all pair (or t-way) interactions for fault-triggering. All they have application for product evaluation. We show a practical way to approach these tasks by converting them to a SAT problem and using a SAT solver to effectively find solutions.', NULL);
INSERT INTO `list` VALUES (414, '0000-00-00', 2014, 'inproceedings', 'Peter M. Kruse, Onn Shehory, Nelly Condori-Fernandez, Tanja E.J. Vos, Daniel Citron, Bilha Mendelson', 'Assessing the applicability of a combinatorial testing tool within an industrial environment', 'Evaluation', 'Tool', '2014 17th Ibero-American Conference on Software Engineering', 'other', '', '', '405-418', '', 'not found', 'Combinatorial Testing', 'This paper describes a case study executed to evaluate a combinatorial test design approach within the industrial setting of IBM Research. An existing combinatorial test suite was compared against a prioritized combinatorial test suite that was generated with the Combinatorial Tree Editor XL Profesional (CTE). The prioritization technique was recently developed and added to the CTE in the context of the FITTEST project. Test design for the new test suite was carried out by the developers of the prioritization technique. Test implementation and execution was done by the industrial partner of the System Under Test. This case study has investigated whether the prioritized combinatorial technique is useful to complement current testing practices at IBM Research. The focus of this study is on fault finding capability of artificially injected faults that have been selected and prioritized using domain knowledge and expertise, and efficiency of test case execution. Conclusions of this study are that for the testing of the target product in a simulated environment, the improved combinatorial testing tools do qualify as useful and this type of testing will be included in current practices.', NULL);
INSERT INTO `list` VALUES (415, '0000-00-00', 2014, 'inproceedings', 'Mustafa Al-Hajjaji, Thomas Thum, Jens Meinicke, Malte Lochau, Gunter Saake', 'Similarity-based prioritization in software product-line testing', 'Optimization', 'Priority', '2014 18th International Software Product Line Conference', 'SPLC', '1', '', '197-206', '', '10.1145/2648511.2648532', 'Combinatorial Testing', 'Exhaustively testing every product of a software product line (SPL) is a difficult task due to the combinatorial explosion of the number of products. Combinatorial interaction testing is a technique to reduce the number of products under test. However, it is typically up-to the tester in which order these products are tested. We propose a similarity-based prioritization to be applied on these products before they are generated. The proposed approach does not guarantee to find more errors than sampling approaches, but it aims at increasing interaction coverage of an SPL under test as fast as possible over time. This is especially beneficial since usually the time budget for testing is limited. We implemented similarity-based prioritization in FeatureIDE and evaluated it by comparing its outcome to the default outcome of three sampling algorithms as well as to random orders. The experiment results indicate that the order with similarity-based prioritization is better than random orders and often better than the default order of existing sampling algorithms.', NULL);
INSERT INTO `list` VALUES (416, '0000-00-00', 2014, 'inproceedings', 'Satoshi Fujimoto, Hideharu Kojima, Hiroyuki Nakagawa, Tatsuhiro Tsuchiya', 'Applying parameter value weighting to a practical application', 'Application', 'Priority', '2014 25th International Symposium on Software Reliability Engineering Workshops', 'ISSREW', '', '', '130-131', '', '10.1109/ISSREW.2014.63', 'Combinatorial Testing', 'This paper reports a case study where pair-wise testing was applied to a real-world program. In particular we focus on weighting, an added feature which allows the tester to prioritize particular parameter values. In our previous work we proposed a weighting method that can reflect given weights in the resulting test suite more directly than can existing methods. To asses the effects of weighting in a practical testing process, we compare the number of execution times of the program\'s methods among three pair-wise test suites, including the test suite generated by our weighting method and those generated by an existing test case generation tool with and without the weighting option. The results show that the effects of weighting were most clearly observed when our weighting method was used.', NULL);
INSERT INTO `list` VALUES (417, '0000-00-00', 2014, 'inproceedings', 'Ali Darvish, Carl K. Chang', 'GUIDiVa: Automated discovery and validation of state-based GUI invariants', 'Application', 'Sequence CA', '2014 38th Annual Computer Software and Applications Conference', 'COMPSAC', '', '', '65-74', '', '10.1109/COMPSAC.2014.93', 'Combinatorial Testing', 'Applications with a Graphical User Interface (GUI) front-end are ubiquitous, thus it is of great importance to assure the quality of such systems. Model-based GUI testing provides an effective mechanism for automated testing of applications with a GUI. However, most existing model-based GUI test generation techniques produce many infeasible (i.e., Broken) event sequences which are used as test cases. This happens primarily because they ignore behavioral specifications of the GUI under test. In this paper, we present an automated black box framework that reveals an important set of GUI invariants as state-based event constraints. GUIDiVa, an iterative algorithm at the core of our framework, enumerates all possible constraint violations as potential reasons of a test case failure, on the failed event of the infeasible test case. It further selects and adds the most promising constraints of each iteration to a final set based on our notion of constraint Validity Weight. The results of empirical studies on both seeded and nine non-trivial study subjects show that our framework is capable of capturing important aspects of GUI behavior, while considerably reducing the number of insfeasible test cases. Additionally, a human oracle is used to further validate the accuracy of the discovered constraints.', NULL);
INSERT INTO `list` VALUES (418, '0000-00-00', 2014, 'inproceedings', 'Laleh Sh. Ghandehari, Jacek Czerwonka, Yu Lei, Soheil Shafiee, Raghu N. Kacker, D. Richard Kuhn', 'An Empirical Comparison of Combinatorial and Random Testing', 'Evaluation', '', '2014 3rd International Workshop on Combinatorial Testing', 'IWCT', '', '', '68-77', '', '10.1109/ICSTW.2014.8', 'Combinatorial Testing', 'Some conflicting results have been reported on the comparison between t-way combinatorial testing and random testing. In this paper, we report a new study that applies t-way and random testing to the Siemens suite. In particular, we investigate the stability of the two techniques. We measure both code coverage and fault detection effectiveness. Each program in the Siemens suite has a number of faulty versions. In addition, mutation faults are used to better evaluate fault detection effectiveness in terms of both number and diversity of faults. The experimental results show that in most cases, t-way testing performed as good as or better than random testing. There are few cases where random testing performed better, but with a very small margin. Overall, the differences between the two techniques are not as significant as one would have probably expected. We discuss the practical implications of the results. We believe that more studies are needed to better understand the comparison of the two techniques.', NULL);
INSERT INTO `list` VALUES (419, '0000-00-00', 2014, 'inproceedings', 'Andrea Calvagna, Andrea Fornaia, Emiliano Tramontana', 'Combinatorial Interaction Testing of a Java Card Static Verifier', 'Application', '', '2014 3rd International Workshop on Combinatorial Testing', 'IWCT', '', '', '84-87', '', '10.1109/ICSTW.2014.10', 'Combinatorial Testing', 'We present a combinatorial interaction testing approach to perform validation testing of a fundamental component for the security of Java Cards: the byte code verifier. Combinatorial testing of all states of the Java Card virtual machine has been adopted as the coverage criteria. We developed a formal model of the Java Card byte code syntax to enable the combinatorial enumeration of well-formed states, and a formal model of the byte code semantic rules to be able to distinguish between well-typed and ill-typed ones, and to derive actual test programs from them. A complete framework has been implemented, enabling fully automated application and evaluation of the conformance tests to any verifier implementation.', NULL);
INSERT INTO `list` VALUES (420, '0000-00-00', 2014, 'inproceedings', 'Gunwant Dhadyalla, Neelu Kumari, Timothy Snell', 'Combinatorial Testing for an Automotive Hybrid Electric Vehicle Control System: A Case Study', 'Application', '', '2014 3rd International Workshop on Combinatorial Testing', 'IWCT', '', '', '51-57', '', '10.1109/ICSTW.2014.6', 'Combinatorial Testing', 'Embedded electrical systems for passenger vehicles are highly complex distributed systems with varying system boundaries. The surge towards further electrification of vehicles demands the deployment of high voltage systems that provide propulsion through an electric motor as part of a hybrid electric or pure electric drive train. This demands additional care and robust deployment to ensure the safety of the end user and the environment around them. Exhaustive testing is not feasible for large systems and the use of formal approaches can be restrictive. In the presented work a combinatorial test approach is applied to a real Hybrid Electric Vehicle control system as part of a hardware-in-the-loop test system. 2-way, 3-way and mixed strength up to 4-way testing is carried out. The concept of CAN main and local is devised to intercept CAN messages and replace them with the generated combinatorial tests using the HIL simulator\'s own processor to assure real-time testing. Early results indicate that the approach is effective in exposing incidents in system behavior not normally found during traditional functional testing.', NULL);
INSERT INTO `list` VALUES (421, '0000-00-00', 2014, 'inproceedings', 'Eitan Farchi, Itai Segall, Rachel Tzoref-Brill, Aviad Zlotnick', 'Combinatorial Testing with Order Requirements', 'Generation', 'Sequence CA, Constraint', '2014 3rd International Workshop on Combinatorial Testing', 'IWCT', '', '', '118-127', '', '10.1109/ICSTW.2014.13', 'Combinatorial Testing', 'Combinatorial Test Design, CTD, does not easily lend itself to the modeling of ordered parameter-values. Such modeling is much needed in practice, e.g. For the testing of sequences of API calls or parameterized events. We extend the CTD paradigm to address this need. We define a test as an ordered tuple of the parameter-values of the model, and introduce the concepts of ordered restrictions and ordered interaction coverage requirements. We develop an efficient algorithm for generating a small set of tests that satisfy the ordered and unordered interaction coverage requirements and evaluate it on several real-life examples.', NULL);
INSERT INTO `list` VALUES (422, '0000-00-00', 2014, 'inproceedings', 'Bernhard Garn, Dimitris E. Simos', 'Eris: A Tool for Combinatorial Testing of the Linux System Call Interface', 'Application', 'Tool', '2014 3rd International Workshop on Combinatorial Testing', 'IWCT', '', '', '58-67', '', '10.1109/ICSTW.2014.7', 'Combinatorial Testing', 'In this paper, we show the applicability of combinatorial testing to the system call interface of the Linux kernel. Our approach is two-fold: first we analyze the Trinity fuzz tester and in the aftermath we adapt the input parameter modeling of Trinity to the field of combinatorial testing. Furthermore, apart from the modeling itself, we target to provide a configurable testing framework for executing tests obtained by the ACTS combinatorial test generation tool, called Eris.', NULL);
INSERT INTO `list` VALUES (423, '0000-00-00', 2014, 'inproceedings', 'D. Richard Kuhn, Raghu N. Kacker, Yu Lei', 'Estimating Fault Detection Effectiveness', 'Evaluation', '', '2014 3rd International Workshop on Combinatorial Testing', 'IWCT', '', '', '154', '', '10.1109/ICSTW.2014.69', 'Combinatorial Testing', 'A t-way covering array can detect t-way faults, however they generally include other combinations beyond t-way as well. For example, a particular test set of all 5-way combinations is shown capable of detecting all seeded faults in a test program, despite the fact that it contains up to 9-way faults. This poster gives an overview of methods for estimating fault detection effectiveness of a test set based on combinatorial coverage for a class of software. Detection effectiveness depends on the distribution of t-way faults, which is not known. However based on past experience one could say for example the fraction of 1-way faults is F 1 = 60 %, 2- way faults F 2 = 25 % F 3 = 10 % and F 4 = 5 %. Such information could be used in determining the required strength t. It is shown that the fault detection effectiveness of a test set may be affected significantly by the t-way fault distribution, overall, simple coverage at each level of t, number of values per variable, and minimum t-way coverage. Using these results, we develop practical guidance for testers.', NULL);
INSERT INTO `list` VALUES (424, '0000-00-00', 2014, 'inproceedings', 'Preeti Satish, Arinjita Paul, Krishnan Rangarajan', 'Extracting the Combinatorial Test Parameters and Values from UML Sequence Diagrams', 'Model', '', '2014 3rd International Workshop on Combinatorial Testing', 'IWCT', '', '', '88-97', '', '10.1109/ICSTW.2014.11', 'Combinatorial Testing', 'In the current practice, the Combinatorial Test Design Model (CTDM) is designed by the test designers manually leveraging their experience in testing. Their involvement, perception, domain knowledge and testing proficiency are needed to analyze the requirements document and design the test model. Till date we know of no automated method that has eased the process of deriving the Combinatorial Test Design Model. Requirements document and analysis artifacts like UML activity diagrams and sequence diagrams hold information on parameters, values and constraints of the underlying CTDM. Our research focus is to develop a tool that assists test designers in coming up with the CTDM. This paper presents an approach to extract CTDM related information such as parameters and values from sequence diagrams. Our key contribution in this paper includes proposing a rule-based method for identifying the model elements from the sequence diagrams with the supporting rules and extraction algorithms. The rules have been applied onto individual sequence diagrams and results qualitatively discussed based on the general understanding of the requirements.', NULL);
INSERT INTO `list` VALUES (425, '0000-00-00', 2014, 'inproceedings', 'George Sherwood', 'Functional Dependence and Equivalence Class Factors in Combinatorial Test Designs', 'Model', '', '2014 3rd International Workshop on Combinatorial Testing', 'IWCT', '', '', '108-117', '', '10.1109/ICSTW.2014.12', 'Combinatorial Testing', 'Functionally dependent (FD) mappings permeate software systems and impose constraints on designs for verification. This paper develops concepts for accommodating FD relations in combinatorial test designs and derives rules to determine combinatorial coverage for FD factors. FD equivalence class factors are introduced to assess coverage of expected results classes before test case generation. Examples are given for test designs with FD factors, for applications of the coverage rules, and for coverage improvement techniques. A nondeterminant strength classification is formulated.', NULL);
INSERT INTO `list` VALUES (426, '0000-00-00', 2014, 'inproceedings', 'Jon Hagar, D. Richard Kuhn, Raghu N. Kacker, Tom Wissink', 'Introducing Combinatorial Testing in a Large Organization: Pilot Project Experience Report', 'Application', '', '2014 3rd International Workshop on Combinatorial Testing', 'IWCT', '', '', '153', '', '10.1109/ICSTW.2014.70', 'Combinatorial Testing', 'This poster gives an overview of the experience of eight pilot projects, over two years, applying combinatorial testing in Lockheed Martin (LM), one of the world\'s largest aerospace firms. Lockheed Martin and NIST developed a Co-operative Research and Development Agreement (CRADA) to evaluate effectiveness and areas of suitable application for combinatorial testing in a real-world industrial setting with complex software requirements. (One of the ways in which NIST conducts joint research with US industry is through CRADAs, which allow federal laboratories to work with US industry and provide flexibility in structuring projects, intellectual property rights, and in protecting industry proprietary information and research results).', NULL);
INSERT INTO `list` VALUES (427, '0000-00-00', 2014, 'inproceedings', 'Xiaohua Li, Zhao Dong, Huayao Wu, Changhai Nie, Kai-Yuan Cai', 'Refining a Randomized Post-optimization Method for Covering Arrays', 'Optimization', 'Reduction', '2014 3rd International Workshop on Combinatorial Testing', 'IWCT', '', '', '143-152', '', '10.1109/ICSTW.2014.16', 'Combinatorial Testing', 'Combinatorial testing is an efficient technique that reveals the faults caused by parameters interaction in software systems. It uses covering arrays as test suites to avoid the combinatorial explosion of parameter values. However, the construction of covering arrays with minimum size is still a challenging problem. This is because most of the existing methods to construct covering arrays result in extensive repetition of coverage. To address this challenging problem, some researchers proposed a randomized post-optimization method to reduce the number of rows in a covering array that has been already constructed. It repeatedly adjusts the array without loss of coverage. However, it seems that this method is not efficient as desired. In order to improve its efficiency, we propose a refined algorithm to replace the randomized algorithm adopted in the method. This avoids the local optima problem that arises in randomized algorithm. Experimental results are presented to confirm the benefits of the refined algorithm. In the cases of CA(N, 6, k, 2) (38 ≤ k ≤ 50) generated by IPO, this refined algorithm not only reduces more number of rows than the randomized algorithm, but also produces covering arrays that are smaller than previously best known ones. Furthermore, we provide a reasonable estimator to predict the extent to which covering arrays can be improved by this refined algorithm.', NULL);
INSERT INTO `list` VALUES (428, '0000-00-00', 2014, 'inproceedings', 'Huayao Wu, Changhai Nie, Fei-Ching Kuo', 'Test Suite Prioritization by Switching Cost', 'Optimization', 'Priority', '2014 3rd International Workshop on Combinatorial Testing', 'IWCT', '', '', '133-142', '', '10.1109/ICSTW.2014.15', 'Combinatorial Testing', 'Test suite generation and prioritization are two main research fields to improve testing efficiency. Combinatorial testing has been proven as an effective method to generate test suite for highly configurable software systems, while test suites are often prioritized by interaction coverage to detect faults as early as possible. However, for some cases, there exists reasonable cost of reconfiguring parameter settings when switching test cases in different orders. Surprisingly, only few studies paid attention to it. In this paper, by proposing greedy algorithms and graph-based algorithms, we aim to prioritize a given test suite to minimize its total switching cost. We also compare two different prioritization strategies by a series of experiments, and discuss the advantages of our prioritization strategy and the selection of prioritization techniques. The results show that prioritization by switching cost can improve testing efficiency and our prioritization strategy can produce a small test suite with a reasonably low switching cost. This prioritization can be used widely and help locate fault causing interactions. The results also suggest that when testing highly configurable software systems and no knowledge of fault detection can be used, prioritization by switching cost is a good choice to detect faults earlier.', NULL);
INSERT INTO `list` VALUES (429, '0000-00-00', 2014, 'inproceedings', 'Quentin Mayo, Ryan Michaels, Renée C. Bryce', 'Test Suite Reduction by Combinatorial-Based Coverage of Event Sequences', 'Optimization', 'Reduction, Sequence CA', '2014 3rd International Workshop on Combinatorial Testing', 'IWCT', '', '', '128-132', '', '10.1109/ICSTW.2014.14', 'Combinatorial Testing', 'Combinatorial-based criteria are useful in several studies for test suite generation, prioritization, and minimization. In this paper, we extend previous work by using combinatorial-based criteria for test suite reduction. We use criteria that are based on combinatorial coverage of events and consider the order in which events occur. A simple combinatorial-based criterion covers t-way events and does not differentiate between the order of events. The event pair (e1, e2) is counted the same as if it occurs in the order (e2, e1). We also use two criteria that consider the order in which events occur since different orderings of events may be valuable during testing. First, the consecutive sequence-based criterion counts all event sequences in different orders, but they must occur adjacent to each other. The sequence-based criterion counts pairs in all orders without the requirement that events must be adjacent. We evaluate the new criteria on three GUI applications. We use 2way inter-window coverage in our studies. All of the 2way combinatorial-based criteria are effective in reducing the test suites and maintaining close to 100% fault finding effectiveness. Our future work examines larger test suites, higher strength coverage, techniques to partition event data, and further empirical studies.', NULL);
INSERT INTO `list` VALUES (430, '0000-00-00', 2014, 'inproceedings', 'Sergiy Vilkomir, Brandi Amstutz', 'Using Combinatorial Approaches for Testing Mobile Applications', 'Application', '', '2014 3rd International Workshop on Combinatorial Testing', 'IWCT', '', '', '78-83', '', '10.1109/ICSTW.2014.9', 'Combinatorial Testing', 'Device-specific faults are very common for mobile software applications. To avoid such faults and guarantee the reliability and quality of mobile applications, sufficient testing is required on different mobile devices, which is expensive and time-consuming. This makes the task of the optimal selection of mobile devices for testing important and interesting from both practical and theoretical points of view. The suggested approach in this paper is based on combinatorial methods for coverage of each device characteristics. The initial results of the experimental investigation using comparisons with a random selection of devices are provided and show that the proposed approach is effective and promising.', NULL);
INSERT INTO `list` VALUES (431, '0000-00-00', 2014, 'inproceedings', 'Paolo Arcaini, Angelo Gargantini, Paolo Vavassori', 'Validation of Models and Tests for Constrained Combinatorial Interaction Testing', 'Model', 'Constraint', '2014 3rd International Workshop on Combinatorial Testing', 'IWCT', '', '', '98-107', '', '10.1109/ICSTW.2014.5', 'Combinatorial Testing', 'In Combinatorial Interaction Testing, models specify a set of parameters with associated domains, and some constraints over the parameters. Test generation tools produce, starting from these models, test suites for achieving some given coverage criteria. The validation of both the models and the produced test suites is a worthwhile activity. Validating the models permits to early discover possible defects in them, to feed the test generations tools with good inputs and, possibly, to improve the quality of the testing process. Validating the produced test suites, instead, permits to check if the test generation tools are correct and to judge their quality. This paper proposes to validate the models by checking that the constraints are consistent, that there is no constraint implied by the other constraints, and that the parameters and their values are really necessary. The proposed test suite validation, instead, consists in checking that the tests respect the type definitions and the constraints, that all the test requirements are covered, and that all the tests in the test suite are valid and necessary. For every error we propose a possible technique able to identify the potential causes and to suggest fixes for those problems. Experiments show that the targeted defects are widespread both in benchmark and real-life models.', NULL);
INSERT INTO `list` VALUES (432, '0000-00-00', 2014, 'inproceedings', 'Ana B. Sanchez, Sergio Segura, Antonio Ruiz-Cortes', 'A Comparison of test case prioritization criteria for software product lines', 'Optimization', 'Priority, Software Product Line', '2014 7th International Conference on Software Testing, Verification and Validation', 'ICST', '', '', '41-50', '', '10.1109/ICST.2014.15', 'Combinatorial Testing', 'Software Product Line (SPL) testing is challenging due to the potentially huge number of derivable products. To alleviate this problem, numerous contributions have been proposed to reduce the number of products to be tested while still having a good coverage. However, not much attention has been paid to the order in which the products are tested. Test case prioritization techniques reorder test cases to meet a certain performance goal. For instance, testers may wish to order their test cases in order to detect faults as soon as possible, which would translate in faster feedback and earlier fault correction. In this paper, we explore the applicability of test case prioritization techniques to SPL testing. We propose five different prioritization criteria based on common metrics of feature models and we compare their effectiveness in increasing the rate of early fault detection, i.e. a measure of how quickly faults are detected. The results show that different orderings of the same SPL suite may lead to significant differences in the rate of early fault detection. They also show that our approach may contribute to accelerate the detection of faults of SPL test suites based on combinatorial testing.', NULL);
INSERT INTO `list` VALUES (434, '0000-00-00', 2014, 'inproceedings', 'Wenjun Wu, Wei-Tek Tsai, Chao Jin, Guanqiu Qi, Luo Jie', 'Test-algebra execution in a cloud environment', 'Application', '', '2014 8th International Symposium on Service Oriented System Engineering', 'SOSE', '', '', '59-69', '', '10.1109/SOSE.2014.13', 'Combinatorial Testing', 'A algebraic system, Test Algebra (TA), identifies faults in combinatorial testing for SaaS (Software-as-a-Service) applications. SaaS is a software delivery model that involves composition, deployment, and execution of mission application on cloud platforms. Testing SaaS applications is challenging because a large number of configurations needs to be tested. Faulty configurations should be identified and corrected before the delivery of SaaS applications. TA proposes an effective way to reuse existing test results to identify test results of candidate configurations. The TA also defines rules to permit results to be combined, and to identify the faulty interactions. Using the TA, configurations can be tested concurrently on different servers and in any order. This paper proposes one MapReduce design of TA concurrent execution in a cloud environment. The optimization of TA analysis is discussed. The proposed solutions are simulated using Hadoop in a cloud environment.', NULL);
INSERT INTO `list` VALUES (435, '0000-00-00', 2014, 'article', 'Sangeeta Sabharwal, Manuj Aggarwal ', 'Identifying Interactions for Combinatorial Testing using Data Flow Techniques', 'Model', '', '2014 ACM SIGSOFT Software Engineering Notes', 'SIGSOFT ', '39', '6', '1--4', '', '10.1145/2674632.2674643', 'Combinatorial Testing', 'Combinatorial (t-way) testing has been proved to be an effective technique that identifies faults caused by interactions among a small number of input parameters. However, the degree of interaction to be considered for testing is still an open issue. Although higher strength t-way testing improves fault detection, it leads to a considerable increase in number of interactions to be tested and hence the test set size. In this paper, an approach is proposed that attempts to reduce the number of interactions to be tested. The source code is transformed into a flow graph and data flow analysis is applied to it to identify the interactions that exist in the system. The initial results suggest that the approach is able to achieve a considerable reduction in the number of interactions to be tested.', NULL);
INSERT INTO `list` VALUES (436, '0000-00-00', 2014, 'inproceedings', 'Rubing Huang, Jinfu Chen, Zhicheng Li, Rongcun Wang, Yansheng Lu', 'Adaptive random prioritization for interaction test suites', 'Optimization', 'Priority', '2014 Annual ACM Symposium on Applied Computing', 'SAC', '', '', '1058-1063', '', 'https://doi.org/10.1145/2554850.2554854', 'Combinatorial Testing', 'Combinatorial interaction testing (CIT), a black-box testing method, has been well studied in recent years. It aims at constructing an effective interaction test suites, so as to identify the faults that are caused by interactions among parameters. After interaction test suites are generated by CIT, the execution order of test cases in the test suite becomes critical due to limited testing resources. To determine test case order, the prioritization of interaction test suites has been employed. As we know, random prioritization (RP) of test cases has been considered as simple but ineffective. Existing research unveils that adaptive random prioritization (ARP) of test cases is an alternative and promising candidate that may replace RP. However, previous ARP techniques may not be used to prioritize interaction test suites due to the lack of source-code-related information in interaction test suite, such as statement coverage, function coverage, or branch coverage. In this paper, we not only propose the ARP strategy in order to prioritize interaction test suites by using interaction coverage information, without the source-code-related information, but also unify the RP strategy and traditional interaction-coverage based prioritization strategy (ICBP). Additionally, simulation studies indicate that the ARP strategy performs better than the RP strategy, test-case-generation prioritization, and reverse test-case-generation prioritization, and can also be more time-saving than ICBP while greatly maintaining similar, or even better, effectiveness.', NULL);
INSERT INTO `list` VALUES (437, '0000-00-00', 2014, 'inproceedings', 'Roberto E. Lopez-Herrejon, Javier Ferrer, Francisco Chicano, Evelyn Nicole Haslinger, Alexander Egyed, Enrique Alba', 'A parallel evolutionary algorithm for prioritized pairwise testing of software product lines', 'Generation', 'Search Based, Priority, Software Product Line', '2014 Annual Conference on Genetic and Evolutionary Computation', 'GECCO', '', '', '1255-1262', '', '10.1145/2576768.2598305', 'Combinatorial Testing', 'Software Product Lines (SPLs) are families of related software systems, which provide different feature combinations. Different SPL testing approaches have been proposed. However, despite the extensive and successful use of evolutionary computation techniques for software testing, their application to SPL testing remains largely unexplored. In this paper we present the Parallel Prioritized product line Genetic Solver (PPGS), a parallel genetic algorithm for the generation of prioritized pairwise testing suites for SPLs. We perform an extensive and comprehensive analysis of PPGS with 235 feature models from a wide range of number of features and products, using 3 different priority assignment schemes and 5 product prioritization selection strategies. We also compare PPGS with the greedy algorithm prioritized-ICPL. Our study reveals that overall PPGS obtains smaller covering arrays with an acceptable performance difference with prioritized-ICPL.', NULL);
INSERT INTO `list` VALUES (442, '0000-00-00', 2014, 'inproceedings', 'Peter M. Kruse, Wishnu Prasetya, Jurriaan Hage, Alexander Elyasov', 'Logging to Facilitate Combinatorial System Testing', 'Application', '', '2014 Future Internet Testing - FITTEST workshop', 'FITTEST', '', '', '48-58', '', '10.1007/978-3-319-07785-7_3', 'Combinatorial Testing', 'Testing a web application is typically very complicated. Imposing simple coverage criteria such as function or line coverage is often not sufficient to uncover bugs due to incorrect components integration. Combinatorial testing can enforce a stronger criterion, while still allowing the prioritization of test cases in order to keep the overall effort feasible. Combinatorial testing requires the whole testing domain to be classified and formalized, e.g., in terms of classification trees. At the system testing level, these trees can be quite large. This short paper presents our preliminary work to automatically construct classification trees from loggings of the system, and to subsequently calculate the coverage of our test runs against various combinatorial criteria. We use the tool CTE which allows such criteria to be custom specified. Furthermore, it comes with a graphical interface to simplify the specification of new test sequences.', NULL);
INSERT INTO `list` VALUES (443, '0000-00-00', 2014, 'article', 'Cemal Yilmaz, Sandro Fouche, Myra B. Cohen, Adam Porter, Gulsen Demiroz, Ugur Koc', 'Moving Forward with Combinatorial Interaction Testing', 'Other', 'Survey, Adaptive CT', '2014 IEEE Computer', 'Computer', '47', '2', '37-45 ', '', '10.1109/MC.2013.408', 'Combinatorial Testing', 'Combinatorial interaction testing (CIT) is an effective failure detection method for many types of software systems. This review discusses the current approaches CIT uses in detecting parameter interactions, the difficulties of applying it in practice, recent advances, and opportunities for future research.', NULL);
INSERT INTO `list` VALUES (445, '0000-00-00', 2014, 'article', 'Christopher Henard, Mike Papadakis, Gilles Perrouin, Jacques Klein, Patrick Heymans, Yves Le Traon', 'Bypassing the Combinatorial Explosion: Using Similarity to Generate and Prioritize T-Wise Test Configurations for Software Product Lines', 'Generation', 'Search Based, Software Product Line', '2014 IEEE Transactions on Software Engineering', 'TSE', '40', '7', '650-670', '', '10.1109/TSE.2014.2327020', 'Combinatorial Testing', 'Large Software Product Lines (SPLs) are common in industry, thus introducing the need of practical solutions to test them. To this end, t-wise can help to drastically reduce the number of product configurations to test. Current t-wise approaches for SPLs are restricted to small values of t. In addition, these techniques fail at providing means to finely control the configuration process. In view of this, means for automatically generating and prioritizing product configurations for large SPLs are required. This paper proposes (a) a search-based approach capable of generating product configurations for large SPLs, forming a scalable and flexible alternative to current techniques and (b) prioritization algorithms for any set of product configurations. Both these techniques employ a similarity heuristic. The ability of the proposed techniques is assessed in an empirical study through a comparison with state of the art tools. The comparison focuses on both the product configuration generation and the prioritization aspects. The results demonstrate that existing t-wise tools and prioritization techniques fail to handle large SPLs. On the contrary, the proposed techniques are both effective and scalable. Additionally, the experiments show that the similarity heuristic can be used as a viable alternative to t-wise.', NULL);
INSERT INTO `list` VALUES (446, '0000-00-00', 2014, 'article', 'Charles Song, Adam Porter, Jeffrey S. Foster', 'iTree: efficiently discovering high-coverage configurations using interaction trees', 'Generation', '', '2014 IEEE Transactions on Software Engineering', 'TSE', '40', '3', '251-265', '', '10.1109/TSE.2013.55', 'Combinatorial Testing', 'Modern software systems are increasingly configurable. While this has many benefits, it also makes some software engineering tasks,such as software testing, much harder. This is because, in theory,unique errors could be hiding in any configuration, and, therefore,every configuration may need to undergo expensive testing. As this is generally infeasible, developers need cost-effective technique for selecting which specific configurations they will test. One popular selection approach is combinatorial interaction testing (CIT), where the developer selects a strength t and then computes a covering array (a set of configurations) in which all t-way combinations of configuration option settings appear at least once. In prior work, we demonstrated several limitations of the CIT approach. In particular, we found that a given system\'s effective configuration space - the minimal set of configurations needed to achieve a specific goal - could comprise only a tiny subset of the system\'s full configuration space. We also found that effective configuration space may not be well approximated by t-way covering arrays. Based on these insights we have developed an algorithm called interaction tree discovery (iTree). iTree is an iterative learning algorithm that efficiently searches for a small set of configurations that closely approximates a system\'s effective configuration space. On each iteration iTree tests the system on a small sample of carefully chosen configurations, monitors the system\'s behaviors, and then applies machine learning techniques to discover which combinations of option settings are potentially responsible for any newly observed behaviors. This information is used in the next iteration to pick a new sample of configurations that are likely to reveal further new behaviors. In prior work, we presented an initial version of iTree and performed an initial evaluation with promising results. This paper presents an improved iTree algorithm in greater detail. The key improvements are based on our use of composite proto-interactions - a construct that improves iTree\'s ability to correctly learn key configuration option combinations, which in turn significantly improves iTree\'s running time, without sacrificing effectiveness. Finally, the paper presents a detailed evaluation of the improved iTree algorithm by comparing the coverage it achieves versus that of covering arrays and randomly generated configuration sets, including a significantly expanded scalability evaluation with the ~ 1M-LOC MySQL. Our results strongly suggest that the improved iTree algorithm is highly scalable and can identify a high-coverage test set of configurations more effectively than existing methods.', NULL);
INSERT INTO `list` VALUES (447, '0000-00-00', 2014, 'article', 'Cemal Yilmaz, Emine Dumlu, Myra B. Cohen, Adam Porter', 'Reducing Masking Effects in CombinatorialInteraction Testing: A Feedback Driven Adaptive Approach', 'Application', 'Adaptive CT', '2014 IEEE Transactions on Software Engineering', 'TSE', '40', '1', '43-66', '', '10.1109/TSE.2013.53', 'Combinatorial Testing', 'The configuration spaces of modern software systems are too large to test exhaustively. Combinatorial interaction testing (CIT) approaches, such as covering arrays, systematically sample the configuration space and test only the selected configurations. The basic justification for CIT approaches is that they can cost-effectively exercise all system behaviors caused by the settings of t or fewer options. We conjecture, however, that in practice some of these behaviors are not actually tested because of unanticipated masking effects - test case failures that perturb system execution so as to prevent some behaviors from being exercised. While prior research has identified this problem, most solutions require knowing the masking effects a priori. In practice this is impractical, if not impossible. In this work, we reduce the harmful consequences of masking effects. First we define a novel interaction testing criterion, which aims to ensure that each test case has a fair chance to test all valid t-way combinations of option settings. We then introduce a feedback driven adaptive combinatorial testing process (FDA-CIT) to materialize this criterion in practice. At each iteration of FDA-CIT, we detect potential masking effects, heuristically isolate their likely causes (i.e., fault characterization), and then generate new samples that allow previously masked combinations to be tested in configurations that avoid the likely failure causes. The iterations end when the new interaction testing criterion has been satisfied. This paper compares two different fault characterization approaches - an integral part of the proposed approach, and empirically assesses their effectiveness and efficiency in removing masking effects on two widely used open source software systems. It also compares FDA-CIT against error locating arrays, a state of the art approach for detecting and locating failures. Furthermore, the scalability of the proposed approach is evaluated by comparing it with perfect test scenarios, in which all masking effects are known a priori. Our results suggest that masking effects do exist in practice, and that our approach provides a promising and efficient way to work around them, without requiring that masking effects be known a priori.', NULL);
INSERT INTO `list` VALUES (448, '0000-00-00', 2014, 'article', 'Rubing Huang, Dave Towey, Jinfu Chen, Yansheng Lu', 'New metrics for prioritized interaction test suites', 'Optimization', 'Priority', '2014 IEICE Transactions on Information and Systems', 'other', 'E97-D', '4', '830-841', '', '10.1587/transinf.E97.D.830', 'Combinatorial Testing', 'Combinatorial interaction testing has been well studied in recent years, and has been widely applied in practice. It generally aims at generating an effective test suite (an interaction test suite) in order to identify faults that are caused by parameter interactions. Due to some constraints in practical applications (e.g. limited testing resources), for example in combinatorial interaction regression testing, prioritized interaction test suites (called interaction test sequences) are often employed. Consequently, many strategies have been proposed to guide the interaction test suite prioritization. It is, therefore, important to be able to evaluate the different interaction test sequences that have been created by different strategies. A well-known metric is the Average Percentage of Combinatorial Coverage (shortly APCCλ), which assesses the rate of interaction coverage of a strength λ (level of interaction among parameters) covered by a given interaction test sequence S. However, APCCλ has two drawbacks: firstly, it has two requirements (that all test cases in S be executed, and that all possible λ-wise parameter value combinations be covered by S ); and secondly, it can only use a single strength λ (rather than multiple strengths) to evaluate the interaction test sequence-which means that it is not a comprehensive evaluation. To overcome the first drawback, we propose an enhanced metric Normalized APCCλ (NAPCC) to replace the APCCλ. Additionally, to overcome the second drawback, we propose three new metrics: the Average Percentage of Strengths Satisfied (APSS); the Average Percentage of Weighted Multiple Interaction Coverage (APWMIC); and the Normalized APWMIC (NAPWMIC). These metrics comprehensively assess a given interaction test sequence by considering different interaction coverage at different strengths. Empirical studies show that the proposed metrics can be used to distinguish different interaction test sequences, and hence can be used to compare different test prioritization strategies.', NULL);
INSERT INTO `list` VALUES (449, '0000-00-00', 2014, 'inproceedings', 'Priti Bansal, Nitish Mittal, Aakanksha Sabharwal, Sakshi Koul', 'Integrating greedy based approach with genetic algorithm to generate mixed covering arrays for pair-wise testing', 'Generation', 'Search Based', '2014 International Conference on Contemporary Computing', 'other', '', '', '629-634', '', '10.1109/IC3.2014.6897246', 'Combinatorial Testing', 'The effectiveness of combinatorial interaction testing (CIT) to test highly configurable systems has constantly motivated researchers to look out for new techniques to construct optimal covering arrays that correspond to test sets. Pair-wise testing is a combinatorial testing technique that generates a pair-wise interaction test set to test all possible combinations of each pair of input parameter value. Meta heuristic techniques have being explored by researchers in past to construct optimal covering arrays for t-way testing (where, t denotes the strength of interaction). In this paper we apply genetic algorithm, a meta heuristic search based optimization algorithm to generate optimal mixed covering arrays for pair-wise testing. Here, we present a novel method that uses a greedy based approach to perform mutation and study the impact of the proposed approach on the performance of genetic algorithm. We describe the implementation of the proposed approach by extending an open source tool PWiseGen. Experimental results indicate that the use of greedy approach to perform mutation improves the performance of genetic algorithm by generating mixed covering arrays with higher fitness level in less number of generations as compared to those generated using other techniques.', NULL);
INSERT INTO `list` VALUES (450, '0000-00-00', 2014, 'inproceedings', 'Shiwei Gao, Jianghua Lv, Binglei Du, Yaruo Jiang, Shilong Ma', 'General Optimization Strategies for Refining the In-Parameter-Order Algorithm', 'Generation', '', '2014 International Conference on Quality Software', 'QSIC', '', '', '21-16', '', '10.1109/QSIC.2014.15', 'Combinatorial Testing', 'In-Parameter-Order (IPO) algorithm is an effective strategy of combinatorial testing. And several variants of the algorithm have been developed for reducing the runtime and size of test cases or for dealing with certain problems in test case generation, such as IPOG, IPOG-F and IPOG-F2. In this paper, the general optimization strategies, which can be applied to these variants of the algorithm, are proposed to make each value of all parameters more evenly distributed in the test cases. The proposed optimization strategies mainly focus on choosing values for the extension to an additional parameter during the horizontal growth of the algorithm and filling values for don\'t care positions. Experimental results show that the proposed optimization strategies are effective in reducing runtime and producing smaller size of test suites with the increase of the domain size.', NULL);
INSERT INTO `list` VALUES (451, '0000-00-00', 2014, 'inproceedings', 'Yasuhiro Hirasaki, Hideharu Kojima, Tatsuhiro Tsuchiya', 'Applying random testing to constrained interaction testing', 'Generation', 'Constraint', '2014 International Conference on Software Engineering and Knowledge Engineering', 'SEKE', '', '', '193-198', '', 'not found', 'Combinatorial Testing', 'This paper discusses interaction testing using random testing. Random testing can generate test cases very fast; but directly applying this method to interaction testing may result in insufficient interaction coverage if constraints exist over parameter values. We propose a random testing approach that is tailored to constrained interaction testing to solve this problem. In this approach, if a test case that was randomly generated violates the constraints, then new test cases are systematically generated to compensate the loss in interaction coverage that would be caused by simply discarding that constraint-violating test case. The technical challenge here is how to reduce the number of those newly generated test cases. We propose a novel algorithm for this purpose and two methods that can be incorporated in the algorithm. Experimental results show that the proposed approach can generate test suites very fast and that the proposed two methods work very effectively in reducing the number of additional test cases. Keywords—Random testing, combinatorial interaction testing, constraints', NULL);
INSERT INTO `list` VALUES (452, '0000-00-00', 2014, 'inproceedings', 'Rubing Huang, Jinfu Chen, Rongcun Wang, Deng Chen', 'How to do tie-breaking in prioritization of interaction test suites?', 'Optimization', 'Priority', '2014 International Conference on Software Engineering and Knowledge Engineering', 'SEKE', '', '', '121-125', '', 'not found', 'Combinatorial Testing', 'The prioritization of interaction test suites has received more attention in the field of combinatorial interaction testing, especially when testing resources are limited to allow the part of combinatorial test cases to be executed. Many strategies have been proposed to prioritize interaction test suites according to different evaluation measures. However, most of these strategies may face a challenge to choose more than one “best” candidate with the largest evaluation measure value. In this case, there is a tie among all “best” candidates. How to do tie-breaking? Intuitively speaking, random tiebreaking could be a reasonable choice, which has also been applied to many research papers. In this paper, we investigate different tie-breaking techniques including random tiebreaking, first-element tie-breaking, last-element tie-breaking, higher-strength tie-breaking, and lower-strength tie-breaking, and also conduct experiments on a well-known prioritization strategy of interaction test suites, namely interaction coverage based prioritization, in order to present a guideline of choosing tie-breaking techniques for testers in practical testing. The experimental results show that although no tie-breaking technique always performs best, in many cases random tie-breaking and last-element tie-breaking have best performance, so that they would be best choices for testers in the prioritization of interaction test suites. Keywords-Combinatorial interaction testing, interaction test suite, test case prioritization, tie-breaking, guideline', NULL);
INSERT INTO `list` VALUES (453, '0000-00-00', 2014, 'inproceedings', 'Wei-Tek Tsai, Guanqiu Qi, Lian Yu, Jerry Gao', 'TaaS (Testing-as-a-Service) Design for Combinatorial Testing', 'Application', '', '2014 International Conference on Software Security and Reliability', 'SERE', '', '', '127-136', '', '10.1109/SERE.2014.26', 'Combinatorial Testing', 'Testing-as-a-Service (TaaS) in a cloud environment can leverage the computation power provided by the cloud. Specifically, testing can be scaled to large and dynamic workloads, executed in a distributed environment with hundreds of thousands of processors, and these processors may support concurrent and distributed test execution and analysis. TaaS may be implemented as SaaS and used to test SaaS applications. This paper proposes a TaaS design for SaaS combinatorial testing. Test Algebra (TA) and Adaptive Reasoning (AR) algorithm are used in the TaaS design.', NULL);
INSERT INTO `list` VALUES (454, '0000-00-00', 2014, 'inproceedings', 'Mike Papadakis, Christopher Henard, Yves Le Traon', 'Sampling Program Inputs with Mutation Analysis: Going Beyond Combinatorial Interaction Testing', 'Evaluation', '', '2014 International Conference on Software Testing, Verification and Validation', 'ICST', '', '', '1--10', '', '10.1109/ICST.2014.11', 'Combinatorial Testing', 'Modern systems tend to be highly configurable. Testing such systems requires selecting test cases from a large input space. Thus, there is a need to systematically sample program inputs in order to reduce the testing effort. In such cases, testing the interactions between program parameters has been identified as an effective way to deal with this problem. In these lines, Combinatorial Interaction Testing (CIT) models the program input interactions and uses this model to select test cases. Going a step further, we apply mutation analysis on the CIT input model to select program test cases. Mutation operates by injecting defects to the program input model and measures the number of defects found by the selected test cases. Experiments performed on four real programs show that measuring the number of model-based defects gives a stronger correlation to code-level faults than measuring the number of the exercised interactions. Therefore, the proposed mutation analysis approach forms a valid and more effective alternative to CIT.', NULL);
INSERT INTO `list` VALUES (455, '0000-00-00', 2014, 'inproceedings', 'Paul Wojciak, Rachel Tzoref-Brill', 'System Level Combinatorial Testing in Practice - The Concurrent Maintenance Case Study', 'Application', '', '2014 International Conference on Software Testing, Verification and Validation', 'ICST', '', '', '103-112', '', '10.1109/ICST.2014.23', 'Combinatorial Testing', 'Combinatorial test design (CTD) is an effective test design technique that reveals faults resulting from parameter interactions in a system. CTD requires a test space definition in the form of a set of parameters, their respective values, and restrictions on the value combinations. Though CTD is considered an industry best practice, there is only a small body of work on the practical application of CTD to industrial systems, and some key elements of the CTD application process are under-explored. Specifically, little consideration has been given to the process for identifying the parameters of the test space and their interrelations, how to validate the test space definition remains an open question, the application of CTD in reported work concentrates mostly on function or interface level testing and is hardly expanded to other levels of testing, and there is a significant lack of evaluation of the degree to which CTD helped improve the quality of the system under test. In this work, we analyze the continuous application of CTD in system test of two large industrial systems: IBM® POWER7® and IBM® System z®. For POWER7, CTD was used to design test cases for server concurrent maintenance. The application of CTD was in direct response to inconsistent reliability of those features on the prior POWER6® servers, and resulted in noteworthy quality improvements on POWER7. Success with POWER7 led to application of the methods to System z Enhanced Driver Maintenance testing, also featured in this work. To the best of our knowledge, this is the first comprehensive analysis of CTD usage in system test of industrial products, and the first analysis of long term use of CTD. We describe the methodology that we followed to define the combinatorial test space, while answering some unique challenges rising from the use of CTD to design functional test cases at system level rather than at interface or function level. We also describe our methodology for evaluating the test space definition and continuously improving it over time. In addition, we describe advanced CTD features that we found helpful for achieving an effective yet affordable test plan. Finally, we quantitatively and qualitatively evaluate the overall effectiveness of CTD usage, and show that it resulted in significantly improved server concurrent maintenance features.', NULL);
INSERT INTO `list` VALUES (456, '0000-00-00', 2014, 'inproceedings', 'Shiwei Gao, Binglei Du, Yaruo Jiang, Jianghua Lv, Shilong Ma', 'An efficient algorithm for pairwise test case generation in presence of constraints', 'Generation', 'Constraint', '2014 International Conference on Systems and Informatics', 'ICSAI', '', '', '406-410', '', '10.1109/ICSAI.2014.7009323', 'Combinatorial Testing', 'Constraints handling problem in combinational testing is an intensive computation process. In this paper, we present an effective algorithm, called IPO SAT (In-Parameter-Order-Satisfiability), for pairwise test case generation in presence of constraints. In our strategy, constraints are denoted as forbidden tuples, which are converted to conjunctive normal form. Then, the combination test cases which meet the constraints are found out by calling Boolean satisfiability(SAT) solvers. Besides, an optimization upon the process is given, in order to improve the performance of IPO SAT by reducing the number of times of calling SAT solver and avoiding checking irrelevant constraints. Finally, experimental results show that the proposed IPO SAT algorithm is efficient and the optimization has obvious improvements on reducing time cost.', NULL);
INSERT INTO `list` VALUES (457, '0000-00-00', 2014, 'inproceedings', 'Nelly Condori-Fernandez, Peter M. Kruse, Tanja E.J. Vos, Etienne Brosse, Alessandra Bagnato', 'Combinatorial Testing in an Industrial Environment -- Analyzing the Applicability of a Tool', 'Application', 'Tool', '2014 International Conference on the Quality of Information and Communications Technology', 'QUATIC', '', '', '210-215', '', '10.1109/QUATIC.2014.36', 'Combinatorial Testing', 'Numerous combinatorial testing tools are available for generating test cases. However, many of them are never used in practice. One of the reasons is the lack of empirical studies that involve human subjects applying testing techniques. This paper aims to investigate the applicability of a combinatorial testing tool in the company SOFTEAM. A case study is designed and conducted within the development team responsible for a new product. The participants consist of 3 practitioners from the company. The applicability of the tool has been examined in terms of efficiency, effectiveness and learning effort.', NULL);
INSERT INTO `list` VALUES (458, '0000-00-00', 2014, 'inproceedings', 'Angelo Gargantini, Paolo Vavassori', 'Efficient Combinatorial Test Generation Based on Multivalued Decision Diagrams', 'Generation', '', '2014 International Haifa Verification Conference', 'IHVC', '', '', '220-235', '', '10.1007/978-3-319-13338-6_17', 'Combinatorial Testing', 'Combinatorial interaction testing (CIT) is an emerging testing technique that has proved to be effective in finding faults due to the interaction among inputs. Efficient test generation for CIT is still an open problem especially when applied to real models having meaningful size and containing many constraints among inputs. In this paper we present a novel technique for the automatic generation of compact test suites starting from models containing constraints given in general form. It is based on the use of Multivalued Decision Diagrams (MDDs) which prove to be suitable to efficiently support CIT. We devise and experiment several optimizations including a novel variation of the classical greedy policy normally used in similar algorithms. The results of a thorough comparison with other similar techniques are presented and show that our approach can provide several advantages in terms of applicability, test suite size, generation time, and cost.', NULL);
INSERT INTO `list` VALUES (461, '0000-00-00', 2014, 'inproceedings', 'Linbin Yu, Feng Duan, Yu Lei, Raghu N. Kacker, D. Richard Kuhn', 'Combinatorial Test Generation for Software Product Lines Using Minimum Invalid Tuples', 'Generation', 'Software Product Line', '2014 International Symposium on High Assurance System Engineering', 'HASE', '', '', '65-72', 'IEEE', '10.1109/HASE.2014.18', 'Combinatorial Testing', 'A software product line is a set of software systems that share some common features. Several recent works have been reported that apply combinatorial testing, a very effective testing strategy, to software product lines. A unique challenge in these efforts is dealing with a potentially large number of constraints among different features. In this paper, we propose a novel constraint-handling strategy that uses minimum invalid tuples (MITs) as an alternative to traditional constraint solvers. Our approach systematically derives all MITs from a software product line, and uses them to quickly determine the validity of a test configuration during test generation. We implemented a test generation research tool called LOOKUP that integrates the proposed constraint-handling strategy with a general test generation algorithm called IPOG-C. Experimental results show that LOOKUP performs considerably better than two existing test generation tools in terms of test size and execution time.', NULL);
INSERT INTO `list` VALUES (462, '0000-00-00', 2014, 'inproceedings', 'Wei-Tek Tsai, Jie Luo, Guanqiu Qi, Wenjun Wu', 'Concurrent Test Algebra Execution with Combinatorial Testing', 'Application', '', '2014 International Symposium on Service Oriented System Engineering', 'SOSE', '', '', '35-46', '', '10.1109/SOSE.2014.11', 'Combinatorial Testing', 'Software-as-a-Service (SaaS), a new software delivery model, plays an important role in daily life. In SaaS, mission-critical applications are composed, deployed, and executed on cloud platforms. SaaS applications needed to have high reliability and availability before publishing. Testing SaaS applications becomes important, as the large number of testing prior to their deployment. Test Algebra (TA), a algebraic system, identifies faults in combinatorial testing for SaaS applications using existing test results and eliminates those related faults. Although TA eliminates a large number of configurations from considerations, it is still difficult to finish testing enormous combinations of services in a reasonable time. To improve TA analysis, this paper proposes a concurrent TA analysis. It allocates workloads into different clusters of computers and performs TA analysis from 2-way to 6-way configurations. Different database designs are used to store the test results of various configurations. Faulty and operational table search algorithms are proposed to retrieve existing test results. One 25-component experiment is simulated using the proposed solutions. The same experiment is also simulated on multiple processors for concurrent TA analysis.', NULL);
INSERT INTO `list` VALUES (463, '0000-00-00', 2014, 'inproceedings', 'Sunint Kaur Khalsa, Yvan Labiche', 'An Orchestrated Survey of Available Algorithms and Tools for Combinatorial Testing', 'Other', 'Tool, Survey', '2014 International Symposium on Software Reliability Engineering', 'ISSRE', '', '', '323-334', '', '10.1109/ISSRE.2014.15', 'Combinatorial Testing', 'For functional testing based on the input domain of a functionality, parameters and their values are identified and a test suite is generated using a criterion exercising combinations of those parameters and values. Since software systems are large, resulting in large numbers of parameters and values, a technique based on combinatorics called Combinatorial Testing (CT) is used to automate the process of creating those combinations. CT is typically performed with the help of combinatorial objects called Covering Arrays. The goal of the present work is to determine available algorithms/tools for generating a combinatorial test suite. We tried to be as complete as possible by using a precise protocol for selecting papers describing those algorithms/tools. The 75 algorithms/tools we identified are then categorized on the basis of different comparison criteria, including: the test suite generation technique, the support for selection (combination)criteria, mixed covering array, the strength of coverage, and the support for constraints between parameters. Results can be of interest to researchers or software companies who are looking for a CT algorithm/tool suitable for their needs.', NULL);
INSERT INTO `list` VALUES (464, '0000-00-00', 2014, 'inproceedings', 'Jose A. Galindo, Mauricio Alferez, Mathieu Acher, Benoit Baudry, David Benavides', 'A variability-based testing approach for synthesizing video sequences', 'Application', '', '2014 International Symposium on Software Testing and Analysis', 'ISSTA', '', '', '293-303', '', '10.1145/2610384.2610411', 'Combinatorial Testing', 'A key problem when developing video processing software is the difficulty to test different input combinations. In this paper, we present VANE, a variability-based testing approach to derive video sequence variants. The ideas of VANE are i) to encode in a variability model what can vary within a video sequence; ii) to exploit the variability model to generate testable configurations; iii) to synthesize variants of video sequences corresponding to configurations. VANE computes T-wise covering sets while optimizing a function over attributes. Also, we present a preliminary validation of the scalability and practicality of VANE in the context of an industrial project involving the test of video processing algorithms.', NULL);
INSERT INTO `list` VALUES (465, '0000-00-00', 2014, 'inproceedings', 'Josip Bozic, Dimitris E. Simos, Franz Wotawa', 'Attack pattern-based combinatorial testing', 'Application', '', '2014 International Workshop on Automation of Software Test', 'IWAST', '', '', '1--9', '', '10.1145/2593501.2593502', 'Combinatorial Testing', 'The number of potential security threats rises with the increasing number of web applications, which cause tremendous financial and existential implications for developers and users as well. The biggest challenge for security testing is to specify and implement ways in order to detect potential vulnerabilities of the developed system in a never ending quest against new security threats but also to cover already known ones so that a program is suited against typical attack vectors. For these purposes many approaches have been developed in the area of model-based security testing in order to come up with solutions for real-world application problems. These approaches provide theoretical background as well as practical solutions for certain security issues. In this paper, we partially rely on previous work but focus on the representation of attack patterns using UML state diagrams. We extend previous work in combining the attack pattern models with combinatorial testing in order to provide concrete test input, which is submitted to the system under test. With combinatorial testing we capture different combinations of inputs and thus increasing the likelihood to find weaknesses in the implementation under test that can be exploited. Besides the foundations of our approach we further report on first experiments that indicate its practical use.', NULL);
INSERT INTO `list` VALUES (466, '0000-00-00', 2014, 'inproceedings', 'Huayao Wu, Changhai Nie', 'An overview of search based combinatorial testing', 'Other', 'Search Based, Survey', '2014 International Workshop on Search-Based Software Testing', 'SBST', '', '', '27-30', '', '10.1145/2593833.2593839', 'Combinatorial Testing', 'Combinatorial testing (CT) is a branch of software testing, which aims to detect the interaction triggered failures as much as possible. Search based combinatorial testing is to use the search techniques to solve the problem in combinatorial testing. It has been shown to be effective and promising. In this paper, we aim to provide an overview of search based combinatorial testing, especially focusing on test suite generation without constraint, and discuss the potential future directions in this field.', NULL);
INSERT INTO `list` VALUES (468, '0000-00-00', 2014, 'article', 'Zhiqiang Zhang, Jun Yan, Yong Zhao, Jian Zhang', 'Generating combinatorial test suite using combinatorial optimization', 'Generation', 'Constraint', '2014 Journal of Systems and Software', 'JSS', '98', '0', '191-207', '', '10.1016/j.jss.2014.09.001', 'Combinatorial Testing', 'Combinatorial testing (CT) is an effective technique to test software with multiple configurable parameters. It is used to detect interaction faults caused by the combination effect of parameters. CT test generation aims at generating covering arrays that cover all t-way parameter combinations, where t is a given covering strength. In practical CT usage scenarios, there are usually constraints between parameters, and the performance of existing constraint-handling methods degrades fast when the number of constraints increases.\r\n\r\nThe contributions of this paper are (1) we propose a new one-test-at-a-time algorithm for CT test generation, which uses pseudo-Boolean optimization to generate each new test case; (2) we have found that pursuing the maximum coverage for each test case is uneconomic, and a possible balance point is to keep the approximation ratio in [0.8,0.9]; (3) we propose a new self-adaptive mechanism to stop the optimization process at a proper time when generating each test case; (4) extensive experimental results show that our algorithm works fine on existing benchmarks, and the constraint-handling ability is better than existing approaches when the number of constraints is large; and (5) we propose a method to translate shielding parameters (a common type of constraints) into normal constraints.', NULL);
INSERT INTO `list` VALUES (470, '0000-00-00', 2014, 'article', 'Rozmie R. Othman, Norazlina Khamis, Kamal Z. Zamli', 'Variable strength t-way test suite generator with constraints support', 'Generation', 'Constraint', '2014 Malaysian Journal of Computer Science', 'other', '27', '3', '204-217', '', 'not found', 'Combinatorial Testing', 'T-way testing (or interaction testing) is a common test planning method used to sample a complete or exhaustive test suite systematically.In t-way testing, it is assumed that interaction only occurs between t numbers of parameters (where t is the interaction strength). Therefore, all t-way strategies generate the t-way test suite with the intention to cover every possible combination produces by the interacting parameters (or also known as tuples). However, for some systems under test(SUT), there are some combinations that are known to produce invalid outputs or eventrigger unwanted errors. Additionally, there are also some known combinations that are impossible to occur due to requirements set to the system. As such, these combinations (termed constraints) have to be excluded from the final test suite. Whilemany t-way strategies have been proposed in literature for the past 20 years (e.g. GTWay, MIPOG, TConfig and TCG), only IPOG and PICT strategies have been known to support constraints in variable strength test suite generation. However, as t-way test suite generation process is an NP-hard problem, no single strategy can claim dominance over the others. Motivated by the challenges, this paper proposes a new strategy named General Variable Strength with Constraints (GVS_CONST) that support variable strength interaction with constraints consideration. Empirical evidence demonstrates that in most cases GVS_CONST outperforms other competing strategies in term of test suite size', NULL);
INSERT INTO `list` VALUES (471, '0000-00-00', 2014, 'inproceedings', 'Takahiro Nagamoto, Hideharu Kojima, Hiroyuki Nakagawa, Tatsuhiro Tsuchiya', 'Locating a Faulty Interaction in Pair-wise Testing (short)', 'Diagnosis', '', '2014 Pacific Rim International Symposium on Dependable Computing', 'PRDC', '', '', '155-156', '', '10.1109/PRDC.2014.26', 'Combinatorial Testing', 'This article discusses the location of faulty interactions in software testing. We propose an algorithm to generate a test suite that can be used to identify a faulty pair-wise interaction. This approach works as follows. First, a test suite is generated using an existing method for pair-wise testing. Pair-wise testing requires testing all pair-wise interactions but does not guarantee that the faulty interaction can be located. Second, pair-wise interactions that cannot be located by the test suite are enumerated. Finally, test cases are repeatedly added to the test suite until all pair-wise interactions can be located. The results of applying the algorithm to several problem instances show that the test suites obtained using the algorithm are nearly twice as large as those for ordinary pair-wise testing which does not ensure fault locating ability.', NULL);
INSERT INTO `list` VALUES (472, '0000-00-00', 2014, 'article', 'Kyungmin Go, Sungwon Kang, Jongmoon Baik, Myungchul Kim', 'Pairwise testing for systems with data derived from real-valued variable inputs', 'Model', '', '2014 Software: Practice and Experience', 'other', '', '', '1--23', '', '10.1002/spe.2295', 'Combinatorial Testing', 'Pairwise testing is an effective combinatorial test case generation approach in which test cases are developed to execute all possible pairwise combinations of system inputs. It can help reduce the number of test cases and save testing time yet still effective in finding defects. However, it is very difficult for practitioners to effectively apply pairwise testing in the real world because of the lack of suitable techniques and guidelines. To redress this situation, this paper conducts a case study of applying pairwise testing to system data derived from real-valued variable inputs. In order to apply pairwise testing to this case study, this paper develops a test procedure and a novel partitioning method to test derived data as a naïve application of the conventional pairwise testing that would produce a huge number of test cases. A comparative evaluation shows that the pairwise testing of the proposed approach is more effective than the random testing with a 12–20% higher fault detection ratio. Based on our experience, guidelines for applying pairwise testing in practice are also presented. Copyright © 2014 John Wiley & Sons, Ltd.', NULL);
INSERT INTO `list` VALUES (473, '0000-00-00', 2014, 'incollection', 'Eun-Hye Choi, Takashi Kitamura, Cyrille Artho, Yutaka Oiwa', 'Design of Prioritized N-wise Testing', 'Optimization', 'Priority', '2014 Testing Software and Systems', 'Book', '8763', '', '186-191', 'Elsevier', '10.1007/978-3-662-44857-1_14', 'Combinatorial Testing', 'N-wise testing is a widely used technique for combinatorial interaction testing. Prioritizing testing reorders test cases by relevance, testing important aspects more thoroughly. We propose a novel\r\ntechnique for N-wise test case generation to satisfy the three distinct\r\nprioritization criteria of interaction coverage, weight coverage, and KL\r\ndivergence. The proposed technique generates small N-wise test cases,\r\nwhere high-priority test cases appear early and frequently. Our early\r\nevaluation confirms that the proposed technique improves on existing\r\ntechniques based on the three prioritization criteria.', NULL);
INSERT INTO `list` VALUES (474, '0000-00-00', 2014, 'inproceedings', 'Bernhard Garn, Ioannis Kapsalis, Dimitris E. Simos, Severin Winkler', 'On the applicability of combinatorial testing to web application security testing: a case study', 'Application', '', '2014 Workshop on Joining AcadeMiA and Industry Contributions to Test Automation and Model-Based Testing', 'other', '', '', '16-21', '', '10.1145/2631890.2631894', 'Combinatorial Testing', 'Case studies for evaluating tools in security testing are powerful. Although they cannot achieve the scientific rigor of formal experiments, the results can provide sufficient information to help professionals judge if a specific technology being evaluated will benefit their organization. This paper reports on a case study done for evaluating and revisiting a recently introduced combinatorial testing methodology used for web application security purposes. It further reports on undertaken practical experiments thus strengthening the applicability of combinatorial testing to web application security testing.', NULL);
INSERT INTO `list` VALUES (475, '0000-00-00', 2014, 'book', 'Jian Zhang, Zhiqiang Zhang, Feifei Ma', 'Automatic Generation of Combinatorial Test Data', 'Generation', 'Constraint', '2014 not found', 'Book', '', '', 'not found', 'Springer Berlin Heidelberg', '10.1007/978-3-662-43429-1', 'Combinatorial Testing', 'This book reviews the state-of-the-art in combinatorial testing, with particular emphasis on the automatic generation of test data. It describes the most commonly used approaches in this area - including algebraic construction, greedy methods, evolutionary computation, constraint solving and optimization - and explains major algorithms with examples. In addition, the book lists a number of test generation tools, as well as benchmarks and applications. Addressing a multidisciplinary topic, it will be of particular interest to researchers and professionals in the areas of software testing, combinatorics, constraint solving and evolutionary computation.', NULL);
INSERT INTO `list` VALUES (476, '0000-00-00', 2014, 'book', 'D. Richard Kuhn, Raghu N. Kacker, Yu Lei', 'Introduction to combinatorial testing', 'Other', 'Survey', '2014 not found', 'Book', '', '', 'not found', 'CRC Press', 'not found', 'Combinatorial Testing', 'Combinatorial testing of software analyzes interactions among variables using a very small number of tests. This advanced approach has demonstrated success in providing strong, low-cost testing in real-world situations. Introduction to Combinatorial Testing presents a complete self-contained tutorial on advanced combinatorial testing methods for real-world software. The book introduces key concepts and procedures of combinatorial testing, explains how to use software tools for generating combinatorial tests, and shows how this approach can be integrated with existing practice. Detailed explanations and examples clarify how and why to use various techniques. Sections on cost and practical considerations describe tradeoffs and limitations that may impact resources or funding. While the authors introduce some of the theory and mathematics of combinatorial methods, readers can use the methods without in-depth knowledge of the underlying mathematics. Accessible to undergraduate students and researchers in computer science and engineering, this book illustrates the practical application of combinatorial methods in software testing. Giving pointers to freely available tools and offering resources on a supplementary website, the book encourages readers to apply these methods in their own testing projects', NULL);
INSERT INTO `list` VALUES (477, '0000-00-00', 2015, 'inproceedings', 'Roberto E. Lopez-Herrejon, Stefan Fischer, Rudolf Ramler, Alexander Egyed', 'A First Systematic Mapping Study on Combinatorial Interaction Testing for Software Product Lines', 'Other', 'Software Product Line, Survey', '2015 4th International Workshop on Combinatorial Testing', 'IWCT', '', '', '1--10', 'IEEE', '10.1109/ICSTW.2015.7107435', 'Combinatorial Testing', 'Software Product Lines (SPLs) are families of related software systems distinguished by the set of features each one provides. Over the past decades SPLs have been the subject of extensive research and application both in academia and industry. SPLs practices have proven benefits such as better product customization and reduced time to market. Testing SPLs pose additional challenges stemming from the typically large number of product variants which make it infeasible to test every single one of them. In recent years, there has been an extensive research on applying Combinatorial Interaction Testing (CIT) for SPL testing. In this paper we present the first systematic mapping study on this subject. Our research questions aim to gather information regarding the techniques that have been applied, the nature of the case studies used for their evaluation, and what phases of CIT have been addressed. Our goal is to identify common trends, gaps, and opportunities for further research and application.', NULL);
INSERT INTO `list` VALUES (478, '0000-00-00', 2015, 'inproceedings', 'Siegmar Zufle, Venkataraman Krishnamoorthy', 'A process for nonfunctional combinatorial testing: Selection of parameter values from a nondiscrete domain space', 'Model', '', '2015 4th International Workshop on Combinatorial Testing', 'IWCT', '', '', '1--4', 'IEEE', '10.1109/ICSTW.2015.7107437 ', 'Combinatorial Testing', 'This paper describes the preliminary and subsequent work before and after a combinatorial test set generation for non-functional full-automatic testing of a car infotainment system. It is an example where physical quantities (time and voltage) are used in the set of parameter combinations. This is done by transforming generated test cases with discrete values into the physical parameter value domain space. It is demonstrated why an additional “reproducible randomness” is introduced. It is also explained why and how parameters control test case execution on the basis of the Automated Combinatorial Testing for Software tool.', NULL);
INSERT INTO `list` VALUES (479, '0000-00-00', 2015, 'inproceedings', 'Laleh Sh. Ghandehari, Jaganmohan Chandrasekaran, Yu Lei, Raghu N. Kacker, D. Richard Kuhn', 'BEN: A Combinatorial Testing-Based Fault Localization Tool', 'Diagnosis', 'Tool', '2015 4th International Workshop on Combinatorial Testing', 'IWCT', '', '', '1--4', 'IEEE', '10.1109/ICSTW.2015.7107446', 'Combinatorial Testing', 'We present a combinatorial testing-based fault localization tool called BEN. BEN takes as input three types of information, including the subject program, the source code, an input parameter model, and a combinatorial test set created based on the input parameter model. It is assumed that the combinatorial test set has already been executed, and thus the execution status of each test is known. The output of BEN is a ranking of statements in terms of their likelihood to be faulty. In the fault localization process, a small number of additional tests are generated by BEN and need to be executed by the user. In this paper, we present the major user scenarios and the highlevel design of BEN. BEN is implemented in Java and provides a graphical user interface that provides friendly access to the tool.', NULL);
INSERT INTO `list` VALUES (480, '0000-00-00', 2015, 'inproceedings', 'Arsalan Javeed, Cemal Yilmaz', 'Combinatorial Interaction Testing of Tangled Configuration Options', 'Model', '', '2015 4th International Workshop on Combinatorial Testing', 'IWCT', '', '', '1--4', 'IEEE', '10.1109/ICSTW.2015.7107438', 'Combinatorial Testing', 'Traditional t-way covering arrays have been shown to be highly effective at revealing option-related failures caused by the interactions of t or fewer configuration options. We however, argue that their effectiveness suffers in the presence of complex interactions among configuration options, which from now on will be referred to as tangled options. To overcome this shortcoming, we propose an approach in which 1) the source code of the system under test is analyzed to figure out how configuration options interact with each other, 2) the analysis results are used to determine the combinations of option settings as well as the conditions under which these combinations must be tested, and 3) a “minimal” interaction test suite covering all the required combinations, is created. To evaluate the proposed approach, we conducted a set of feasibility studies on two highly configurable software systems. The results we have obtained from these studies support our basic hypothesis that traditional covering arrays suffer in the presence of tangled options and that this shortcoming can be overcome by turning CIT from a black-box approach to a gray-box approach.', NULL);
INSERT INTO `list` VALUES (481, '0000-00-00', 2015, 'inproceedings', 'Itai Segall, Rachel Tzoref-Brill, Aviad Zlotnick', 'Combining Minimization and Generation for Combinatorial Testing', 'Optimization', 'Reduction', '2015 4th International Workshop on Combinatorial Testing', 'IWCT', '', '', '1--9', 'IEEE', '10.1109/ICSTW.2015.7107434', 'Combinatorial Testing', 'Combinatorial Test Design (CTD) is an effective test planning technique that reveals faults resulting from feature interactions in a system. The standard application of CTD requires manual modeling of the test space, including a precise definition of restrictions between the test space parameters, and produces a test suite that corresponds to new test cases to be implemented from scratch. Interaction-based Test-Suite Minimization (ITSM) is a complementary approach to standard CTD, which reduces a given test suite without impacting its coverage of feature interactions. ITSM requires much less modeling effort, and does not require a definition of restrictions or generation of new test data. On the other hand, it does not improve the coverage obtained by the given test suite. In this work, we introduce Minimization Generation CTD (MG-CTD). MG-CTD is a combination of CTD with ITSM for addressing situations in which CTD is impractical, and ITSM is insufficient. In MG-CTD, one can define a subset of the parameters that can be freely assigned, as in CTD. The other parameter combinations must be selected from an existing set, as in ITSM. MG-CTD is suitable when for some parts of the test space it is easy to specify restrictions and generate new test data, while for others it is not. MG-CTD can be viewed as an enhancement of ITSM, and always achieves better interaction coverage than ITSM. We discuss the trade-offs between CTD, ITSM and MG-CTD, and present an efficient implementation which is based on binary decision diagrams. We then present some of the measures that one should take when implementing such an approach, in order to achieve the best possible coverage in the final result. Finally, we demonstrate MG-CTD on three real-life case studies.', NULL);
INSERT INTO `list` VALUES (482, '0000-00-00', 2015, 'inproceedings', 'Linbin Yu, Feng Duan, Yu Lei, Raghu N. Kacker, D. Richard Kuhn', 'Constraint Handling in Combinatorial Test Generation Using Forbidden Tuples', 'Generation', 'Constraint', '2015 4th International Workshop on Combinatorial Testing', 'IWCT', '', '', '1--9', 'IEEE', '10.1109/ICSTW.2015.7107441', 'Combinatorial Testing', 'Constraint handling is a challenging problem in combinatorial test generation. In general, there are two ways to handle constraints, i.e., constraint solving and forbidden tuples. In our earlier work, we proposed a constraint handling approach based on forbidden tuples for software product line systems consisting of only Boolean parameters. In this paper, we generalize this approach for general software systems that may consist of other types of parameter. The key idea of our approach is using the notion of minimum forbidden tuples to perform validity checks on both complete and partial tests. Furthermore, we propose an on-demand strategy that only generates minimum forbidden tuples for validity checks as they are encountered, instead of generating all of them up front. We implemented our generalized approach with and without the on-demand strategy in our combinatorial testing tool called ACTS. We performed experiments on 35 systems using ACTS and PICT. The results show that for these 35 systems, our generalized approach performed faster than PICT and the constraint solving-based approach in ACTS. For some large systems, the improvement on test generation time is up to two orders of magnitude.', NULL);
INSERT INTO `list` VALUES (483, '0000-00-00', 2015, 'inproceedings', 'George Sherwood', 'Embedded Functions in Combinatorial Test Designs', 'Model', 'Constraint', '2015 4th International Workshop on Combinatorial Testing', 'IWCT', '', '', '1--10', 'IEEE', '10.1109/ICSTW.2015.7107432', 'Combinatorial Testing', 'A feature for conforming to system constraints during combinatorial test case generation is proposed. The user interface and requirements for the feature are outlined. For constraint conformance, allowed test factor values are given by functions embedded in the test case generator. The functions are defined in a general-purpose programming language widely used among software engineers. The language, PHP, is chosen for its flexibility and prevalence. Examples of functions conforming to constraints are given. A second type of embedded function is proposed to automate the identification of expected equivalence class(es) for each test case. Equivalence class functions return the classes according to test case values. Examples of equivalence class functions are given also. Implementation of the feature is ongoing; goals include assessment of the feature\'s feasibility, usability and performance.', NULL);
INSERT INTO `list` VALUES (484, '0000-00-00', 2015, 'inproceedings', 'D. Richard Kuhn, Raghu N. Kacker, Yu Lei, Jose Torres-Jimenez', 'Equivalence class verification and oracle-free testing using two-layer covering arrays', 'Model', '', '2015 4th International Workshop on Combinatorial Testing', 'IWCT', '', '', '1--4', 'IEEE', '10.1109/ICSTW.2015.7107445', 'Combinatorial Testing', 'This short paper introduces a method for verifying equivalence classes for module/unit testing. This is achieved using a two-layer covering array, in which some or all values of a primary covering array represent equivalence classes. A second layer covering array of the equivalence class values is computed, and its values substituted for the equivalence class names in the primary array. It is shown that this method can detect certain classes of errors without a conventional test oracle, and an illustrative example is given.', NULL);
INSERT INTO `list` VALUES (485, '0000-00-00', 2015, 'inproceedings', 'Josip Bozic, Bernhard Garn, Dimitris E. Simos, Franz Wotawa', 'Evaluation of the IPO-Family Algorithms for Test Case Generation in Web Security Testing', 'Evaluation', '', '2015 4th International Workshop on Combinatorial Testing', 'IWCT', '', '', '1--10', 'IEEE', '10.1109/ICSTW.2015.7107436', 'Combinatorial Testing', 'Security testing of web applications remains a major problem of software engineering. In order to reveal vulnerabilities, testing approaches use different strategies for detection of certain kinds of inputs that might lead to a security breach. Such approaches depend on the corresponding test case generation technique that are executed against the system under test. In this work we examine how two of the most popular algorithms for combinatorial test case generation, namely the IPOG and IPOG-F algorithms, perform in web security testing. For generating comprehensive and sophisticated testing inputs we have used input parameter modelling which includes also constraints between the different parameter values. To handle the test execution, we make use of a recently introduced methodology which is based on model-based testing. Our evaluation indicates that both algorithms generate test inputs that succeed in revealing security leaks in web applications with IPOG-F giving overall slightly better results w.r.t. the test quality of the generated inputs. In addition, using constraints during the modelling of the attack grammars results in an increase on the number of test inputs that cause security breaches. Last but not least, a detailed analysis of our evaluation results confirms that combinatorial testing is an efficient test case generation method for web security testing as the security leaks are mainly due to the interaction of a few parameters. This statement is further supported by some combinatorial coverage measurement experiments on the successful test inputs.', NULL);
INSERT INTO `list` VALUES (486, '0000-00-00', 2015, 'inproceedings', 'Christopher Henard, Mike Papadakis, Yves Le Traon', 'Flattening or Not of the Combinatorial Interaction Testing Models?', 'Generation', 'Constraint', '2015 4th International Workshop on Combinatorial Testing', 'IWCT', '', '', '1--4', 'IEEE', '10.1109/ICSTW.2015.7107443', 'Combinatorial Testing', 'Combinatorial Interaction Testing (CIT) requires the use of models that represent the interactions between the features of the system under test. In most cases, CIT models involve Boolean or integer options and constraints among them. Thus, applying CIT requires solving the involved constraints, which can be directly performed using Satisfiability Modulo Theory (SMT) solvers. An alternative practice is to flatten the CIT model into a Boolean model and use Satisfiability (SAT) solvers. However, the flattening process artificially increases the size of the employed models, raising the question of whether it is profitable or not in the CIT context. This paper investigates this question and demonstrates that flattened models, despite being much larger, are processed faster with SAT solvers than the smaller original ones with SMT solvers. These results suggests that flattening is worthwhile in the CIT context.', NULL);
INSERT INTO `list` VALUES (487, '0000-00-00', 2015, 'inproceedings', 'Feng Duan, Linbin Yu, Yu Lei, Raghu N. Kacker, D. Richard Kuhn', 'Improving IPOG\'s Vertical Growth Based on a Graph Coloring Scheme', 'Generation', '', '2015 4th International Workshop on Combinatorial Testing', 'IWCT', '', '', '1--4', 'IEEE', '10.1109/ICSTW.2015.7107444', 'Combinatorial Testing', 'We show that the vertical growth phase of IPOG is optimal for t-way test generation when t = 2, but it is no longer optimal when t is greater than 2. We present an improvement that reduces the number of tests generated during vertical growth. The vertical growth problem is modeled as a classical NP-hard problem called “Minimum Vertex Coloring”. We adopted a greedy coloring algorithm to determine the order in which missing tuples are covered during vertical growth. We implemented a revised IPOG algorithm incorporating this improvement. The experimental results show that compared with the original IPOG algorithm, which uses an arbitrary order to cover missing tuples during vertical growth, the revised IPOG algorithm reduces the number of tests for many real-life systems.', NULL);
INSERT INTO `list` VALUES (488, '0000-00-00', 2015, 'inproceedings', 'Douglas Hillmer', 'Introducing Combinatorial Testing in the Organization a Report on a First Attempt', 'Application', '', '2015 4th International Workshop on Combinatorial Testing', 'IWCT', '', '', '1--9', 'IEEE', '10.1109/ICSTW.2015.7107433', 'Combinatorial Testing', 'Combinatorial testing (CT) is still relatively unknown in many organizations with large software development components. This paper provides a detailed report on what the author did to introduce CT in a large U.S. government organization, focusing on the first project where CT was applied. The final sections of the paper discuss lessons learned from this experience and contain some proposals for more effective ways to introduce CT in large organizations.', NULL);
INSERT INTO `list` VALUES (489, '0000-00-00', 2015, 'inproceedings', 'Sergiy Vilkomir, David Anderson', 'Relationship between Pair-wise and MC/DC Testing: Initial Experimental Results', 'Evaluation', '', '2015 4th International Workshop on Combinatorial Testing', 'IWCT', '', '', '1--4', 'IEEE', '10.1109/ICSTW.2015.7107439', 'Combinatorial Testing', 'While pair-wise testing has shown a high level of fault detection in many situations, it has not done so for testing logical expressions in software applications. The modified condition/decision coverage (MC/DC) approach was especially developed for testing logical expressions, but test generation according to this approach can be complicated and time-consuming. From a practical point of view, combining pair-wise and MC/DC testing would integrate the benefits of both approaches; however, this would require solving many research problems. As an initial step in this direction, our paper evaluates the level of MC/DC coverage for pair-wise test cases in different situations and compares this level to MC/DC coverage for random test cases. To confirm this, we conducted experimental testing of logical expressions of different sizes, complexities, and numbers of input variables. Our experimental results show that the pair-wise test cases had a higher level of MC/DC coverage compared to the random test cases, achieving more than 70% MC/DC coverage. This allows us to suggest pair-wise testing as a promising method to be used as the basis for MC/DC test generation.', NULL);
INSERT INTO `list` VALUES (490, '0000-00-00', 2015, 'inproceedings', 'Angelo Gargantini, Paolo Vavassori', 'Using Decision Trees to aid Algorithm Selection in Combinatorial Interaction Tests Generation', 'Generation', '', '2015 4th International Workshop on Combinatorial Testing', 'IWCT', '', '', '1--10', 'IEEE', '10.1109/ICSTW.2015.7107442', 'Combinatorial Testing', 'It has been widely observed that there is no a single best CIT generation algorithm; instead, different algorithms perform best in terms of test suite size and time, also depending on different combinatorial models. Rather than following the traditional approach of leaving the choice of the best generator for a given class of models and for given testing requirements to the user, we want to automate the algorithm selection process among a given set of techniques (called portfolio). The proposed approach takes as input a distribution of combinatorial models and their test suites generated using several tools, then, using data-mining techniques, it permits to predict the algorithm that performs better given the cost estimated to execute a single test and the model characteristics. As predictors, we decide to use decision trees because they have been one of the most widely used decision support tool for many years. Their attraction lies in the simplicity of the resulting model, where a decision tree (at least one that is not too large) is quite easy to view, understand, and, importantly, explain even if it may not always deliver the best performances. We demonstrate the effectiveness of our approach to automated algorithm selection in extensive experimental results on data sets including models commonly presented in literature.', NULL);
INSERT INTO `list` VALUES (491, '0000-00-00', 2015, 'inproceedings', 'Ziyuan Wang', 'Why Combinatorial Testing Works: Analyzing Minimal Failure-Causing Schemas in Logic Expressions', 'Evaluation', '', '2015 4th International Workshop on Combinatorial Testing', 'IWCT', '', '', '1--4', 'IEEE', '10.1109/ICSTW.2015.7107440', 'Combinatorial Testing', 'Combinatorial testing technique has been applied on Boolean-specification testing. Previous results indicated that it performed well to detect faults in Boolean expressions. This paper aims to investigate the reason why combinatorial testing works in Boolean-specification testing, which was always omitted previously. We design experiment to get the minimal failure-causing schemas for 19129 faults, which could be classified into 10 fault classes, of 20 Boolean expressions that extracted from TCAS system. By analyzing the number and strengths of minimal failure-causing schemas for each fault, the low bound of fault-detecting probability of τ-way combinatorial test suite for Boolean-specification testing are calculated. Computational results could explain the effectiveness of combinatorial testing technique in Boolean-specification testing.', NULL);
INSERT INTO `list` VALUES (493, '0000-00-00', 2015, 'inproceedings', 'Itai Segall, Rachel Tzoref-Brill', 'Feedback-driven combinatorial test design and execution', 'Application', 'Adaptive CT', '2015 ACM International Systems and Storage Conference', 'other', '', '', '12:1--12:6', 'ACM', '10.1145/2757667.2757677', 'Combinatorial Testing', 'This work introduces a novel approach for online design and execution of load tests on Cloud applications. Our approach utilizes a Combinatorial Test Design (CTD) engine in order to exercise combinations of levels of resource utilization on the target system\'s subcomponents. In order to cope with the unpredictability and uncontrollability of Cloud environments, and to align with agile and DevOps paradigms, it designs and executes tests in an iterative online fashion. During test execution, monitoring information is collected from the Cloud, and leveraged for driving and adjusting the subsequent test scenarios. In this work we introduce the overall approach and the algorithms behind it, and demonstrate it on an example setting consisting of three sub-components comprising a typical installation of a web blogging application.', NULL);
INSERT INTO `list` VALUES (494, '0000-00-00', 2015, 'article', 'Abraham N. Aldaco, Charles J. Colbourn, Violet R. Syrotiuk', 'Locating Arrays: A New Experimental Design for Screening Complex Engineered Systems', 'Generation', '', '2015 ACM SIGOPS Operating Systems Review - Special Issue on Repeatability and Sharing of Experimental Artifacts', 'SIGSOFT ', '49', '1', '31-40', 'ACM', '10.1145/2723872.2723878', 'Combinatorial Testing', 'The purpose of a screening experiment is to identify significant factors and interactions on a response for a system. Engineered systems are complex in part due to their size. To apply traditional experimental designs for screening in complex engineered systems requires either restricting the factors considered, which automatically restricts the interactions to those in the set, or restricting interest to main effects, which fails to consider any possible interactions. To address this problem we propose a locating array (LA) as a screening design. Locating arrays exhibit logarithmic growth in the number of factors because their focus is on identification rather than on measurement. This makes practical the consideration of an order of magnitude more factors in experimentation than traditional screening designs. We present preliminary results applying an LA for screening the response of TCP throughput in a simulation model of a mobile wireless network. The full-factorial design for this system is infeasible (over 1043 design points!) yet an LA has only 421 design points. We validate the significance of the identified factors and interactions independently using the statistical software JMP. Screening using locating arrays is viable and yields useful models.', NULL);
INSERT INTO `list` VALUES (495, '0000-00-00', 2015, 'article', 'Abhinandan H. Patil, Neena Goveas, Krishnan Rangarajan', 'Re-architecture of Contiki and Cooja Regression Test Suites using Combinatorial Testing Approach', 'Application', '', '2015 ACM SIGSOFT Software Engineering Notes', 'SIGSOFT ', '40', '2', '1--3', 'ACM', '10.1145/2735399.2735413', 'Combinatorial Testing', 'In this paper, we describe how combinatorial testing can be applied to re-architecture Contiki and Cooja regression test suites. Contiki is the popular and widely accepted internet of things operating system. Combinatorial testing was pioneered by National Institute of Standards and Technology. National Institute of Standards and Technology offers a set of tools to public. One such tool is Automated Combinatorial Testing for Software. We describe how Automated Combinatorial Testing for Software can be used to generate a complete test suite for Contiki and Cooja. Coverage of base test suite is gathered using CodeCover, a code coverage tool for Java. The low percentage of coverage in Cooja indicated the need for a redesign of test suite. Once the base regression test suite is modified using Combinatorial Testing approach, it can be the new base regression test suite.', NULL);
INSERT INTO `list` VALUES (497, '0000-00-00', 2015, 'incollection', 'Jose Torres-Jimenez, Idelfonso Izquierdo-Marquez, Aldo Gonzalez-Gomez, Himer Avila-George', 'A Branch & Bound Algorithm to Derive a Direct Construction for Binary Covering Arrays', 'Generation', '', '2015 Advances in Artificial Intelligence and Soft Computing', 'Book', '9413', '', '158-177', 'Springer International Publishing', '10.1007/978-3-319-27060-9_13', 'Combinatorial Testing', 'Covering arrays are used in testing deterministic systems where failures occur as a result of interactions among subsystems. The goal is to reveal if any interaction induces a failure in the system. Application areas include software and hardware testing. A binary covering array CA(N;t,k,2) is an N×k\r\n array over the alphabet {0,1}\r\n with the property that each set of t columns contains all the 2t\r\n possible t-tuples of 0’s and 1’s at least once. In this paper we propose a direct method to construct binary covering arrays using an specific interpretation of binomial coefficients: a binomial coefficient with parameters k and r will be interpreted as the set of all the k-tuples from {0,1}\r\n having r ones and k−r\r\n zeroes. For given values of k and t, the direct method uses an explicit formula in terms of both k and t to provide a covering array CA(N;t,k,2) expressed as the juxtaposition of a set of binomial coefficients; this covering array will be of the minimum size that can be obtained by any juxtaposition of binomial coefficients. In order to derive the formula, a Branch & Bound (B&B) algorithm was first developed; the B&B algorithm provided solutions for small values of k and t that allowed the identification of the general pattern of the solutions. Like others previously reported methods, our direct method finds optimal covering arrays for k=t+1\r\n and k=t+2\r\n; however, the major achievement is that nine upper bounds were significantly improved by our direct method, plus the fact that the method is able to set an infinite number of new upper bounds for t≥7\r\n given that little work has been done to compute binary covering arrays for general values of k and t.', NULL);
INSERT INTO `list` VALUES (498, '0000-00-00', 2015, 'incollection', 'D. Richard Kuhn, Renée C. Bryce, Feng Duan, Laleh Sh. Ghandehari, Yu Lei, Raghu N. Kacker', 'Combinatorial Testing: Theory and Practice', 'Other', 'Survey', '2015 Advances in Computers', 'Adv. Comput.', '99', '', '1--66', 'Elsevier', '10.1016/bs.adcom.2015.05.003', 'Combinatorial Testing', 'Combinatorial testing has rapidly gained favor among software testers in the past decade as improved algorithms have become available and practical success has been demonstrated. This chapter reviews the theory and application of this method, focusing particularly on research since 2010, with a brief background providing the rationale and development of combinatorial methods for software testing. Significant advances have occurred in algorithm performance, and the critical area of constraint representation and processing. In addition to these foundational topics, we take a look at advances in specialized areas including test suite prioritization, sequence testing, fault localization, the relationship between combinatorial testing and structural coverage, and approaches to very large testing problems.', NULL);
INSERT INTO `list` VALUES (499, '0000-00-00', 2015, 'incollection', 'Andrea Calvagna, Emiliano Tramontana', 'A framework for incremental covering arrays construction', 'Generation', 'Adaptive CT', '2015 Advances in Intelligent Systems and Computing', 'Book', '349', '', '283-294', '', '10.1007/978-3-319-18473-9_28', 'Combinatorial Testing', 'In this paper we first show that the combinatorial task of enumerating t-wise tuples out of a given set of elements is the recursive iteration of the simpler task of computing pairs out of the same set of elements. We then show how to apply this result to the design of a general framework for incremental CIT test suite construction, that is, producing at each iteration an additional set of tuples required to increase the coverage interaction degree just by one. As a last contribution, we show that in the presented construction framework, the covering array minimization problem and its inherent complexity can be encapsulated inside a delegate task of merging two given smaller covering array, while minimizing rows redundancy.', NULL);
INSERT INTO `list` VALUES (500, '0000-00-00', 2015, 'inproceedings', 'Andrea Calvagna, Andrea Fornaia, Emiliano Tramontana', 'Random versus combinatorial effectiveness in software conformance testing: a case study', 'Evaluation', '', '2015 Annual ACM Symposium on Applied Computing', 'SAC', '', '', '1797-1802', 'ACM', '10.1145/2695664.2695905', 'Combinatorial Testing', 'Combinatorial interaction testing is widely rewarded as a powerful and cost-effective tool for generic debugging of large software implementations. However, its efficacy when applied to the specific task of testing a software for conformance to its specification has not yet been assessed, to the best of our knowledge. For this type of task, we show that the much easier and commonly used random testing approach is a less convenient choice with respect to applying a combinatorial based test suite of comparable size. We also performed a wider set of experiments and found that even much greater random testing efforts won\'t be able to trigger a comparably wide set of faults, with respect to the combinatorial based testing. The presented results are based on the case study of applying conformance testing to the verifier component of the Java virtual machine. The framework for the combinatorial driven generation of the conformance test suite is also described. In the framework, the test cases are generated by model checking the considered specification, and using a combinatorial coverage criteria targeted to the specification constraints. Results obtained from both types of test suites application are presented and discussed, with their comparison showing the better efficacy of the combinatorial one, and empirically validating the underlying approach.', NULL);
INSERT INTO `list` VALUES (501, '0000-00-00', 2015, 'article', 'Marcos Palaciosa, Jose Garcia-Fanjula, Javier Tuyaa, George Spanoudakisb', 'Automatic test case generation for WS-Agreements using combinatorial testing', 'Generation', '', '2015 Computer Standards & Interfaces', 'other', '38', '', '84--100', 'Elsevier', '10.1016/j.csi.2014.10.003', 'Combinatorial Testing', 'In the scope of the applications developed under the service-based paradigm, Service Level Agreements (SLAs) are a standard mechanism used to flexibly specify the Quality of Service (QoS) that must be delivered. These agreements contain the conditions negotiated between the service provider and consumers as well as the potential penalties derived from the violation of such conditions. In this context, it is important to assure that the service based application (SBA) behaves as expected in order to avoid potential consequences like penalties or dissatisfaction between the stakeholders that have negotiated and signed the SLA. In this article we address the testing of SLAs specified using the WS-Agreement standard by means of applying testing techniques such as the Classification Tree Method and Combinatorial Testing to generate test cases. From the content of the individual terms of the SLA, we identify situations that need to be tested. We also obtain a set of constraints based on the SLA specification and the behavior of the SBA in order to guarantee the testability of the test cases. Furthermore, we define three different coverage strategies with the aim at grading the intensity of the tests. Finally, we have developed a tool named SLACT (SLA Combinatorial Testing) in order to automate the process and we have applied the whole approach to an eHealth case study.', NULL);
INSERT INTO `list` VALUES (506, '0000-00-00', 2015, 'inproceedings', 'Sagar Sen, Stefano Di Alesio, Dusica Marijan, Arnab Sarkar', 'Evaluating Reconfiguration Impact in Self-Adaptive Systems - An Approach Based on Combinatorial Interaction Testing', 'Generation', 'Constraint, Software Product Line', '2015 Euromicro Conference on Software Engineering and Advanced Applications', 'other', '', '', '250-254', '', '10.1109/SEAA.2015.72', 'Combinatorial Testing', 'Self-adaptive software adapts its behavior to the operational context via automatic run-time reconfiguration of software components. Particular reconfigurations may negatively affect the system Quality of Service (QoS), and therefore their impact over the system performance needs to be thoroughly evaluated. In this paper, we present an approach, based on Combinatorial Interaction Testing (CIT), that generates a sequence of configurations aimed at evaluating the extent to which reconfigurations affect the system QoS. Specifically, we transform a Classification Tree Models (CTM) of the configurations domain to a Constraint Satisfaction Problem (CSP) in ALLOY, whose solution is a sequence of reconfigurations achieving T-wise coverage between system features, and R-wise coverage between configurations in the sequence. The resolution of the CSP is performed by an incremental growth algorithm that divides the generation of the sequence into sub-problems, and merges the results into a final set of test configurations. Preliminary validation in a self adaptive vision system shows that our methodology effectively identifies critical reconfigurations exhibiting a high variation in QoS. This result encourages the use of CIT as a strategy to evaluate the performance of self-adaptive systems.', NULL);
INSERT INTO `list` VALUES (507, '0000-00-00', 2015, 'article', 'Thair Mahmoud, Bestoun S. Ahmed', 'An efficient strategy for covering array construction with fuzzy logic-based adaptive swarm optimization for software testing use', 'Generation', 'Search Based', '2015 Expert Systems with Applications', 'other', '42', '12', '8753–8765', '', '10.1016/j.eswa.2015.07.029', 'Combinatorial Testing', 'Recent research activities have demonstrated the effective application of combinatorial optimization in different areas, especially in software testing. Covering array (CA) has been introduced as a representation of the combinations in one complete set. CAλ(N; t, k, v) is an N × k array in which each t-tuple for an N × t sub array occurs at least λ times, where t is the combination strength, k is the number of components (factors), and v is the number of symbols for each component (levels). Generating an optimized covering array for a specific number of k and v is difficult because the problem is a non-deterministic polynomial-time hard computational one. To address this issue, many relevant strategies have been developed, including stochastic population-based algorithms. This paper presents a new and effective approach for constructing efficient covering arrays through fuzzy-based, adaptive particle swarm optimization (PSO). With this approach, efficient covering arrays have been constructed and the performance of PSO has been improved for this type of application. To measure the effectiveness of the technique, an empirical study is conducted on a software system. The technique proves its effectiveness through the conducted case study.', NULL);
INSERT INTO `list` VALUES (509, '0000-00-00', 2015, 'inproceedings', 'Anna Zamansky, Eitan Farchi', 'Helping the Tester Get it Right: Towards Supporting Agile Combinatorial Test Design', 'Model', '', '2015 Human-Oriented Formal Methods Workshop', 'other', '', '', '1--7', '', 'https://doi.org/10.1007/978-3-662-49224-6_4', 'Combinatorial Testing', 'Combinatorial test design (CTD) is an effective test planning technique that reveals faulty feature interaction in a given system. CTD takes a systematic approach to formally model the system to be tested, and propose test cases ensuring coverage of given conditions or interactions between parameters. In this position paper we propose a framework for supporting agile CTD, a human-centered methodology, which takes into account the human tester’s possible mistakes and supports revision and refinement. In this approach a combinatorial model of the system and test plans are constructed in an incremental and iterative way, providing the tester with the ability to refine and validate the constructions. We propose a formal framework which can be used as a theoretical foundation for the development of agile CTD support tools, and describe a use case of an envisioned tool.', NULL);
INSERT INTO `list` VALUES (510, '0000-00-00', 2015, 'article', 'Jon Hagar, Thomas L. Wissink, D. Richard Kuhn, Raghu N. Kacker', 'Introducing Combinatorial Testing in a Large Organization', 'Application', '', '2015 IEEE Computer', 'Computer', '48', '4', '64-72', 'IEEE', '10.1109/MC.2015.114', 'Combinatorial Testing', 'A two-year study of eight pilot projects to introduce combinatorial testing in a large aerospace corporation found that the new methods were practical, significantly lowered development costs, and improved test coverage by 20 to 50 percent.', NULL);
INSERT INTO `list` VALUES (511, '0000-00-00', 2015, 'article', 'Huayao Wu, Changhai Nie, Fei-Ching Kuo, Hareton Leung, Charles J. Colbourn', 'A Discrete Particle Swarm Optimization for Covering Array Generation', 'Generation', 'Search Based', '2015 IEEE Transactions on Evolutionary Computation', 'TEVC', '19', '4', '575-591', 'IEEE', '10.1109/TEVC.2014.2362532', 'Combinatorial Testing', 'Software behavior depends on many factors. Combinatorial testing (CT) aims to generate small sets of test cases to uncover defects caused by those factors and their interactions. Covering array generation, a discrete optimization problem, is the most popular research area in the field of CT. Particle swarm optimization (PSO), an evolutionary search-based heuristic technique, has succeeded in generating covering arrays that are competitive in size. However, current PSO methods for covering array generation simply round the particle\'s position to an integer to handle the discrete search space. Moreover, no guidelines are available to effectively set PSOs parameters for this problem. In this paper, we extend the set-based PSO, an existing discrete PSO (DPSO) method, to covering array generation. Two auxiliary strategies (particle reinitialization and additional evaluation of gbest) are proposed to improve performance, and thus a novel DPSO for covering array generation is developed. Guidelines for parameter settings both for conventional PSO (CPSO) and for DPSO are developed systematically here. Discrete extensions of four existing PSO variants are developed, in order to further investigate the effectiveness of DPSO for covering array generation. Experiments show that CPSO can produce better results using the guidelines for parameter settings, and that DPSO can generate smaller covering arrays than CPSO and other existing evolutionary algorithms. DPSO is a promising improvement on PSO for covering array generation.', NULL);
INSERT INTO `list` VALUES (512, '0000-00-00', 2015, 'article', 'Justyna Petke, Myra B. Cohen, Mark Harman, Shin Yoo', 'Practical Combinatorial Interaction Testing: Empirical Findings on Efficiency and Early Fault Detection', 'Evaluation', '', '2015 IEEE Transactions on Software Engineering', 'TSE', '41', '9', '901-924', 'IEEE', '10.1109/TSE.2015.2421279', 'Combinatorial Testing', 'Combinatorial interaction testing (CIT) is important because it tests the interactions between the many features and parameters that make up the configuration space of software systems. Simulated Annealing (SA) and Greedy Algorithms have been widely used to find CIT test suites. From the literature, there is a widely-held belief that SA is slower, but produces more effective tests suites than Greedy and that SA cannot scale to higher strength coverage. We evaluated both algorithms on seven real-world subjects for the well-studied two-way up to the rarely-studied six-way interaction strengths. Our findings present evidence to challenge this current orthodoxy: real-world constraints allow SA to achieve higher strengths. Furthermore, there was no evidence that Greedy was less effective (in terms of time to fault revelation) compared to SA; the results for the greedy algorithm are actually slightly superior. However, the results are critically dependent on the approach adopted to constraint handling. Moreover, we have also evaluated a genetic algorithm for constrained CIT test suite generation. This is the first time strengths higher than 3 and constraint handling have been used to evaluate GA. Our results show that GA is competitive only for pairwise testing for subjects with a small number of constraints.', NULL);
INSERT INTO `list` VALUES (513, '0000-00-00', 2015, 'article', 'Bestoun S. Ahmed, Taib Sh. Abdulsamad, Moayad Y. Potrus', 'Achievement of minimized combinatorial test suite for configuration-aware software functional testing using the Cuckoo Search algorithm', 'Generation', 'Search Based', '2015 Information and Software Technology', 'IST', '66', '', '13-29', 'Elsevier', '10.1016/j.infsof.2015.05.005', 'Combinatorial Testing', 'Context\r\nSoftware has become an innovative solution nowadays for many applications and methods in science and engineering. Ensuring the quality and correctness of software is challenging because each program has different configurations and input domains. To ensure the quality of software, all possible configurations and input combinations need to be evaluated against their expected outputs. However, this exhaustive test is impractical because of time and resource constraints due to the large domain of input and configurations. Thus, different sampling techniques have been used to sample these input domains and configurations.\r\n\r\nObjective\r\nCombinatorial testing can be used to effectively detect faults in software-under-test. This technique uses combinatorial optimization concepts to systematically minimize the number of test cases by considering the combinations of inputs. This paper proposes a new strategy to generate combinatorial test suite by using Cuckoo Search concepts.\r\n\r\nMethod\r\nCuckoo Search is used in the design and implementation of a strategy to construct optimized combinatorial sets. The strategy consists of different algorithms for construction. These algorithms are combined to serve the Cuckoo Search.\r\n\r\nResults\r\nThe efficiency and performance of the new technique were proven through different experiment sets. The effectiveness of the strategy is assessed by applying the generated test suites on a real-world case study for the purpose of functional testing.\r\n\r\nConclusion\r\nResults show that the generated test suites can detect faults effectively. In addition, the strategy also opens a new direction for the application of Cuckoo Search in the context of software engineering.', NULL);
INSERT INTO `list` VALUES (514, '0000-00-00', 2015, 'article', 'Changhai Nie, Huayao Wu, Xintao Niu, Fei-Ching Kuo, Hareton Leung, Charles J. Colbourn', 'Combinatorial testing, random testing, and adaptive random testing for detecting interaction triggered failures', 'Evaluation', '', '2015 Information and Software Technology', 'IST', '62', '', '198-213', 'Elsevier', '10.1016/j.infsof.2015.02.008', 'Combinatorial Testing', 'Context: Software behavior depends on many factors, and some failures occur only when certain factors interact. This is known as an interaction triggered failure, and the corresponding selection of factor values can be modeled as a Minimal Failure-causing Schema (MFS). (An MFS involving m factors is an m-MFS.) Combinatorial Testing (CT) has been developed to exercise (\"hit\") all MFS with few tests. Adaptive Random Resting (ART) endeavors to make tests as different as possible, ensuring that testing of MFS is not unnecessarily repeated. Random Testing (RT) chooses tests at random without regard to the MFS already treated. CT might be expected to improve on RT for finding interaction triggered faults, and yet some studies report no significant difference. CT can also be expected to be better than ART, and yet other studies report that ART can be much better than RT. In light of these, the relative merits of CT, ART, and RT for finding interaction triggered faults are unclear. Objective: To investigate the relationships among CT, ART, and RT, we conduct the first complete and systematic comparison for the purpose of hitting MFS. Method: A systematic review of six aspects of CT, RT and ART is conducted first. Then two kinds of experiments are used to compare them under four metrics. Results: ART improves upon RT, but t-way CT is better than both. In hitting t\'-MFS the advantage is typically in the range from 10% to 30% when t = t\', but becomes much smaller when t\' < t, and there may be no advantage when t\' > t. The latter case may explain the studies reporting no significant difference between RT and CT. Conclusion: RT is easily implemented. However, depending on its implementation, ART can improve upon RT. CT does as well as ART whether or nott\' = t, but provides a valuable improvement in the cases when t\' = t.', NULL);
INSERT INTO `list` VALUES (515, '0000-00-00', 2015, 'article', 'Loreto Gonzalez-Hernandez', 'New bounds for mixed covering arrays in t-way testing with uniform strength', 'Generation', 'Search Based', '2015 Information and Software Technology', 'IST', '59', '', '17-32', 'Elsevier', '10.1016/j.infsof.2014.10.009', 'Combinatorial Testing', 'Context\r\nCombinatorial testing (CT) can increase the effectiveness of software testing by ensuring that all t-way input combinations are covered in a test suite. When software components have different input cardinalities, CT uses a mixed covering array (MCA) to represent the test suite. This study proposes a new methodology for constructing MCAs of \r\n by using Mixed-Tabu Search (MiTS) as the construction strategy.\r\n\r\nObjective\r\nThe objective of this study is to significantly improve the best bounds of MCAs of \r\n with uniform strength.\r\n\r\nMethod\r\nThe proposed solution incorporates a new procedure for efficient parameter tuning where statistical testing is used to identify the setting values that significantly affect the performance of MiTS. For validation purposes, we used a robust benchmark that comprised a set of 35 instances of real cases and a set of 95 academic instances, which represented the best bounds reported previously.\r\n\r\nResult\r\nThe experimental results showed that our MiTS-based methodology improved 93 bounds and matched 36 of them. The Wilcoxon signed-rank test demonstrated that our MiTS-based methodology significantly enhanced the best bounds of MCAs compared with those reported previously with 95% confidence.\r\n\r\nConclusion\r\nMCAs for t-way testing with a good solution quality (in terms of test size), which involves artificial intelligence-based strategies, may be obtained by following a well-established methodology during the construction process.', NULL);
INSERT INTO `list` VALUES (516, '0000-00-00', 2015, 'article', 'Javier Ferrer, Peter M. Kruse, Francisco Chicano, Enrique Alba', 'Search based algorithms for test sequence generation in functional testing', 'Generation', 'Search Based, Sequence CA', '2015 Information and Software Technology', 'other', '58', '', '419-432', '', '10.1016/j.infsof.2014.07.014', 'Combinatorial Testing', 'Context\r\nThe generation of dynamic test sequences from a formal specification, complementing traditional testing methods in order to find errors in the source code.\r\n\r\nObjective\r\nIn this paper we extend one specific combinatorial test approach, the Classification Tree Method (CTM), with transition information to generate test sequences. Although we use CTM, this extension is also possible for any combinatorial testing method.\r\n\r\nMethod\r\nThe generation of minimal test sequences that fulfill the demanded coverage criteria is an NP-hard problem. Therefore, search-based approaches are required to find such (near) optimal test sequences.\r\n\r\nResults\r\nThe experimental analysis compares the search-based technique with a greedy algorithm on a set of 12 hierarchical concurrent models of programs extracted from the literature. Our proposed search-based approaches (GTSG and ACOts) are able to generate test sequences by finding the shortest valid path to achieve full class (state) and transition coverage.\r\n\r\nConclusion\r\nThe extended classification tree is useful for generating of test sequences. Moreover, the experimental analysis reveals that our search-based approaches are better than the greedy deterministic approach, especially in the most complex instances. All presented algorithms are actually integrated into a professional tool for functional testing.', NULL);
INSERT INTO `list` VALUES (517, '0000-00-00', 2015, 'article', 'D. Richard Kuhn, Raghu N. Kacker, Yu Lei', 'Measuring and specifying combinatorial coverage of test input configurations', 'Evaluation', '', '2015 Innovations in Systems and Software Engineering', 'other', '', '', '1--13', '', '10.1007/s11334-015-0266-2', 'Combinatorial Testing', 'A key issue in testing is how many tests are needed for a required level of coverage or fault detection. Estimates are often based on error rates in initial testing, or on code coverage. For example, tests may be run until a desired level of statement or branch coverage is achieved. Combinatorial methods present an opportunity for a different approach to estimating required test set size, using characteristics of the test set. This paper describes methods for estimating the coverage of, and ability to detect, t-way interaction faults of a test set based on a covering array. We also develop a connection between (static) combinatorial coverage and (dynamic) code coverage, such that if a specific condition is satisfied, 100 % branch coverage is assured. Using these results, we propose practical recommendations for using combinatorial coverage in specifying test requirements, and for improving estimates of the fault detection capacity of a test set.', NULL);
INSERT INTO `list` VALUES (519, '0000-00-00', 2015, 'inproceedings', 'Eun-Hye Choi, Takashi Kitamura, Cyrille Artho, Akihisa Yamada, Yutaka Oiwa', 'Priority Integration for Weighted Combinatorial Testing', 'Optimization', 'Priority', '2015 International Computers, Software & Applications Conference', 'COMPSAC', '', '', '242-247', 'IEEE', '10.1109/COMPSAC.2015.113', 'Combinatorial Testing', 'Priorities (weights) for parameter values can improve the effectiveness of combinatorial testing. Previous approaches have employed weights to derive high-priority test cases either earlier or more frequently. Our approach integrates these order-focused and frequency-focused prioritizations. We show that our priority integration realizes a small test suite providing high-priority test cases early and frequently in a good balance. We also propose two algorithms that apply our priority integration to existing combinatorial test generation algorithms. Experimental results using numerous test models show that our approach improves the existing approaches w.r.t. Order-focused and frequency-focused metrics, while overheads in the size and generation time of test suites are small.', NULL);
INSERT INTO `list` VALUES (520, '0000-00-00', 2015, 'inproceedings', 'Sangeeta Sabharwal, Manuj Aggarwal ', 'Variable strength interaction test set generation using Multi Objective Genetic Algorithms', 'Generation', 'Search Based', '2015 International Conference on Advances in Computing, Communications and Informatics', 'ICCCI', '', '', '2049-2053', '', '10.1109/ICACCI.2015.7275918', 'Combinatorial Testing', 'Combinatorial testing aims at identifying faults that are caused due to interactions of a small number of input parameters. It provides a technique to select a subset of exhaustive test cases covering all the t-way interactions without much loss of the fault detection capability. The test set generated is for a fixed value of t. In this paper, an approach is proposed to generate test set for a system where some variables have higher interaction strength among them as compared to that of the system. Variable Strength Covering Arrays are used for testing such systems. We propose to generate Variable Strength Covering Arrays using Multi objective optimization (Multi Objective Genetic Algorithms). We attempt to reduce the test set size while covering all the base level interactions of the system and higher strength interactions of its components. Experimental results indicate that the proposed approach generates results comparable to or better in some cases as compared to that of existing approaches.', NULL);
INSERT INTO `list` VALUES (521, '0000-00-00', 2015, 'inproceedings', 'Jinkun Lin, Chuan Luo, Shaowei Cai, Kaile Su, Dan Hao, Lu Zhang', 'TCA: An Efficient Two-Mode Meta-Heuristic Algorithm for Combinatorial Test Generation', 'Generation', 'Search Based', '2015 International Conference on Automated Software Engineering', 'ASE', '', '', '1--12', 'IEEE', '', 'Combinatorial Testing', 'Covering arrays (CAs) are often used as test suites for combinatorial interaction testing to discover interaction faults of real-world systems. Most real-world systems involve constraints, so improving algorithms for covering array generation (CAG) with constraints is beneficial. Two popular methods for constrained CAG are greedy construction and meta-heuristic search. Recently, a meta-heuristic framework called two-mode local search has shown great success in solving classic NPhard problems. We are interested whether this method is also powerful in solving the constrained CAG problem. This work proposes a two-mode meta-heuristic framework for constrained CAG efficiently and presents a new meta-heuristic algorithm called TCA. Experiments show that TCA significantly outperforms state-of-the-art solvers on 3-way constrained CAG. Further experiments demonstrate that TCA also performs much better than its competitors on 2-way constrained CAG.', NULL);
INSERT INTO `list` VALUES (523, '0000-00-00', 2015, 'inproceedings', 'Abdul Rauf EM, E.Madhusudhana Reddy', 'Combinatorial testing: A case study approach for software evaluation', 'Application', '', '2015 International Conference on Electrical, Computer and Communication Technologies', 'ICECCT', '', '', '1--5', '', '10.1109/ICECCT.2015.7226066', 'Combinatorial Testing', 'Combinatorial explosion of test cases is one of the major challenges in software testing area. Solutions for efficiently generating input combinations to represent software interaction and generation of test suites using efficient model checking tools will address this issue to an extent. Empirical observation in software industry states that fault is likely to be triggered by few interacting variables. This paper discusses about combinatorial test design approaches and a case study is conducted on platform dump component\' using Combinatorial test design (CTD) tool.', NULL);
INSERT INTO `list` VALUES (524, '0000-00-00', 2015, 'inproceedings', 'Rongzhi Qi, Zhijian Wang, Ping Ping, Shuiyan Li', 'A hybrid optimization algorithm for pairwise test suite generation', 'Generation', 'Search Based', '2015 International Conference on Information and Automation', 'ICIA', '', '', '3062-3067', '', '10.1109/ICInfA.2015.7279814', 'Combinatorial Testing', 'Pairwise testing is an effective combinatorial test generation technique that can generate relative small test suite to cover all pairs of parameter values at least once. Genetic algorithm has been used for pairwise test suite generation by some researchers. In order to improve the performance of genetic algorithm, this paper proposes a hybrid optimization algorithm by augmenting genetic algorithm with two-stage hill climbing. The first stage is to improve all the individuals after genetic operations. The second stage is to improve the best solution of the current generation at the end of each generation. A series of experiments are conducted to evaluate the proposed algorithm. Experiment results show that the proposed algorithm is very competitive with respect to other approaches reported in the literature.', NULL);
INSERT INTO `list` VALUES (525, '0000-00-00', 2015, 'inproceedings', 'Valerio Panzica La Manna, Itai Segall, Joel Greenyer', 'Synthesizing tests for combinatorial coverage of modal scenario specifications', 'Application', '', '2015 International Conference on Model Driven Engineering Languages and Systems', 'MoDELS', '', '', '126-135', '', '10.1109/MODELS.2015.7338243', 'Combinatorial Testing', 'Software-intensive systems often consist of many components that interact to fulfill complex functionality. Testing these systems is vital, preferably by a minimal set of tests that covers all relevant cases. The behavior is typically specified by scenarios that describe what the system may, must, or must not do. When designing tests, as in the design of the system itself, the challenge is to consider interactions of scenarios. When doing this manually, critical interactions are easily overlooked. Inspired by Combinatorial Test Design, which exploits that bugs are typically found by regarding the interaction of a small set of parameters, we propose a new test coverage criterion based on scenario interactions. Furthermore, we present a novel technique for automatically synthesizing from Modal Sequence Diagram specifications a minimal set of tests that ensures a maximal coverage of possible t-wise scenario interactions. The technique is evaluated on an example specification from an industrial project.', NULL);
INSERT INTO `list` VALUES (526, '0000-00-00', 2015, 'inproceedings', 'Yue Jia, Myra B. Cohen, Mark Harman, Justyna Petke', 'Learning Combinatorial Interaction Test Generation Strategies using Hyperheuristic Search', 'Generation', 'Search Based', '2015 International Conference on Software Engineering', 'ICSE', '', '', '540-550', 'IEEE', '10.1109/ICSE.2015.71', 'Combinatorial Testing', 'The surge of search based software engineering research has been hampered by the need to develop customized search algorithms for different classes of the same problem. For instance, two decades of bespoke Combinatorial Interaction Testing (CIT) algorithm development, our exemplar problem, has left software engineers with a bewildering choice of CIT techniques, each specialized for a particular task. This paper proposes the use of a single hyperheuristic algorithm that learns search strategies across a broad range of problem instances, providing a single generalist approach. We have developed a Hyperheuristic algorithm for CIT, and report experiments that show that our algorithm competes with known best solutions across constrained and unconstrained problems: For all 26 real-world subjects, it equals or outperforms the best result previously reported in the literature. We also present evidence that our algorithm\'s strong generic performance results from its unsupervised learning. Hyperheuristic search is thus a promising way to relocate CIT design intelligence from human to machine.', NULL);
INSERT INTO `list` VALUES (527, '0000-00-00', 2015, 'inproceedings', 'Josip Bozic, Bernhard Garn, Ioannis Kapsalis, Dimitris E. Simos, Severin Winkler, Franz Wotawa', 'Attack Pattern-Based Combinatorial Testing with Constraints for Web Security Testing', 'Application', 'Constraint', '2015 International Conference on Software Quality, Reliability and Security', 'QRS', '', '', '207-212', 'IEEE', '10.1109/QRS.2015.38', 'Combinatorial Testing', 'Security testing of web applications remains a major problem of software engineering. In order to reveal vulnerabilities, manual and automatic testing approaches use different strategies for detection of certain kinds of inputs that might lead to a security breach. In this paper we compared a state-of-the-art manual testing tool with an automated one that is based on model-based testing. The first tool requires user input from the tester whereas the second one reduces the necessary amount of manual manipulation. Both approaches depend on the corresponding test case generation technique and its produced inputs are executed against the system under test (SUT). For this case we enhance a novel technique, which combines a combinatorial testing technique for input generation and a model-based technique for test execution. In this work the input parameter modelling is improved by adding constraints to generate more comprehensive and sophisticated testing inputs. The evaluated results indicate that both techniques succeed in detecting security leaks in web applications with different results, depending on the background logic of the testing approach. Last but not least, we claim that attack pattern-based combinatorial testing with constraints can be an alternative method for web application security testing, especially when we compare our method to other test generation techniques like fuzz testing.', NULL);
INSERT INTO `list` VALUES (528, '0000-00-00', 2015, 'inproceedings', 'Takashi Kitamura, Akihisa Yamada, Goro Hatayama, Cyrille Artho, Eun-Hye Choi, Ngoc Thi Bich Do, Yutaka Oiwa, Shinya Sakuragi', 'Combinatorial Testing for Tree-Structured Test Models with Constraints', 'Application', 'Software Product Line', '2015 International Conference on Software Quality, Reliability and Security', 'QRS', '', '', '141-150', 'IEEE', '10.1109/QRS.2015.29', 'Combinatorial Testing', 'In this paper, we develop a combinatorial testing technique for tree-structured test models. First, we generalize our previous test models for combinatorial testing based on and-xor trees with constraints limited to a syntactic subset of propositional logic, to allow for constraints in full propositional logic. We prove that the generalized test models are strictly more expressive than the limited ones. Then we develop an algorithm for combinatorial testing for the generalized models, and show its correctness and computational complexity. We apply a tool based on our algorithm to an actual ticket gate system that is used by several large transportation companies in Japan. Experimental results show that our technique outperforms existing techniques.', NULL);
INSERT INTO `list` VALUES (529, '0000-00-00', 2015, 'inproceedings', 'Akihisa Yamada, Takashi Kitamura, Cyrille Artho, Eun-Hye Choi, Yutaka Oiwa, Armin Biere', 'Optimization of Combinatorial Testing by Incremental SAT Solving', 'Generation', 'Constraint', '2015 International Conference on Software Testing, Verification and Validation', 'ICST', '', '', '1--10', 'IEEE', '10.1109/ICST.2015.7102599', 'Combinatorial Testing', 'Combinatorial testing aims at reducing the cost of software and system testing by reducing the number of test cases to be executed. We propose an approach for combinatorial testing that generates a set of test cases that is as small as possible, using incremental SAT solving. We present several search-space pruning techniques that further improve our approach. Experiments show a significant improvement of our approach over other SAT-based approaches, and considerable reduction of the number of test cases over other combinatorial testing tools.', NULL);
INSERT INTO `list` VALUES (531, '0000-00-00', 2015, 'inproceedings', 'Rachel Tzoref-Brill, Shahar Maoz', 'Lattice-Based Semantics for Combinatorial Model Evolution', 'Model', '', '2015 International Symposium on Automated Technology for Verification and Analysis', 'ATVA', '', '', '276-292', '', '10.1007/978-3-319-24953-7_22', 'Combinatorial Testing', 'Combinatorial test design (CTD) is an effective test design technique, considered to be a testing best practice. CTD provides automatic test plan generation, but it requires a manual definition of the test space in the form of a combinatorial model. As the system under test evolves, e.g., due to iterative development processes and bug fixing, so does the test space, and thus, in the context of CTD, evolution translates into frequent manual model definition updates.\r\n\r\nIn this work, we show that the Boolean semantics currently in use by CTD tools to interpret the model is inadequate for combinatorial model evolution, and propose to replace it with a new lattice-based semantics that (1) provides a consistent interpretation of atomic changes to the model via Galois connections, and (2) exposes which additional parts of the model must change following an atomic change, in order to restore validity. We further use the new lattice-based semantics to define new higher-level atomic operations for combinatorial model evolution. Finally, we identify recurring abstraction and refinement patterns in the evolution of 42 real-world industrial models, and use the new lattice-based semantics to define new higher-level atomic constructs that encapsulate these patterns.\r\n\r\nThe proposed lattice-based semantics and related new modeling constructs advance the state-of-the-art in CTD with a new foundation for model evolution and with better tools for change comprehension and management.', NULL);
INSERT INTO `list` VALUES (532, '0000-00-00', 2015, 'inproceedings', 'Wei-Tek Tsai, Guanqiu Qi, Kai Hu', 'Autonomous Decentralized Combinatorial Testing', 'Generation', '', '2015 International Symposium on Autonomous Decentralized Systems', 'ISADS ', '', '', '40-47', '', '10.1109/ISADS.2015.53', 'Combinatorial Testing', 'Testing-as-a-Service (TaaS) is a software testing service in a cloud that can leverage the computation power provided by the cloud. Specifically, a TaaS can be scaled to large and dynamic workloads, executed in a distributed environment with hundreds of thousands of processors, and these processors may support concurrent and distributed test execution and analysis. This paper proposes an autonomous decentralized combinatorial testing system based on Adaptive Reasoning (AR) and Test Algebra (TA) for Combinatorial Testing (CT). AR performs testing and identifies faulty interactions, and TA eliminates related configurations from testing and there can be carried out concurrently. By combining these two, it is possible to perform large CT. We performed experiments with 2^10 components and 98:34% of configurations have been eliminated out of total number of configurations by AR and TA analysis.', NULL);
INSERT INTO `list` VALUES (533, '0000-00-00', 2015, 'inproceedings', 'Salamah Salamah, Omar Ochoa, Yadira Jacquez', 'Using Pairwise Testing to Verify Automatically-Generated Formal Specifications', 'Application', '', '2015 International Symposium on High Assurance Systems Engineering', 'HASE', '', '', '279-280', '', '10.1109/HASE.2015.46', 'Combinatorial Testing', 'In this paper, we report on the effectiveness of the testing approach known as pairwise or orthogonal testing in verifying the correctness of the LTL specifications generated by the PROperty SPECification (Prospec) tool. This tool assists the user in generating a large number (over 34,000) of formal specifications in formal languages, including Linear Temporal Logic (LTL). Pairwise testing is a technique that aims at, significantly, reducing the amount of test cases required for testing a particular software system while providing assurance of adequate coverage of the problem space.', NULL);
INSERT INTO `list` VALUES (534, '0000-00-00', 2015, 'inproceedings', 'Justyna Petke', 'Testing Django Configurations Using Combinatorial Interaction Testing', 'Application', '', '2015 International Symposium on Search-Based Software Engineering', 'SSBSE', '', '', '242-247', 'IEEE', '10.1007/978-3-319-22183-0_18', 'Combinatorial Testing', 'Combinatorial Interaction Testing (CIT) is important because it tests the interactions between the many parameters that make up the configuration space of software systems. We apply this testing paradigm to a Python-based framework for rapid development of web-based applications called Django. In particular, we automatically create a CIT model for Django website configurations and run a state-of-the-art tool for CIT test suite generation to obtain sets of test configurations. Our automatic CIT-based approach is able to efficiently detect invalid configurations.', NULL);
INSERT INTO `list` VALUES (535, '0000-00-00', 2015, 'inproceedings', 'Paris Kitsos, Dimitris E. Simos, Jose Torres-Jimenez, Artemios G. Voyiatzis', 'Exciting FPGA Cryptographic Trojans using Combinatorial Testing', 'Application', '', '2015 International Symposium on Software Reliability Engineering', 'ISSRE', '', '', '1--10', '', 'https://doi.org/10.1109/ISSRE.2015.7381800', 'Combinatorial Testing', 'Contemporary hardware design shares many similarities with software development. The injection of malicious functionality (Trojans) in FPGA designs is a realistic threat. Established techniques for testing correctness do not cope well with Trojans, since Trojans are not captured in the system model. Furthermore, a well-designed Trojan activates under rare conditions and can escape detection during testing. Such conditions cannot be exhaustively searched, especially in the case of cryptographic core implementations with hundreds of inputs. In this paper, we explore the applicability of a prominent combinatorial strategy, namely combinatorial testing, for FPGA Trojan detection. We demonstrate that combinatorial testing provides the theoretical guarantees for exciting a Trojan of specific lengths by covering all input combinations. Our findings indicate that combinatorial testing constructs can improve the existing FPGA Trojan detection capabilities by reducing significantly the number of tests needed. Besides the foundations of our approach, we also report on first experiments that indicate its practical use.', NULL);
INSERT INTO `list` VALUES (536, '0000-00-00', 2015, 'inproceedings', 'Gulsen Demiroz', 'Cost-aware combinatorial interaction testing (doctoral symposium)', 'Optimization', 'Priority', '2015 International Symposium on Software Testing and Analysis', 'ISSTA', '', '', '440-443', 'ACM', '10.1145/2771783.2784775', 'Combinatorial Testing', 'The configuration spaces of software systems are often too large to test exhaustively. Combinatorial interaction testing approaches, such as covering arrays, systematically sample the configuration space and test only the selected configurations. Traditional t-way covering arrays aim to cover all t-way combinations of option settings in a minimum number of configurations. By doing so, they assume that the testing cost of a configuration is the same for all configurations. In my thesis work, we however argue that, in practice, the actual testing cost may differ from one configuration to another and that accounting for these differences can improve the cost-effectiveness of covering arrays. To this end, we introduced a new novel combinatorial object, called a cost-aware covering array where a t-way cost-aware covering array is a t-way covering array that minimizes a given cost function. As part of progress, we developed an algorithm for a simple, yet important scenario, and the results of our empirical studies suggest that cost-aware covering arrays can greatly reduce the actual cost of testing compared to traditional covering arrays. We also defined a framework for defining the cost function but then we observed that manually creating these cost models is impractical. Hence our first future goal is to develop an approach for automatically discovering cost models for complex configuration spaces. Our second future goal is then to develop algorithms to generate cost-aware covering arrays for more general cost scenarios. Our focus is currently on meta-heuristic search algorithms such as simulated annealing and genetic algorithms to construct cost-aware covering arrays. Another goal is to expand the cost framework to be test-case aware where not every test case is valid for a configuration, hence the cost of running the test suite is actually different for each configuration.', NULL);
INSERT INTO `list` VALUES (537, '0000-00-00', 2015, 'inproceedings', 'Hiroyuki Nakagawa, Tatsuhiro Tsuchiya', 'Towards automatic constraints elicitation in pair-wise testing based on a linguistic approach: elicitation support using coupling strength', 'Model', 'Constraint', '2015 International Workshop on Requirements Engineering and Testing', 'other', '', '', '34-36', '', 'https://dl.acm.org/doi/10.5555/2820704.2820714', 'Combinatorial Testing', 'This paper focuses on the constraints elicitation in the combinatorial test design. Pair-wise testing, a common combinatorial testing approach, is an effective test planning technique to find interaction faults from the relatively small set of test cases. The test space is modeled by a set of parameters, their individual values, and constraints on the value combinations. Constraints reduce the test space, however, little consideration has been given to the process of finding them. The goal of our study is to establish an automatic constraints acquisition from the requirements document. We try to establish a constraints elicitation mechanism that helps to extract constraints from the requirements document based on a linguistic approach. In this paper, as the first step, we attempt to extract the coupling strength between parameters from the requirements document. We conducted a preliminary experiment on an ATM system example and evaluated the feasibility of our approach.', NULL);
INSERT INTO `list` VALUES (538, '0000-00-00', 2015, 'inproceedings', 'Justyna Petke', 'Constraints: The Future of Combinatorial Interaction Testing', 'Other', 'Constraint', '2015 International Workshop on Search-Based Software Testing', 'SBST', '', '', '17-18', '', '10.1109/SBST.2015.11', 'Combinatorial Testing', 'Combinatorial Interaction Testing (CIT) has gained a lot of attention in the area of software engineering in the last few years. CIT problems have their roots in combinatorics. Mathematicians have been concerned with the NP-complete problem of finding minimal covering arrays (in other words, minimal CIT test suites) since early nineties. With the adoption of these techniques into the area of software testing, an important gap has been identified - namely consideration of real-world constraints. We show that indeed finding an efficient way of handling constraints during search is the key factor in wider applicability of CIT techniques.', NULL);
INSERT INTO `list` VALUES (539, '0000-00-00', 2015, 'inproceedings', 'Yue Jia', 'Hyperheuristic Search for SBST', 'Other', 'Search Based', '2015 International Workshop on Search-Based Software Testing', 'SBST', '', '', '15-16', '', '10.1109/SBST.2015.10', 'Combinatorial Testing', 'This paper argues that incorporating hyper heuristic techniques into existing SBST approaches could help to increase their applicability and generality. We propose a general two layer selective hyper heuristic approach for SBST and provide an example of its use for Combinatorial Interaction Testing (CIT).', NULL);
INSERT INTO `list` VALUES (540, '0000-00-00', 2015, 'article', 'Shiwei Gao, Jianghua Lv, Binglei Du, Charles J. Colbourn, Shilong Ma', 'Balancing Frequencies and Fault Detection in the In-Parameter-Order Algorithm', 'Optimization', 'Priority', '2015 Journal of Computer Science and Technology ', 'JCS&T', '30', '5', '957-968', '', '10.1007/s11390-015-1574-6', 'Combinatorial Testing', 'The In-Parameter-Order (IPO) algorithm is a widely used strategy for the construction of software test suites for combinatorial testing (CT) whose goal is to reveal faults triggered by interactions among parameters. Variants of IPO have been shown to produce test suites within reasonable amounts of time that are often not much larger than the smallest test suites known. When an entire test suite is executed, all faults that arise from t-way interactions for some fixed t are surely found. However, when tests are executed one at a time, it is desirable to detect a fault as early as possible so that it can be repaired. The basic IPO strategies of horizontal and vertical growth address test suite size, but not the early detection of faults. In this paper, the growth strategies in IPO are modified to attempt to evenly distribute the values of each parameter across the tests. Together with a reordering strategy that we add, this modification to IPO improves the rate of fault detection dramatically (improved by 31% on average). Moreover, our modifications always reduce generation time (2 times faster on average) and in some cases also reduce test suite size.', NULL);
INSERT INTO `list` VALUES (543, '0000-00-00', 2015, 'article', 'Rubing Huang, Jinfu Chen, Dave Towey, Alvin T.S. Chan, Yansheng Lu', 'Aggregate-strength interaction test suite prioritization', 'Optimization', 'Priority', '2015 Journal of Systems and Software', 'JSS', '99', '', '36-51', 'Elsevier', '10.1016/j.jss.2014.09.002', 'Combinatorial Testing', 'Combinatorial interaction testing is a widely used approach. In testing, it is often assumed that all combinatorial test cases have equal fault detection capability, however it has been shown that the execution order of an interaction test suite\'s test cases may be critical, especially when the testing resources are limited. To improve testing cost-effectiveness, test cases in the interaction test suite can be prioritized, and one of the best-known categories of prioritization approaches is based on “fixed-strength prioritization”, which prioritizes an interaction test suite by choosing new test cases which have the highest uncovered interaction coverage at a fixed strength (level of interaction among parameters). A drawback of these approaches, however, is that, when selecting each test case, they only consider a fixed strength, not multiple strengths. To overcome this, we propose a new “aggregate-strength prioritization”, to combine interaction coverage at different strengths. Experimental results show that in most cases our method performs better than the test-case-generation, reverse test-case-generation, and random prioritization techniques. The method also usually outperforms “fixed-strength prioritization”, while maintaining a similar time cost.', NULL);
INSERT INTO `list` VALUES (544, '0000-00-00', 2015, 'article', 'Beatriz Pérez Lamancha, Macario Polo, Mario Piattini', 'PROW: A Pairwise algorithm with constRaints, Order and Weight', 'Generation', 'Constraint, Priority, Tool, Software Product Line', '2015 Journal of Systems and Software', 'JSS', '99', '', '1--19', 'Elsevier', '10.1016/j.jss.2014.08.005', 'Combinatorial Testing', 'Testing systems with many variables and/or values is often quite expensive due to the huge number of possible combinations to be tested. There are several criteria available to combine test data and produce scalable test suites. One of them is pairwise. With the pairwise criterion, each pair of values of any two parameters is included in at least one test case. Although this is a widely-used coverage criterion, two main characteristics improve considerably pairwise: constraints handling and prioritisation.\r\n\r\nThis paper presents an algorithm and a tool. The algorithm (called PROW: Pairwise with constRaints, Order and Weight) handles constraints and prioritisation for pairwise coverage. The tool called CTWeb adds functionalities to execute PROW in different contexts, one of them is product sampling in Software Product Lines via importing feature models. Software Product Line (SPL) development is a recent paradigm, where a family of software systems is constructed by means of the reuse of a set of common functionalities and some variable functionalities. An essential artefact of a SPL is the feature model, which shows the features offered by the product line, jointly with the relationships (includes and excludes) among them. Pairwise testing could be used to obtain the product sampling to test in a SPL, using features as pairwise parameters. In this context, the constraint handling becomes essential. As a difference with respect to other tools, CTWeb does not require SAT solvers.\r\n\r\nThis paper describes the PROW algorithm, also analysing its complexity and efficiency. The CTWeb tool is presented, including two examples of the PROW application to two real environments: the first corresponds to the migration of the subsystem of transactions processing of a credit card management system from AS400 to Oracle with .NET; the second applies both the algorithm and the tool to a SPL that monitors and controls some parameters of the load in trucks.', NULL);
INSERT INTO `list` VALUES (545, '0000-00-00', 2015, 'incollection', 'Jose Torres-Jimenez, Himer Avila-George', 'Search-Based Software Engineering to Construct Binary Test-Suites', 'Generation', 'Search Based', '2015 Trends and Applications in Software Engineering', 'Book', '405', '', '201-212', 'Springer International Publishing', '10.1007/978-3-319-26285-7_17', 'Combinatorial Testing', 'Search-based software engineering is the application of optimization techniques in solving software engineering problems. One challenge to testing software systems is the effort involved in creating test suites that will systematically test the system and reveal faults in an effective manner. Given the importance of the software testing phase, a specific subarea called search-based software testing has become increasingly important. This paper presents a search-based software testing tool (SBSTT), for constructing test suites. Through the use of SBSTT we were able to find 370 new upper bounds for binary test suites.', NULL);
INSERT INTO `list` VALUES (546, '0000-00-00', 2016, 'article', 'Rongzhi Qi, Zhijian Wang, Shuiyan Li', 'A Parallel Genetic Algorithm Based on Spark for Pairwise Test Suite Generation', 'Generation', 'Search Based', '2016 Journal of Computer Science and Technology', 'JCS&T', '31', '2', '417-427', '', '10.1007/s11390-016-1635-5', 'Combinatorial Testing', 'Pairwise testing is an effective test generation technique that requires all pairs of parameter values to be covered by at least one test case. It has been proven that generating minimum test suite is an NP-complete problem. Genetic algorithms have been used for pairwise test suite generation by researchers. However, it is always a time-consuming process, which leads to significant limitations and obstacles for practical use of genetic algorithms towards large-scale test problems. Parallelism will be an effective way to not only enhance the computation performance but also improve the quality of the solutions. In this paper, we use Spark, a fast and general parallel computing platform, to parallelize the genetic algorithm to tackle the problem. We propose a two-phase parallelization algorithm including fitness evaluation parallelization and genetic operation parallelization. Experimental results show that our algorithm outperforms the sequential genetic algorithm and competes with other approaches in both test suite size and computational performance. As a result, our algorithm is a promising improvement of the genetic algorithm for pairwise test suite generation.', NULL);
INSERT INTO `list` VALUES (547, '0000-00-00', 2016, 'article', 'Kamal Z. Zamli, Basem Y. Alkazemi, Graham Kendall', 'A Tabu Search hyper-heuristic strategy for t-way test suite generation', 'Generation', 'Search Based', '2016 Applied Soft Computing', 'Appl. Soft Comput', '44', '', '57-74', '', '10.1016/j.asoc.2016.03.021', 'Combinatorial Testing', 'This paper proposes a novel hybrid t-way test generation strategy (where t indicates interaction strength), called High Level Hyper-Heuristic (HHH). HHH adopts Tabu Search as its high level meta-heuristic and leverages on the strength of four low level meta-heuristics, comprising of Teaching Learning based Optimization, Global Neighborhood Algorithm, Particle Swarm Optimization, and Cuckoo Search Algorithm. HHH is able to capitalize on the strengths and limit the deficiencies of each individual algorithm in a collective and synergistic manner. Unlike existing hyper-heuristics, HHH relies on three defined operators, based on improvement, intensification and diversification, to adaptively select the most suitable meta-heuristic at any particular time. Our results are promising as HHH manages to outperform existing t-way strategies on many of the benchmarks.', NULL);
INSERT INTO `list` VALUES (558, '2016-07-15', 2016, 'inproceedings', 'Jaganmohan Chandrasekaran, Laleh Sh. Ghandehari, Yu Lei, Raghu N. Kacker, D. Richard Kuhn', 'Evaluating the Effectiveness of BEN in Localizing Different Types of Software Fault', 'Evaluation', 'Tool', '2016 5th International Workshop on Combinatorial Testing', 'IWCT', '', '', '26-34', 'IEEE', '10.1109/ICSTW.2016.44', 'Combinatorial Testing', 'Debugging or fault localization is one of the most challenging tasks during software development. Many tools have been developed to reduce the amount of effort and time software developers have to spend on fault localization. In this paper, we evaluate the effectiveness of a fault localization tool called BEN in localizing different types of software fault. Assuming that combinatorial testing has been performed on the subject program, BEN leverages the result obtained from combinatorial testing to perform fault localization. Our evaluation focuses on impact of three properties of software fault on the effectiveness of BEN. The three properties include accessibility, input value sensitivity and control flow sensitivity. A random test set-based approach is used to measure the three properties. The experimental results suggest that BEN is more effective, respectively, in localizing faults of lower accessibility, input value-insensitive faults or control flow-insensitive faults than localizing faults of higher accessibility, input value-sensitive or control flow-sensitive faults in the subject programs. The insights obtained from our evaluation can be applied to other fault localization tools that are similar to BEN, and can be used to identify opportunities for further research on combinatorial testing-based fault localization.', NULL);
INSERT INTO `list` VALUES (559, '2016-07-15', 2016, 'inproceedings', 'Chiya Xu, Yuanchao Qi, Ziyuan Wang, Weifeng Zhang', 'Analyzing Minimal Failure-Causing Schemas in Siemens Suite', 'Evaluation', '', '2016 5th International Workshop on Combinatorial Testing', 'IWCT', '', '', '35-38', 'IEEE', '10.1109/ICSTW.2016.33', 'Combinatorial Testing', 'Combinatorial testing has been widely utilized in testing softwares, e.g. Siemens Suite. This paper aims to investigate the reason why combinatorial testing works in Siemens Suite. Experiments are designed to get the MFS(minimal failure-causing schema) for Siemens Suite, which has been used as a benchmark to evaluate the effectiveness of many testing techniques. The lowerbound of fault-detecting probability of T-way combinatorial test suite for each program is calculated by analyzing the strengths and the number of MFS for each faulty version. Computational results could explain the effectiveness of combinatorial testing in Siemens Suite.', NULL);
INSERT INTO `list` VALUES (560, '2016-07-15', 2016, 'inproceedings', 'Sergiy Vilkomir, Galen Pennell', 'Should We Care about \"Don\'t Care\" Testing Inputs? Empirical Investigation of Pair-Wise Testing', 'Generation', '', '2016 5th International Workshop on Combinatorial Testing', 'IWCT', '', '', '39-45', 'IEEE', '10.1109/ICSTW.2016.8', 'Combinatorial Testing', 'When test sets are generated according to a coverage criterion, it is often sufficient to fix values only for some of the inputs to achieve 100% coverage. Other inputs are immaterial and the coverage is achieved with any of their values (\"don\'t care\" values). The research question is: How do these \"don\'t care\" values (which can reach up to 20% of all input values) influence the effectiveness and other characteristics of test sets? The paper empirically investigated this question for pair-wise test sets applied for logical expressions with different sizes and complexities. Variations of the effectiveness and the Modified Condition/Decision Coverage (MC/DC) levels of pair-wise test sets were analyzed. Our results show that these variations are low and so pair-wise test sets with different \"don\'t care\" values are very stable. Any test set with randomly selected \"don\'t care\" values can be similarly used for practical testing.', NULL);
INSERT INTO `list` VALUES (561, '2016-07-15', 2016, 'inproceedings', 'Gulsen Demiroz, Cemal Yilmaz', 'Towards Automatic Cost Model Discovery for Combinatorial Interaction Testing', 'Model', '', '2016 5th International Workshop on Combinatorial Testing', 'IWCT', '', '', '46-50', 'IEEE', '10.1109/ICSTW.2016.7', 'Combinatorial Testing', 'We present an automated approach for cost model discovery in configuration spaces. Given a configuration space, a quality assurance (QA) task of interest, and a means of measuring the cost of carrying out the QA task, the proposed approach systematically sample the configuration space by using a traditional covering array, carry out the QA task in each of the selected configurations, measure the costs, and fit a generalized linear regression model to the observed costs. The resulting model is then used to estimate the cost of performing the QA task in a possibly previously unseen configuration. The results of our empirical studies conducted on two highly configurable and widely used software systems, strongly support our basic hypothesis that the proposed approach can efficiently and effectively discover reliable cost models.', NULL);
INSERT INTO `list` VALUES (562, '2016-07-15', 2016, 'inproceedings', 'Anwar Sherif', 'Combinatorial Testing: Implementations in Solutions Testing', 'Application', '', '2016 5th International Workshop on Combinatorial Testing', 'IWCT', '', '', '59-64', 'IEEE', '10.1109/ICSTW.2016.39', 'Combinatorial Testing', 'It is apparent that implementing Combinatorial (CT) Testing, being relatively new to many organizations, comes with both technical and non-technical challenges. This paper focuses the technical challenges and how they were addressed in implementing CT for solutions testing. The author believes that these challenges are not unique to solution testing, and that they are equally applicable to implementations of CT in general.', NULL);
INSERT INTO `list` VALUES (563, '2016-07-15', 2016, 'inproceedings', 'George Sherwood', 'Embedded Functions for Constraints and Variable Strength in Combinatorial Testing', 'Application', '', '2016 5th International Workshop on Combinatorial Testing', 'IWCT', '', '', '65-74', 'IEEE', '10.1109/ICSTW.2016.16', 'Combinatorial Testing', 'An embedded functions feature was implemented to specify functionally dependent relations among test factors. Functions embedded in a combinatorial test case generator specified test factor constraints to which the resulting test cases conformed. The functions were defined in a general-purpose programming language widely used among software engineers. Examples with and without embedded functions were compared. Embedded functions were used to evaluate equivalence class factors to insure coverage of selected classes of results. Embedded functions also were used to evaluate hybrid factors in variable strength designs. Usability and performance characteristics were described.', NULL);
INSERT INTO `list` VALUES (564, '2016-07-15', 2016, 'inproceedings', 'Peter M. Kruse', 'Test Oracles and Test Script Generation in Combinatorial Testing', 'Other', '', '2016 5th International Workshop on Combinatorial Testing', 'IWCT', '', '', '75-82', 'IEEE', '10.1109/ICSTW.2016.11', 'Combinatorial Testing', 'Combinatorial test design is a well-established practice for obtaining tests. Most approaches focus on the actual test generation and test size minimization. For execution of test cases, expected results and executable test scripts are required. We investigate both, how to determine expected results for test cases, ideally in an automated fashion, and ways for generic test script generation to allow for execution of combinatorial test suites. This paper provides a survey of current approaches to test oracles and test script generation in combinatorial testing. Illustration and running example is provided in terms of the Classification Tree Method.', NULL);
INSERT INTO `list` VALUES (565, '2016-07-15', 2016, 'inproceedings', 'D. Richard Kuhn, Vincent C. Hu, David Ferraiolo, Raghu N. Kacker, Yu Lei', 'Pseudo-exhaustive Testing of Attribute Based Access Control Rules', 'Application', '', '2016 5th International Workshop on Combinatorial Testing', 'IWCT', '', '', '51-58', 'IEEE', '10.1109/ICSTW.2016.35', 'Combinatorial Testing', 'Access control typically requires translating policies or rules given in natural language into a form such as a programming language or decision table, which can be processed by an access control system. Once rules have been described in machine-processable form, testing is necessary to ensure that the rules are implemented correctly. This paper describes an approach based on combinatorial test methods for efficiently testing access control rules, using the structure of attribute based access control (ABAC) to detect a large class of faults without a conventional test oracle.', NULL);
INSERT INTO `list` VALUES (566, '2016-07-15', 2016, 'inproceedings', 'Lydie du Bousquet, Mickael Delahaye, Catherine Oriat', 'Applying a pairwise coverage criterion to scenario-based testing', 'Application', '', '2016 5th International Workshop on Combinatorial Testing', 'IWCT', '', '', '83-91', 'IEEE', '10.1109/ICSTW.2016.23', 'Combinatorial Testing', 'Some scenario-based testing approaches propose to express a test suite as a regular expression (called scenario or pattern). It specifies a set of valid sequences of operations in a abstract way. When the regular expression is \"unfold\", test sequences are obtained. Usually, the unfolding is done in an exhaustive way, which can result in a combinatorial explosion. In this article, we explore a pairwise coverage criterion to select a subset of test sequences satisfying the pattern, in order to decrease the number of test sequences. The originality of the approach lies in the fact that the pairwise criterion is applied to the instantiated method calls (and not on the parameters). We applied this strategy to generate unit tests for Java classes. The quality of the test suites is evaluated with a mutation analysis and compared to test suites randomly generated.', NULL);
INSERT INTO `list` VALUES (567, '2016-07-15', 2016, 'inproceedings', 'Koji Tsumura, Hironori Washizaki, Yoshiaki Fukazawa, Keishi Oshima, Ryota Mibe', 'Pairwise Coverage-based Testing with Selected Elements in a Query for Database Applications', 'Application', '', '2016 5th International Workshop on Combinatorial Testing', 'IWCT', '', '', '92-101', 'IEEE', '10.1109/ICSTW.2016.19', 'Combinatorial Testing', 'Because program behaviors of database applications depend on the data used, code coverages do not effectively test database applications. Additionally, test coverages for database applications that focus on predicates in Structured Query Language (SQL) queries are not useful if the necessary predicates are omitted. In this paper, we present two new database applications using Plain Pairwise Coverage (PPC) and Selected Pairwise Coverage (SPC) for SQL queries called Plain Pairwise Coverage Testing (PPCT) and Selected Pairwise Coverage Testing (SPCT), respectively. These coverages are based on pairwise testing coverage, which employs selected elements in the SQL SELECT query as parameters. We also implement a coverage calculation tool and conduct case studies on two open source software systems. PPCT and SPCT can detect many faults, which are not detected by existing test methods based on predicates in the query. Furthermore, the case study suggests that SPCT can detect faults more efficiently than PPCT and the costs of SPCT can be further reduced by ignoring records filtered out by the conditions of the query.', NULL);
INSERT INTO `list` VALUES (575, '2016-10-04', 2016, 'inproceedings', 'Nariman Mirzaei, Joshua Garcia, Hamid Bagheri, Alireza Sadeghi, Sam Malek', 'Reducing combinatorics in GUI testing of android applications', 'Application', '', '2016 International Conference on Software Engineering', 'ICSE', '', '', '559-570', 'ACM', '10.1145/2884781.2884853', 'Combinatorial Testing', 'The rising popularity of Android and the GUI-driven nature of its apps have motivated the need for applicable automated GUI testing techniques. Although exhaustive testing of all possible combinations is the ideal upper bound in combinatorial testing, it is often infeasible, due to the combinatorial explosion of test cases. This paper presents TrimDroid, a framework for GUI testing of Android apps that uses a novel strategy to generate tests in a combinatorial, yet scalable, fashion. It is backed with automated program analysis and formally rigorous test generation engines. TrimDroid relies on program analysis to extract formal specifications. These specifications express the app’s behavior (i.e., control flow between the various app screens) as well as the GUI elements and their dependencies. The dependencies among the GUI elements comprising the app are used to reduce the number of combinations with the help of a solver. Our experiments have corroborated TrimDroid’s ability to achieve a comparable coverage as that possible under exhaustive GUI testing using significantly fewer test cases.', NULL);
INSERT INTO `list` VALUES (576, '2016-10-04', 2016, 'inproceedings', 'Flavio Medeiros, Christian Kastner, Marcio Ribeiro, Rohit Gheyi, Sven Apel', 'A comparison of 10 sampling algorithms for configurable systems', 'Evaluation', '', '2016 International Conference on Software Engineering', 'ICSE', '', '', '643-654', 'ACM', '10.1145/2884781.2884793', 'Combinatorial Testing', 'Almost every software system provides configuration options to tailor the system to the target platform and application scenario. Often, this configurability renders the analysis of every individual system configuration infeasible. To address this problem, researchers have proposed a diverse set of sampling algorithms. We present a comparative study of 10 state-of-the-art sampling algorithms regarding their fault-detection capability and size of sample sets. The former is important to improve software quality and the latter to reduce the time of analysis. In a nutshell, we found that sampling algorithms with larger sample sets are able to detect higher numbers of faults, but simple algorithms with small sample sets, such as most-enabled-disabled, are the most efficient in most contexts. Furthermore, we observed that the limiting assumptions made in previous work influence the number of detected faults, the size of sample sets, and the ranking of algorithms. Finally, we have identified a number of technical challenges when trying to avoid the limiting assumptions, which questions the practicality of certain sampling algorithms.', NULL);
INSERT INTO `list` VALUES (577, '2016-10-04', 2016, 'inproceedings', 'Akihisa Yamada, Armin Biere, Cyrille Artho, Takashi Kitamura, Eun-Hye Choi', 'Greedy combinatorial test case generation using unsatisfiable cores', 'Generation', 'Constraint', '2016 International Conference on Automated Software Engineering', 'ASE', '', '', '614-624', 'ACM', '10.1145/2970276.2970335', 'Combinatorial Testing', 'Combinatorial testing aims at covering the interactions of parameters in a system under test, while some combinations may be forbidden by given constraints (forbidden tuples). In this paper, we illustrate that such forbidden tuples correspond to unsatisfiable cores, a widely understood notion in the SAT solving community. Based on this observation, we propose a technique to detect forbidden tuples lazily during a greedy test case generation, which significantly reduces the number of required SAT solving calls. We further reduce the amount of time spent in SAT solving by essentially ignoring constraints while constructing each test case, but then “amending” it to obtain a test case that satisfies the constraints, again using unsatisfiable cores. Finally, to complement a disturbance due to ignoring constraints, we implement an efficient approximative SAT checking function in the SAT solver Lingeling. Through experiments we verify that our approach significantly improves the efficiency of constraint handling in our greedy combinatorial testing algorithm.', NULL);
INSERT INTO `list` VALUES (578, '2016-10-04', 2016, 'inproceedings', 'Rachel Tzoref-Brill, Paul Wojciak, Shahar Maoz', 'Visualization of combinatorial models and test plans', 'Model', '', '2016 International Conference on Automated Software Engineering', 'ASE', '', '', '144-154', 'ACM', '10.1145/2970276.2970301', 'Combinatorial Testing', 'Combinatorial test design (CTD) is an effective and widely used test design technique. CTD provides automatic test plan generation, but it requires a manual definition of the test space in the form of a combinatorial model. One challenge for successful application of CTD in practice relates to this manual model definition and maintenance process. Another challenge relates to the comprehension and use of the test plan generated by CTD for prioritization purposes.\r\n\r\nIn this work we introduce the use of visualizations as a means to address these challenges. We apply three different forms of visualization, matrices, graphs, and treemaps, to visualize the relationships between the different elements of the model, and to visualize the strength of each test in the test plan and the relationships between the different tests in terms of combinatorial coverage. We evaluate our visualizations via a user survey with 19 CTD practitioners, as well as via two industrial projects in which our visualization was used and allowed test designers to get vital insight into their models and into the coverage provided through CTD generated test plans.', NULL);
INSERT INTO `list` VALUES (579, '2016-10-04', 2016, 'inproceedings', 'Nan Li, Yu Lei, Haider Riaz Khan, Jingshu Liu, Yun Guo', 'Applying combinatorial test data generation to big data applications', 'Application', '', '2016 International Conference on Automated Software Engineering', 'ASE', '', '', '637-647', 'ACM', '10.1145/2970276.2970325', 'Combinatorial Testing', 'Big data applications (e.g., Extract, Transform, and Load (ETL) applications) are designed to handle great volumes of data. However, processing such great volumes of data is time-consuming. There is a need to construct small yet effective test data sets during agile development of big data applications. In this paper, we apply a combinatorial test data generation approach to two real-world ETL applications at Medidata. In our approach, we first create Input Domain Models (IDMs) automatically by analyzing the original data source and incorporating constraints manually derived from requirements. Next, the IDMs are used to create test data sets that achieve t-way coverage, which has shown to be very effective in detecting software faults. The generated test data sets also satisfy all the constraints identified in the first step. To avoid creating IDMs from scratch when there is a change to the original data source or constraints, our approach extends the original IDMs with additional information. The new IDMs, which we refer to as Adaptive IDMs (AIDMs), are updated by comparing the changes against the additional information, and are then used to generate new test data sets. We implement our approach in a tool, called comBinatorial big daTa Test dAta Generator (BIT-TAG). Our experience shows that combinatorial testing can be effectively applied to big data applications. In particular, the test data sets created using our approach for the two ETL applications are only a small fraction of the original data source, but we were able to detect all the faults found with the original data source.', NULL);
INSERT INTO `list` VALUES (580, '2016-10-04', 2016, 'inproceedings', 'Jens Meinicke, Chu-Pan Wong, Christian Kastner, Thomas Thum, Gunter Saake', 'On essential configuration complexity: measuring interactions in highly-configurable systems', 'Model', '', '2016 International Conference on Automated Software Engineering', 'ASE', '', '', '483-494', 'ACM', '10.1145/2970276.2970322', 'Combinatorial Testing', 'Quality assurance for highly-configurable systems is challenging due to the exponentially growing configuration space. Interactions among multiple options can lead to surprising behaviors, bugs, and security vulnerabilities. Analyzing all configurations systematically might be possible though if most options do not interact or interactions follow specific patterns that can be exploited by analysis tools. To better understand interactions in practice, we analyze program traces to characterize and identify where interactions occur on control flow and data. To this end, we developed a dynamic analysis for Java based on variability-aware execution and monitor executions of multiple small to medium-sized programs. We find that the essential configuration complexity of these programs is indeed much lower than the combinatorial explosion of the configuration space indicates. However, we also discover that the interaction characteristics that allow scalable and complete analyses are more nuanced than what is exploited by existing state-of-the-art quality assurance strategies.', NULL);
INSERT INTO `list` VALUES (581, '2016-10-04', 2016, 'inproceedings', 'Myra B. Cohen, A. Pavan, N.V. Vinodchandran', 'Budgeted Testing Through an Algorithmic Lens', 'Generation', '', '2016 International Symposium on the Foundations of Software Engineering (Industry Track)', 'FSE', '', '', '1-1', 'ACM', 'https://doi.org/10.1145/2950290.2983987', 'Combinatorial Testing', 'Automated testing has been a focus of research for a long time. As such, we tend to think about this in a coverage centric manner. Testing budgets have also driven research such as prioritization and test selection, but as a secondary concern. As our systems get larger, are more dynamic, and impact more people with each change, we argue that we should switch from a coverage centric view to a budgeted testing centric view. Researchers in other fields have designed approximation algorithms for such budgeted scenarios and these are often simple to implement and run. In this paper we present an exemplar study on combinatorial interaction testing (CIT) to show that a budgeted greedy algorithm, when adapted to our problem for various budgets, does almost as well coverage-wise as a state of the art greedy CIT algorithm, better in some cases than a state of the art simulated annealing, and always improves over random. This suggests that we might benefit from switching our focus in large systems, from coverage to budgets.', NULL);
INSERT INTO `list` VALUES (583, '2016-10-04', 2016, 'inproceedings', 'D. Richard Kuhn, Raghu N. Kacker, Yu Lei', 'Estimating t-Way Fault Profile Evolution During Testing', 'Evaluation', '', '2016 Annual Computer Software and Applications Conference', 'COMPSAC', '', '', '596-597', 'IEEE', '10.1109/COMPSAC.2016.110', 'Combinatorial Testing', 'Empirical studies have shown that most software interaction faults involve one or two variables interacting, with progressively fewer triggered by three or more, and no failure has been reported involving more than six variables interacting. This paper introduces a model for the origin of this distribution, evaluates model predictions against empirical data, and discusses implications for removal of interaction faults and reliability growth.', NULL);
INSERT INTO `list` VALUES (584, '2016-10-04', 2016, 'inproceedings', 'Rubing Huang, Weiwen Zong, Jinfu Chen, Dave Towey, Yunan Zhou, Deng Chen', 'Prioritizing Interaction Test Suites Using Repeated Base Choice Coverage', 'Optimization', 'Priority', '2016 Annual Computer Software and Applications Conference', 'COMPSAC', '', '', '174-184', 'IEEE', '10.1109/COMPSAC.2016.167', 'Combinatorial Testing', 'Combinatorial interaction testing is a well-studied testing strategy that aims at constructing an effective interaction test suite (ITS) of a specific generation strength to identify interaction faults caused by the interactions among factors. Due to limited testing resources in practice, for example in combinatorial interaction regression testing, interaction test suite prioritization (ITSP) has been proposed to improve the efficiency of testing. An intuitive ITSP strategy that has been widely used in practice is fixed-strength interaction coverage based prioritization (FICBP). FICBP makes use of a property of the ITS: interaction coverage at a fixed prioritization strength. However, a challenge facing FICBP is that, when the ITS is large, the prioritization cost can be very high. In this paper, we propose a new FICBP method that, by repeatedly using base choice coverage (i.e., one-wise coverage) during the prioritization process, improves testing efficiency while maintaining testing effectiveness. The empirical studies show that our method has fault detection capability comparable to current FICBP methods, but obtains more stable results in many cases. Additionally, our method requires considerably less prioritization time than other FICBP methods at different prioritization strengths.', NULL);
INSERT INTO `list` VALUES (585, '2016-10-04', 2016, 'inproceedings', 'Sergiy Vilkomir', 'Combinatorial Testing of Software with Binary Inputs: A State-of-the-Art Review', 'Generation', 'Survey', '2016 International Conference on Software Quality, Reliability and Security Companion', 'QRS-C', '', '', '55-60', 'IEEE', '10.1109/QRS-C.2016.12', 'Combinatorial Testing', 'Combinatorial methods are useful and effective approaches for software testing. In this paper, we provide a brief review of the research results in one area of combinatorial methods applications: software with binary or Boolean inputs. This includes the testing of logical expressions that is crucial for many safety-critical applications such as avionics software and computer systems at nuclear power plants. We consider three different aspects of this research direction: (1) effectiveness of combinatorial testing with binary inputs, (2) combinatorial test generation, and (3) comparison combinatorial testing with other approaches for testing logical expressions.', NULL);
INSERT INTO `list` VALUES (586, '2016-10-04', 2016, 'inproceedings', 'Franz Wotawa', 'Testing Self-Adaptive Systems Using Fault Injection and Combinatorial Testing', 'Application', '', '2016 International Conference on Software Quality, Reliability and Security Companion', 'QRS-C', '', '', '305-310', 'IEEE', '10.1109/QRS-C.2016.47', 'Combinatorial Testing', 'Verifying and validating systems that can adapt their behavior at runtime is still a research challenge that deserves great attention. In order to assure a certain behavior, we might prove that a self-adaptive system always fulfills certain properties, e.g., always behaving as specified in a given range. Such verification and validation techniques, however, assume the good case, i.e., that the system\'s environment is working as expected, i.e., that no fault occurs. In this paper, we relax this assumption, and consider testing self-adaptive systems in case of faults. In particular, we show how fault injection techniques and combinatorial testing can be used together for generating tests for self-adaptive systems.', NULL);
INSERT INTO `list` VALUES (587, '2016-10-04', 2016, 'incollection', 'Hua Zhong, Lingming Zhang, Sarfraz Khurshid', 'The comKorat Tool: Unified Combinatorial and Constraint-Based Generation of Structurally Complex Tests', 'Application', 'Tool', '2016 NASA Formal Methods, Lecture Notes in Computer Science', 'Book', '9690', '', '107-113', 'Springer', '10.1007/978-3-319-40648-0_9', 'Combinatorial Testing', 'This tool paper presents comKorat, which unifies constraint-based generation of structurally complex tests with combinatorial testing. Constraint-based test generation is an effective approach for generating structurally complex inputs for systematic testing. While this approach can typically generate large numbers of tests, it has limited scalability – tests generated are usually only up to a small bound on input size. Combinatorial test generation, e.g., pair-wise testing, is a more scalable approach but is challenging to apply on commercial software systems that require complex input structures that cannot be formed by using arbitrary combinations. The comKorat tool integrates Korat and ACTS test generators to generate test suites for large scale commercial systems. This paper presents a case-study of applying comKorat on a software application developed at Yahoo!. The experimental results show that comKorat outperforms existing solution in execution time and finds a total of 23 previously unknown bugs in the application.', NULL);
INSERT INTO `list` VALUES (589, '2016-10-04', 2016, 'phdthesis', 'Laleh Sh. Ghandehari', 'Fault Localization Based on Combinatorial Testing', 'Diagnosis', '', '2016 The University of Texas at Arlington', 'Phd', '', '', 'not  found', '', 'not  found', 'Combinatorial Testing', 'not found', NULL);
INSERT INTO `list` VALUES (590, '2016-10-04', 2016, 'article', 'Huayao Wu, Changhai Nie, Fei-Ching Kuo', 'The optimal testing order in the presence of switching cost', 'Optimization', 'Priority, Search Based', '2016 Information and Software Technology', 'IST', '80', '', '57-72', '', '10.1016/j.infsof.2016.08.006', 'Combinatorial Testing', 'We show that there exists a trade-off between high rate of combination coverage and low switching cost.We comprehensively compare three single objective algorithms with hybrid and multi-objective algorithms in the presence of switching cost.We find that the heuristic solver for travelling salesmen problem is the best algorithm to minimize switching cost.In order to improve the rate of combination coverage over time and the ability of early fault detection, we recommend multi-objective algorithms. Display Omitted ContextTest suite prioritization is a problem of deciding the order of executing test cases to reach the desirable outcome. Many cost-cognisant prioritization approaches decide the order based on the cost of test execution; but few based on the cost of switching test cases. The latter known as switching cost is the effort of re-configuring the environment for running subsequent test cases. Our previous studies show that switching cost can affect the efficiency of testing. ObjectiveIn this paper, we aim to identify the optimal testing order that can detect interaction triggered faults earlier in the presence switching cost. MethodWe presented a distance based metric to measure the switching cost between test cases. As reducing the switching cost can make the whole test suite run faster and thus achieve full combination coverage earlier, single-objective algorithms were used to minimize the total switching cost. Besides, when determining the next test case to run, there is a trade-off between high combination coverage and low switching cost. Hence, hybrid and multi-objective algorithms were used to achieve a better balance. In order to evaluate different algorithms, we conducted a series of experiments covering 400 different testing scenarios. We also conducted an empirical study with six real world applications. ResultsThe heuristic solver for the travelling salesman problem is the best algorithm to minimize the switching cost. It can detect faults earlier than the order with high rate of combination coverage. But in order to further reduce the effort to detect the first fault, the hybrid and multi-objective algorithms are the best methods. ConclusionPrioritization based on switching cost can speed up the fault detection to some extent, but prioritization based on both combination coverage and testing cost can deliver the optimal testing order.', NULL);
INSERT INTO `list` VALUES (591, '2016-10-04', 2016, 'article', 'Gulsen Demiroz, Cemal Yilmaz', 'Using simulated annealing for computing cost-aware covering arrays', 'Generation', 'Search Based', '2016 Applied Soft Computing', 'Appl. Soft Comput', '49', '', '1129–1144', '', '10.1016/j.asoc.2016.08.022', 'Combinatorial Testing', 'The configuration spaces of software systems are often too large to test exhaustively. Combinatorial interaction testing approaches, such as covering arrays, systematically sample the configuration space and test only the selected configurations. In an attempt to reduce the cost of testing, standard t-way covering arrays aim to cover all t-way combinations of option settings in a minimum number of configurations. By doing so, they simply assume that every configuration costs the same. When the cost varies from one configuration to another, however, minimizing the number of configurations is not necessarily the same as minimizing the cost. To overcome this issue, we have recently introduced cost-aware covering arrays. In a nutshell, a t-way cost-aware covering array is a standard t-way covering array that “minimizes” a given cost function modeling the actual cost of testing. In this work we develop a simulated annealing-based approach to compute cost-aware covering arrays, which takes as input a configuration space model enhanced with a cost function and computes a cost-aware covering array by using two alternating neighboring state generation strategies together with a fitness function expressed as a weighted sum of two objectives: covering all required t-way option setting combinations and minimizing the cost function. To the best of our knowledge, the proposed approach is the first approach that computes cost-aware covering arrays for general, non-additive linear cost functions with multiplicative interaction effects. We evaluate the approach both by conducting controlled experiments, in which we systematically vary the input models to study the sensitivity of the approach to various factors and by conducting experiments using real cost functions for real software systems. We also compare cost-aware covering arrays to standard covering arrays constructed by well-known algorithms and study how fast the construction costs are compensated by the cost reductions provided. Our empirical results suggest that the proposed approach is more effective and efficient than the existing approaches.', NULL);
INSERT INTO `list` VALUES (592, '2016-10-04', 2016, 'inproceedings', 'Christopher Henard, Mike Papadakis, Mark Harman, Yue Jia, Yves Le Traon', 'Comparing white-box and black-box test prioritization', 'Optimization', 'Priority', '2016 International Conference on Software Engineering', 'ICSE', '', '', '523-534', 'ACM', '10.1145/2884781.2884791', 'Combinatorial Testing', 'Although white-box regression test prioritization has been well-studied, the more recently introduced black-box prioritization approaches have neither been compared against each other nor against more well-established white-box techniques. We present a comprehensive experimental comparison of several test prioritization techniques, including well-established white-box strategies and more recently introduced black-box approaches. We found that Combinatorial Interaction Testing and diversity-based techniques (Input Model Diversity and Input Test Set Diameter) perform best among the black-box approaches. Perhaps surprisingly, we found little difference between black-box and white-box performance (at most 4% fault detection rate difference). We also found the overlap between black- and white-box faults to be high: the first 10% of the prioritized test suites already agree on at least 60% of the faults found. These are positive findings for practicing regression testers who may not have source code available, thereby making white-box techniques inapplicable. We also found evidence that both black-box and white-box prioritization remain robust over multiple system releases.', NULL);
INSERT INTO `list` VALUES (597, '2017-02-01', 2011, 'inproceedings', 'Brady J. Garvin, Myra B. Cohen', 'Feature Interaction Faults Revisited: An Exploratory Study', 'Evaluation', '', '2011 International Symposium on Software Reliability Engineering', 'ISSRE', '', '', '90-99', 'ACM', '10.1109/ISSRE.2011.25', 'Combinatorial Testing', 'While a large body of research is dedicated to testing for feature interactions in configurable software, there has been little work that examines what constitutes such a fault at the code level. In consequence, we do not know how prevalent real interaction faults are in practice, what a typical interaction fault looks like in code, how to seed interaction faults, or whether current interaction testing techniques are effective at finding the faults they aim to detect. We make a first step in this direction, by deriving a white box criterion for an interaction fault. Armed with this criterion, we perform an exploratory study on hundreds of faults from the field in two open source systems. We find that only three of the 28 which appear to be interaction faults are in fact due to features\' interactions. We investigate the remaining 25 and find that, although they could have been detected without interaction testing, varying the system configuration amplifies the fault-finding power of a test suite, making these faults easier to expose. Thus, we characterize the benefits of interaction testing in regards to both interaction and non-interaction faults. We end with a discussion of several mutations that can be used to mimic interaction faults based on the faults we see in practice.', NULL);
INSERT INTO `list` VALUES (599, '2017-02-01', 2013, 'phdthesis', 'Mehra N. Borazjany', 'Applying Combinatorial Testing to Systems with a Complex Input Space', 'Model', '', '2013 The University of Texas at Arlington', 'Phd', '', '', 'not found', '', 'not found', 'Combinatorial Testing', 'Combinatorial testing, which has been shown very effective in fault detection, is a\r\ntesting strategy that applies the theory of combinatorial design to test software programs. Given\r\na program under test with k parameters, t-way combinatorial testing requires all combinations of\r\nvalues of t (out of k) parameters be covered at least once, where t is usually a small integer.\r\nCombinatorial testing can significantly reduce the cost of testing while increasing its\r\neffectiveness.\r\nInput space modeling is an important step in combinatorial testing. The input space of a\r\nsubject program must be modeled before combinatorial testing can be applied to it. The\r\neffectiveness of combinatorial testing to a large extent depends on the quality of the input space\r\nmodel. If the input space is modeled perfectly, all faults caused by interactions involving no\r\nmore than t parameters will be detected.\r\nIn this dissertation, we develop an input space modeling methodology for combinatorial\r\ntesting. The main idea is to consider the process of input space modeling as two steps,\r\nv\r\nincluding input structure modeling and input parameter modeling. The first step tries to capture\r\nthe structural relationship among different components in the input space. The second s tep tries\r\nto identify parameters, values, relations and constraints for individual components.\r\nWe present several case studies of applying the proposed methodology to five real-life\r\nprograms. These studies are designed to validate the proposed methodology in a practical\r\nsetting. They are also designed to evaluate the effectiveness of combinatorial testing applied to\r\nreal-life programs. We compare the proposed methodology to two random approaches: (1)\r\npure-random, which generates test sets with minimum effort on modeling; and (2) modeledrandom, which generates random tests from the same model created by the proposed\r\nmethodology. The results show that proposed approach is more effective than the modeledrandom approach, which is significantly more effective than the pure-random approach', NULL);
INSERT INTO `list` VALUES (600, '2017-02-01', 2016, 'phdthesis', 'Nariman Mirzaei', 'Automated Input Generation Techniques for Testing Android Applications', 'Application', '', '2016 George Mason University', 'Phd', '', '', 'not found', '', 'not found', 'Combinatorial Testing', 'The rising popularity of Android and the GUI-driven nature of its apps have motivated the need for applicable automated testing techniques. This dissertation describes\r\ntwo automatic techniques for generating inputs for testing Android applications, SIG-Droid\r\nand TrimDroid. Both presented techniques employ a model-based approach to capture the\r\nevent-driven nature of Android applications into two inferred models : Interface Model and\r\nActivity Transition Model. The Interface Model is used to find values that an app can\r\nreceive through its interfaces. The Activity Transition Model is used to generate sequences\r\nof events that resemble user interactions with the app. SIG-Droid uses symbolic execution for obtaining test inputs that ensure covering each reachable branch in the program,\r\nwhile TrimDroid focuses on reducing the combinatorics (i.e. dealing with combinatorial\r\nexplosion of test cases) in combinatorial testing of Android apps. TrimDroid relies on program analysis to extract formal specifications that express the dependencies between the\r\nGUI elements. The dependencies among the GUI elements comprising the app are used to\r\nreduce the number of combinations with the help of a solver. All conducted experiments\r\ncorroborate the e↵ectiveness and eciency of SIG-Droid and TrimDroid.', NULL);
INSERT INTO `list` VALUES (601, '2017-02-01', 2016, 'inproceedings', 'Hua Zhong, Lingming Zhang, Sarfraz Khurshid', 'Combinatorial Generation of Structurally Complex Test Inputs for Commercial Software Applications', 'Application', '', '2016 International Symposium on Foundations of Software Engineering', 'FSE', '', '', '981-986', 'ACM', '10.1145/2950290.2983959', 'Combinatorial Testing', 'Despite recent progress in automated test generation research, significant challenges remain for applying these techniques on large-scale software systems. These systems under test often require structurally complex test inputs within a large input domain. It is challenging to automatically generate a reasonable number of tests that are both legal and behaviorally-diverse to exercise these systems. Constraint-based test generation is an effective approach for generating structurally complex inputs for systematic testing. While this approach can typically generate large numbers of tests, it has limited scalability – tests generated are usually only up to a small bound on input size. Combinatorial test generation, e.g., pair-wise testing, is a more scalable approach but is challenging to apply on commercial software systems that require complex input structures that cannot be formed by using arbitrary combinations. This paper introduces comKorat, which unifies constraint-based generation of structurally complex tests with combinatorial testing. Specifically, comKorat integrates Korat and ACTS test generators to generate test suites for large scale software systems with structurally complex test inputs. We have successfully applied comKorat on four software applications developed at eBay and Yahoo!. The experimental results show that comKorat outperforms existing solutions in execution time and test coverage. Furthermore, comKorat found a total of 59 previously unknown bugs in the four applications.', NULL);
INSERT INTO `list` VALUES (603, '2017-02-01', 2016, 'inproceedings', 'Eun-Hye Choi, Cyrille Artho, Takashi Kitamura, Osamu Mizuno, Akihisa Yamada', 'Distance-Integrated Combinatorial Testing', 'Generation', 'Priority', '2016 International Symposium on Software Reliability Engineering', 'ISSRE', '', '', '93-104', 'IEEE', '10.1109/ISSRE.2016.26', 'Combinatorial Testing', 'This paper proposes a novel approach to combinatorial test generation, which achieves an increase of not only the number of new combinations but also the distance between test cases. We applied our distance-integrated approach to a state-of-the-art greedy algorithm for traditional combinatorial test generation by using two distance metrics, Hamming distance, and a modified chi-square distance. Experimental results using numerous benchmark models show that combinatorial test suites generated by our approach using both distance metrics can improve interaction coverage for higher interaction strengths with low computational overhead.', NULL);
INSERT INTO `list` VALUES (604, '2017-02-01', 2017, 'article', 'Kamal Z. Zamli, Fakhrud Din, Salmi Baharom, Bestoun S. Ahmed', 'Fuzzy adaptive teaching learning-based optimization strategy for the problem of generating mixed strength t-way test suites', 'Generation', 'Search Based', '2017 Engineering Applications of Artificial Intelligence', 'other', '59', '', '35-50', 'Elsevier', '10.1016/j.engappai.2016.12.014', 'Combinatorial Testing', 'The teaching learning-based optimization (TLBO) algorithm has shown competitive performance in solving numerous real-world optimization problems. Nevertheless, this algorithm requires better control for exploitation and exploration to prevent premature convergence (i.e., trapped in local optima), as well as enhance solution diversity. Thus, this paper proposes a new TLBO variant based on Mamdani fuzzy inference system, called ATLBO, to permit adaptive selection of its global and local search operations. In order to assess its performances, we adopt ATLBO for the mixed strength t-way test generation problem. Experimental results reveal that ATLBO exhibits competitive performances against the original TLBO and other meta-heuristic counterparts.', NULL);
INSERT INTO `list` VALUES (605, '2017-02-01', 2016, 'inproceedings', 'Huiyan Wang, Chang Xu, Jun Sui, Jian Lu', 'How Effective is Branch-Based Combinatorial Testing? An Exploratory Study', 'Evaluation', '', '2016 International Conference on Software Quality, Reliability and Security', 'QRS', '', '', '41-52', 'IEEE', '10.1109/QRS.2016.15', 'Combinatorial Testing', 'Combinatorial testing detects faults by trying different value combinations for program inputs. Traditional combinatorial testing treats programs as black box and focuses on manipulating program inputs (named input-based combinatorial testing or ICT). In this paper, we explore the possibility of conducting combinatorial testing via white-box branch information. Similarly, different combinations of branches taken in an execution are tried to test whether they help detect faults and to what extent. We name this technique branch-based combinatorial testing (BCT). We propose ways to address challenges in realizing BCT, and evaluate BCT with Java programs. The results reported that BCT can effectively detect faults even with low-level combinations, say 3-4 ways, which suggest it to be a strong test adequacy criterion. We also found that our greedy strategy for minimizing test suites reduces over 50% tests for reaching certain way levels, and merging nested branches detects faults more cost-effectively than considering them separately.', NULL);
INSERT INTO `list` VALUES (606, '2017-02-01', 2016, 'inproceedings', 'ThanhVu Nguyen, Ugur Koc, Javran Cheng, Jeffrey S. Foster, Adam Porter', 'iGen: dynamic interaction inference for configurable software', 'Model', '', '2016 International Symposium on Foundations of Software Engineering', 'FSE', '', '', '655-665', 'ACM', '10.1145/2950290.2950311', 'Combinatorial Testing', 'To develop, analyze, and evolve today\'s highly configurable software systems, developers need deep knowledge of a system\'s configuration options, e.g., how options need to be set to reach certain locations, what configurations to use for testing, etc. Today, acquiring this detailed information requires manual effort that is difficult, expensive, and error prone. In this paper, we propose iGen, a novel, lightweight dynamic analysis technique that automatically discovers a program\'s \\emph{interactions}---expressive logical formulae that give developers rich and detailed information about how a system\'s configuration option settings map to particular code coverage. iGen employs an iterative algorithm that runs a system under a small set of configurations, capturing coverage data; processes the coverage data to infer potential interactions; and then generates new configurations to further refine interactions in the next iteration. We evaluated iGen on 29 programs spanning five languages; the breadth of this study would be unachievable using prior interaction inference tools. Our results show that iGen finds precise interactions based on a very small fraction of the number of possible configurations. Moreover, iGen\'s results confirm several earlier hypotheses about typical interaction distributions and structures.', NULL);
INSERT INTO `list` VALUES (609, '2017-02-01', 2016, 'article', 'Sagar Sen, Dusica Marijan, Carlo Ieva, Astrid Grime, Atle Sander', 'Modeling and Verifying Combinatorial Interactions to Test Data Intensive Systems: Experience at the Norwegian Customs Directorate', 'Evaluation', '', '2016 IEEE Transactions on Reliability', 'Trans. Rel', '', '', 'in press', 'IEEE', '10.1109/TR.2016.2618121', 'Combinatorial Testing', 'Data-intensive systems in e-governance collect and process data to ensure conformance to a set of business rules. Testers meticulously verify data in test databases, extracted from different steps of a live production stream , for correct application of business rules. We simplify the process by allowing testers to model a test domain on a relational database and automatically generate test cases representing data interactions satisfying combinatorial interaction coverage criteria. This paper also introduces test cases with self-referential interactions, which is a necessity in real-world databases. We verify these test cases using our human-in-the-loop tool, Depict. Depict, with expert assistance, generates complex SQL queries for test cases and produces a visual report of test case satisfaction. We apply the approach to two scenarios: 1) simplify and optimize a periodic archiving operation and 2) verify fault codes within the testing environment of the Custom directorate\'s TVINN system.', NULL);
INSERT INTO `list` VALUES (612, '2017-02-01', 2016, 'inproceedings', 'Eun-Hye Choi, Shunya Kawabata, Osamu Mizuno, Cyrille Artho, Takashi Kitamura', 'Test Effectiveness Evaluation of Prioritized Combinatorial Testing: A Case Study', 'Evaluation', 'Priority', '2016 International Conference on Software Quality, Reliability and Security', 'QRS', '', '', '61-68', 'IEEE', '10.1109/QRS.2016.17', 'Combinatorial Testing', 'Combinatorial testing is a widely-used technique to detect system interaction failures. To improve test effectiveness with given priority weights of parameter values in a system under test, prioritized combinatorial testing constructs test suites where highly weighted parameter values appear earlier or more frequently. Such order-focused and frequency-focused combinatorial test generation algorithms have been evaluated using metrics called weight coverage and KL divergence but not sufficiently with fault detection effectiveness so far. We evaluate the fault detection effectiveness on a collection of open source utilities, applying prioritized combinatorial test generation and investigating its correlation with weight coverage and KL divergence.', NULL);
INSERT INTO `list` VALUES (613, '2017-02-01', 2016, 'inproceedings', 'Zachary B. Ratliff, D. Richard Kuhn, Raghu N. Kacker, Yu Lei, Kishor S. Trivedi', 'The Relationship between Software Bug Type and Number of Factors Involved in Failures', 'Evaluation', '', '2016 International Symposium on Software Reliability Engineering Workshops', 'ISSREW', '', '', '119-124', 'IEEE', '10.1109/ISSREW.2016.26', 'Combinatorial Testing', 'Previous studies have defined different types of software bugs based on their complexity and reproducibility. Simple bugs, which involve only direct factors and are often easy to reproduce, have been called Bohrbugs, while complex bugs, with at least one indirect factor and generally much more difficult to reproduce, are called Mandelbugs. Locating Mandelbugs in software is often difficult and expensive during the development phase due to their complexity. In this paper we consider the relationship between different types of software bugs and the average t-way interaction involved in triggering them. Analysis suggests that Mandelbugs have a higher interaction strength when triggering their faults. This suggests that both direct and indirect factors play a role in triggering the fault. By using combinatorial testing methods, we can have high assurance of locating Mandelbugs as long as the indirect factors are present at the time of testing.', NULL);
INSERT INTO `list` VALUES (614, '2017-02-01', 2015, 'inproceedings', 'Hiroyuki Nakagawa, Tatsuhiro Tsuchiya', 'Towards Automatic Constraint Elicitation in Test Design: Preliminary Evaluation Based on Collective Intelligence', 'Model', 'Constraint', '2015 International Conference on Automated Software Engineering Workshop', 'other', '', '', '58-61', 'IEEE', '10.1109/ASEW.2015.13', 'Combinatorial Testing', 'Constraint elicitation is an important process in test design since constraints determine the test space, however, the constraint elicitation process, which is known as a daunting task, has not been well studied. It usually requires manual capturing and precise definition of constraints. In this paper, we try to automate a part of the constraint elicitation process in combinatorial test design. Pair-wise testing, a common combinatorial testing approach, is an effective test planning technique for finding interaction faults using a small set of test cases. We propose a collective intelligence approach to determining which value combinations are potential constraints. We conduct preliminary experiments on two examples, a traditional cross-browser testing example and an ATM system example, and evaluate the feasibility of our approach.', NULL);
INSERT INTO `list` VALUES (615, '2017-02-01', 2016, 'inproceedings', 'Angelo Gargantini, Justyna Petke, Marco Radavelli, Paolo Vavassori', 'Validation of Constraints Among Configuration Parameters Using Search-Based Combinatorial Interaction Testing', 'Model', 'Search Based, Constraint', '2016 International Symposium on Search Based Software Engineering', 'SSBSE', '', '', '49-63', 'Springer', '10.1007/978-3-319-47106-8_4', 'Combinatorial Testing', 'The appeal of highly-configurable software systems lies in their adaptability to users’ needs. Search-based Combinatorial Interaction Testing (CIT) techniques have been specifically developed to drive the systematic testing of such highly-configurable systems. In order to apply these, it is paramount to devise a model of parameter configurations which conforms to the software implementation. This is a non-trivial task. Therefore, we extend traditional search-based CIT by devising 4 new testing policies able to check if the model correctly identifies constraints among the various software parameters. Our experiments show that one of our new policies is able to detect faults both in the model and the software implementation that are missed by the standard approaches.', NULL);
INSERT INTO `list` VALUES (616, '2017-02-01', 2016, 'article', 'Xiaofang Qi, Jun He, Peng Wang, Huayang Zhou', 'Variable strength combinatorial testing of concurrent programs', 'Application', '', '2016 Frontiers of Computer Science', 'other', '10', '4', '631-643', 'Springer', '10.1007/s11704-016-5096-3', 'Combinatorial Testing', 'Reachability testing is an important approach to testing concurrent programs. It generates and exercises synchronization sequences automatically and on-the-fly without saving any test history. Existing reachability testing can be classified into exhaustive and t-way testing. Exhaustive testing is impractical in many cases while t-way testing may decrease the capability of fault detection in some cases. In this paper, we present a variable strength reachability testing strategy, which adopts the dynamic framework of reachability testing and uses a variable strength combinatorial strategy. Different parameter groups are provided with different covering strength. Variable strength testing covers no t-way combinations but the necessary combinations of parameters having mutual interactions in a concurrent program. It is more reasonable than t-way testing because uniform interactions between parameters do not often exist in concurrent systems. We propose a merging algorithmthat implements the variable strength combinatorial testing strategy and conduct our experiment on several concurrent programs. The experimental results indicate that our variable strength reachability testing reaches a good tradeoff between the effectiveness and efficiency. It can keep the same capability of fault detection as exhaustive reachability testing while substantially reducing the number of synchronization sequences and decreasing the execution time in most cases.', NULL);
INSERT INTO `list` VALUES (617, '2017-02-01', 2016, 'inproceedings', 'Ludwig Kampel, Dimitris E. Simos', 'Set-Based Algorithms for Combinatorial Test Set Generation', 'Generation', '', '2016 International Conference on Testing Software and Systems', 'ICTSS', '', '', '231-240', 'Springer', '10.1007/978-3-319-47443-4_16', 'Combinatorial Testing', 'Testing is an important and expensive part of software and hardware development. Over the recent years, the construction of combinatorial interaction tests rose to play an important role towards making the cost of testing more efficient. Covering arrays are the key element of combinatorial interaction testing and a means to provide abstract test sets. In this paper, we present a family of set-based algorithms for generating covering arrays and thus combinatorial test sets. Our algorithms build upon an existing mathematical method for constructing independent families of sets, which we extend sufficiently in terms of algorithmic design in this paper. We compare our algorithms against commonly used greedy methods for producing 3-way combinatorial test sets, and these initial evaluation results favor our approach in terms of generating smaller test sets.', NULL);
INSERT INTO `list` VALUES (619, '2017-02-01', 2016, 'inproceedings', 'Maria Spichkova, Anna Zamansky, Eitan Farchi', 'A Visual Logical Language for System Modelling in Combinatorial Test Design', 'Model', '', '2016 International Workshops on Advanced Information Systems Engineering', 'IWAISe', '', '', '116-121', 'Springer', '10.1007/978-3-319-39564-7_12', 'Combinatorial Testing', 'This position paper addresses some weaknesses of the standard logical languages used for specification of system models in combinatorial test design. To overcome these weaknesses, we propose a new logical language which uses visual elements with the aim to lower the cognitive load of the modeller and thereby reduce the risk of modelling errors.', NULL);
INSERT INTO `list` VALUES (622, '2017-02-01', 2016, 'inproceedings', 'Bestoun S. Ahmed, Luca M. Gambardella, Kamal Z. Zamli', 'A new approach to speed up combinatorial search strategies using stack and hash table', 'Generation', '', '2016 SAI Computing Conference', 'other', '', '', '1217-1222', 'IEEE', '10.1109/SAI.2016.7556133', 'Combinatorial Testing', 'Owing to the significance of combinatorial search strategies both for academia and industry, the introduction of new techniques is a fast growing research field these days. These strategies have really taken different forms ranging from simple to complex strategies in order to solve all forms of combinatorial problems. Nonetheless, despite the kind of problem these approaches solve, they are prone to heavy computation with the number of combinations and growing search space dimensions. This paper presents a new approach to speed up the generation and search processes using a combination of stack and hash table data structures. This approach could be put to practice for the combinatorial approaches to speed up the generation of combinations and search process in the search space. Furthermore, this new approach proved its performance in diverse stages better than other known strategies.\r\n', NULL);
INSERT INTO `list` VALUES (625, '2017-02-01', 2016, 'article', 'Sangeeta Sabharwal, Priti Bansal, Nitish Mittal', 'Construction of t-way covering arrays using genetic algorithm', 'Generation', 'Search Based', '2016 International Journal of System Assurance Engineering and Management', 'JSAEM', '', '', '1-11', 'Springer', '10.1007/s13198-016-0430-6', 'Combinatorial Testing', 'In a component based system, interaction among components may give rise to interaction faults. Faults can be caused by the interactions of two or more than two components. Since, it is not feasible to test all possible interactions combinatorial interaction testing is being employed to generate covering arrays (CAs) that covers all t-way interactions between components. In this paper, we generalize our previous work, that uses a greedy based genetic algorithm, to generate CA from 2-way to t-way testing (2 ≤ t ≤ 4). We implement the proposed strategy by extending an open source tool PWiseGen. The main drawback of PWiseGen is the need to input the size of CA in advance. To overcome this restriction of PWiseGen, we propose a variation of binary search algorithm that generates optimal CA without knowing its size in advance. Experiments are conducted to evaluate the effectiveness of the proposed approach and it has been observed that the proposed approach performs well as compared to existing state-of-the-art algorithms.', NULL);
INSERT INTO `list` VALUES (626, '2017-02-01', 2016, 'article', 'B.Narendra Kumar Rao, M.L. Madhuri', 'Coverage Metric on Combinatorial Test Cases of GUI Functional Testing', 'Application', '', '2016 Journal of Information Technology and Sciences', 'other', '1', '2', '1-17', '', 'not found', 'Combinatorial Testing', 'Users utilize GUI (Graphical User Interface) to communicate with the computing devices. Functional testing of GUI deals with how the specifications of the software component under test are tested. To represent the large number of events the covering arrays come into existence. Minimum size of the covering array is not known. The in-parameter-order generator algorithm and simplified swarm optimization algorithm are chosen and the global best test cases are selected in the Simplified Swarm Optimization Algorithm by using the weight factors. The test cases of two algorithms are considered in order to compare the performance of their test suites of two state model of GUI by using the concept of Uncovered Interaction Ratio. The Simplified Swarm Optimization Algorithm performs effective test case reduction.', NULL);
INSERT INTO `list` VALUES (627, '2017-02-01', 2016, 'inproceedings', 'Stefan Fischer, Roberto E. Lopez-Herrejon, Rudolf Ramler, Alexander Egyed', 'A preliminary empirical assessment of similarity for combinatorial interaction testing of software product lines', 'Evaluation', 'Software Product Line', '2016 International Workshop on Search-Based Software Testing', 'SBST', '', '', '15-18', 'ACM', '10.1145/2897010.2897011', 'Combinatorial Testing', 'Extensive work on Search-Based Software Testing for Software Product Lines has been published in the last few years. Salient among them is the use of similarity as a surrogate metric for t-wise coverage whenever higher strengths are needed or whenever the size of the test suites is infeasible because of technological or budget limitations. Though promising, this metric has not been assessed with real fault data. In this paper, we address this limitation by using Drupal, a widely used open source web content management system, as an industry-strength case study for which both variability information and fault data have been recently made available. Our preliminary assessment corroborates some of the previous findings but also raises issues on some assumptions and claims made. We hope our work encourages further empirical evaluations of Combinatorial Interaction Testing approaches for Software Product Lines.', NULL);
INSERT INTO `list` VALUES (628, '2017-02-01', 2016, 'inproceedings', 'Sompong Nakornburi, Taratip Suwannasart', 'Constrained Pairwise Test Case Generation Approach based on Statistical User Profile', 'Generation', 'Constraint', '2016 International Multi Conference of Engineers and Computer Scientists', 'other', '', '', '1-4', '', 'not found', 'Combinatorial Testing', 'Pairwise testing which is the most used of\r\ncombinatorial strategy has been shown to be a very effective\r\ntesting technique. An important problem in pairwise testing\r\ndeals with constraints and selects the optimal input parameters\r\nand values. This paper proposes an approach to select an\r\noptimal set of input parameters and values using statistical user\r\nprofile for pairwise test case generation and to apply constraint\r\nhandling to deal with unrealistic combinations. ', NULL);
INSERT INTO `list` VALUES (629, '2017-02-01', 2016, 'inproceedings', 'Maria Spichkova, Anna Zamansky', 'A Human-Centred Framework for Combinatorial Test Design', 'Application', '', '2016 International Conference on Evaluation of Novel Software Approaches to Software Engineering', 'other', '', '', '228-233', '', '10.5220/0005898202280233', 'Combinatorial Testing', 'This paper presents AHR, a formal framework for combinatorial test design that is Agile, Human-centred and\r\n\r\nRefinement-oriented. The framework (i) allows us to reuse test plans developed for an abstract level at more\r\n\r\nconcrete levels; (ii) has human-centric interface providing queries and alerts whenever the specified test plan\r\n\r\nis incomplete or invalid; (iii) involves analysis of the testing constraints within combinatorial testing.', NULL);
INSERT INTO `list` VALUES (630, '2017-02-01', 2016, 'inproceedings', 'Hanefi Mercan, Cemal Yilmaz', 'A constraint solving problem towards unified combinatorial interaction testing', 'Generation', 'Constraint', '2016 Workshop on Constraint Solvers in Testing, Verification, and Analysis', 'other', '', '', '1-7', '', 'not found', 'Combinatorial Testing', 'Combinatorial Interaction Testing (CIT) approaches aim to reveal failures caused by the interactions of factors, such as input parameters and configuration options. Our ultimate goal in this line of research is to improve the practicality of CIT approaches. To this end, we have been working on developing what we call Unified Combinatorial Interaction Testing (U-CIT), which not only represents most (if not all) combinatorial objects that have been developed so far, but also allows testers to develop their own application-specific combinatorial objects for testing. However, realizing U-CIT in practice requires us to solve an interesting constraint solving problem. In this work we informally define the problem and present a greedy algorithm to solve it. Our gaol is not so much to present a solution, but to introduce the problem, the solution of which (we believe) is of great practical importance.', NULL);
INSERT INTO `list` VALUES (631, '2017-02-01', 2016, 'article', 'Jose Torres-Jimenez, Himer Avila-George, Idelfonso Izquierdo-Marquez', 'A two-stage algorithm for combinatorial testing', 'Generation', 'Search Based', '2016 Optimization Letters', 'other', '', '', '1-13', 'Springer', '10.1007/s11590-016-1012-x', 'Combinatorial Testing', 'Covering arrays are combinatorial structures which have applications in fields like software testing and hardware Trojan detection. In this paper we proposed a two-stage simulated annealing algorithm to construct covering arrays. The proposed algorithm is instanced in this paper through the construction of ternary covering arrays of strength three. We were able to get 579 new upper bounds. In order to show the generality of our proposal, we defined a new benchmark composed of 25 instances of MCAs taken from the literature, all instances were improved.', NULL);
INSERT INTO `list` VALUES (632, '2017-02-01', 2016, 'inproceedings', 'Ruizhi Gao, Linghuan Hu, W. Eric Wong, Han-Lin Lu, Shih-Kun Huang', 'Effective Test Generation for Combinatorial Decision Coverage', 'Generation', '', '2016 International Conference on Software Quality, Reliability and Security Companion', 'QRS-C', '', '', '47-54', 'IEEE', '10.1109/QRS-C.2016.11', 'Combinatorial Testing', 'Complex software systems present significant challenges to existing software testing techniques. Simply applying exhaustive testing will lead to the execution of a prohibitively large number of test cases. Furthermore, many testing techniques today provide neither promising coverage achievement nor reliable fault detection strength. In this paper, we propose a technique, which represents an innovative synthesis of combinatorial testing and symbolic execution, to generate test cases based on a novel coverage criterion, namely combinatorial decision coverage (CDC). Strength t (or t-way) CDC requires each t-tuple of decision outcomes to be executed by at least one test case. Given a program, our CDC-based technique first uses a revised version of a symbolic executor, S2E, to collect all program decisions with symbolic variables as well as their corresponding constraints and then applies a combinatorial test generation tool, ACTS, to generate t-way combinations for the outcomes of these decisions. A test case can be generated with respect to each combination that represents a single path-condition of the program. Case studies were conducted on three versions of photo editing applications. Our results indicate that a test set generated using the proposed technique has higher statement, decision, and all use coverage as well as better fault detection strength than a test set of the same size generated by random testing and genetic algorithm-based test generation.', NULL);
INSERT INTO `list` VALUES (635, '2017-02-01', 2016, 'article', 'Dimitris E. Simos, D. Richard Kuhn, Artemios G. Voyiatzis, Raghu N. Kacker', 'Combinatorial Methods in Security Testing', 'Application', '', '2016 IEEE Computer', 'Computer', '49', '10', '80-83', 'IEEE', '10.1109/MC.2016.314', 'Combinatorial Testing', 'This article introduces combinatorial testing-based approaches for security testing and presents case studies and experiences. The success of the presented research program motivates further intensive research on the field of combinatorial security testing. In particular, security testing for the Internet of Things (IoT) is an area where these approaches may prove particularly useful. IoT systems send and receive data from a large (often continually changing) set of interacting devices and the number of potential communicating pairs increases with the square of the number of devices. Combinatorial methods are ideally suited for the IoT environment, where testing can involve a very large number of nodes and combinations.', NULL);
INSERT INTO `list` VALUES (636, '2017-02-01', 2016, 'article', 'Wei-Tek Tsai, Guanqiu Qi', 'Integrated fault detection and test algebra for combinatorial testing in TaaS (Testing-as-a-Service)', 'Application', '', '2016 Simulation Modelling Practice and Theory', 'other', '68', '', '108-124', 'Elsevier', '10.1016/j.simpat.2016.08.003', 'Combinatorial Testing', 'Testing-as-a-Service (TaaS) is a software testing service in a cloud that can leverage the computation power provided by the cloud. Specifically, a TaaS can be scaled to large and dynamic workloads, executed in a distributed environment with hundreds of thousands of processors, and these processors may support concurrent and distributed test execution and analysis. This paper proposes a TaaS system based on Adaptive Reasoning (AR) and Test Algebra (TA) for Combinatorial Testing (CT). AR performs testing and identifies faulty interactions, and TA eliminates related configurations from testing and there can be carried out concurrently. By combining these two, it is possible to perform large CT that were not possible before. Specifically, we performed experiments with 250 components with 2.83*1087 6-way interactions with about \r\n configurations, and this may be the largest CT experimentation as 2014. 98.6% of configurations have been eliminated out of total number of configurations.', NULL);
INSERT INTO `list` VALUES (637, '2017-02-01', 2016, 'inproceedings', 'Xuelin Li, Ruizhi Gao, W. Eric Wong, Chunhui Yang, Dong Li', 'Applying Combinatorial Testing in Industrial Settings', 'Application', '', '2016 International Conference on Software Quality, Reliability and Security', 'QRS', '', '', '53-60', 'IEEE', '10.1109/QRS.2016.16', 'Combinatorial Testing', 'Combinatorial testing (CT) is a black-box-based technique to generate a small number of test cases with a focus on covering various interactions among input parameters of a software system. How effective is CT in practice? What are the challenges and issues presented by the process of applying CT? How can these challenges and issues be overcome to improve the application of CT? Although CT has attracted attention from both academia and industry, these questions have not been addressed or researched in depth based on an empirical study in industrial settings. From January 2016 to February 2016, we have worked with CEPREI, an authoritative software testing company in China, on testing three real-life software systems using CT. Throughout the process, we have generated 601 test cases and found 33 bugs in total. The results demonstrate that CT not only detects more bugs but also requires less time in designing test cases for a specific system comparing to traditional function coverage-based testing. This paper will present our empirical study thoroughly and give an insightful analysis to investigate the advantages as well as the possible challenges of applying CT.', NULL);
INSERT INTO `list` VALUES (638, '2017-02-01', 2016, 'inproceedings', 'Dimitris E. Simos, Kristoffer Kleine, Laleh Sh. Ghandehari, Bernhard Garn, Yu Lei', 'A Combinatorial Approach to Analyzing Cross-Site Scripting (XSS) Vulnerabilities in Web Application Security Testing', 'Application', '', '2016 IFIP International Conference on Testing Software and Systems', 'ICTSS', '', '', '70-85', 'Springer', '10.1007/978-3-319-47443-4_5', 'Combinatorial Testing', 'Web applications typically employ sanitization functions to sanitize user inputs, independently whether this input is assumed to be legitimate, invalid or malicious. When such functions do not work correctly, a web application immediately becomes vulnerable to security attacks such as XSS. In this paper, we report a combinatorial approach to analyze XSS vulnerabilities in web applications. Our approach first performs combinatorial testing where a set of test vectors is executed against a subject application. If one or more XSS vulnerabilities are triggered during testing, we analyze the structure of each test vector to identify XSS-inducing combinations of its parameter model. If an attack vector contains an XSS-inducing combination, then the execution of this vector will successfully exploit an XSS vulnerability. Identification of XSS-inducing combinations provides insights about which kinds of user input might still be leverageable for XSS attacks and how to correct the function to provide better security guarantees. We conducted an experiment in which our approach was applied to four sanitization functions from the Web Application Vulnerability Scanner Evaluation Project (WAVSEP). The experimental results show that our approach can effectively identify XSS-inducing combinations for these sanitization functions.', NULL);
INSERT INTO `list` VALUES (639, '2017-02-01', 2016, 'article', 'Wei Zheng, Xiaoxue Wu, Desheng Hu, Qihai Zhu', 'Locating Minimal Fault Interaction in Combinatorial Testing', 'Diagnosis', '', '2016 Advances in Software Engineering', 'ASE', '', '', 'ID.2409521', '', '10.1155/2016/2409521', 'Combinatorial Testing', 'Combinatorial testing (CT) technique could significantly reduce testing cost and increase software system quality. By using the test suite generated by CT as input to conduct black-box testing towards a system, we are able to detect interactions that trigger the system’s faults. Given a test case, there may be only part of all its parameters relevant to the defects in system and the interaction constructed by those partial parameters is key factor of triggering fault. If we can locate those parameters accurately, this will facilitate the software diagnosing and testing process. This paper proposes a novel algorithm named complete Fault Interaction Location (comFIL) to locate those interactions that cause system’s failures and meanwhile obtains the minimal set of target interactions in test suite produced by CT. By applying this method, testers can analyze and locate the factors relevant to defects of system more precisely, thus making the process of software testing and debugging easier and more efficient. The results of our empirical study indicate that comFIL performs better compared with known fault location techniques in combinatorial testing because of its improved effectiveness and precision.', NULL);
INSERT INTO `list` VALUES (640, '2017-02-01', 2016, 'article', 'Wenhua Wang, Sreedevi Sampath, Yu Lei, Raghu N. Kacker, D. Richard Kuhn, James Lawrence', 'Using combinatorial testing to build navigation graphs for dynamic web applications', 'Application', '', '2016 Software Testing, Verification and Reliability', 'STVR', '26', '4', '318-346', 'Wiley', '10.1002/stvr.1599', 'Combinatorial Testing', 'Modelling a software system is often a challenging prerequisite to automatic test case generation. Modelling the navigation structure of a dynamic web application is particularly challenging because of the presence of a large number of pages that are created dynamically and the difficulty of reaching a dynamic page unless a set of appropriate input values are provided for the parameters. To address the first challenge, some form of abstraction is required to enable scalable modelling. For the second challenge, techniques are required to select appropriate input values for parameters and systematically combine them to reach new pages. This paper presents a combinatorial approach in building a navigation graph for dynamic web applications. The navigation graph can then be used to automatically generate test sequences for testing web applications. The novelty of our approach is twofold. First, we use an abstraction scheme to control the page explosion problem, where pages that are likely to have the same navigation behaviour are grouped together and are represented as a single node in the navigation graph. Second, assuming that values of individual parameters are supplied manually or generated from other techniques, we combine parameter values such that well-defined combinatorial coverage of input parameter values is achieved. Using combinatorial coverage can significantly reduce the number of requests that have to be submitted while still achieving effective coverage of the navigation structure. We implement our combinatorial approach in a tool, Tansuo, and apply the tool on seven open-source web applications. We evaluate the effectiveness of Tansuo\'s exploration process guided by t-way coverage, for t = 1,2,3, with respect to code coverage, and find that the navigation structure exploration by Tansuo, in general, results in high code coverage (more than 80% statement coverage for most of our subject applications when dead code is removed). We compare Tansuo\'s effectiveness with two other navigation graph tools and find that Tansuo is more effective. Our empirical results indicate that using pairwise coverage in Tansuo results in the efficient generation of navigation graphs and effective exploration of dynamic web applications. Copyright © 2016 John Wiley & Sons, Ltd.', NULL);
INSERT INTO `list` VALUES (641, '2017-02-01', 2017, 'article', 'Xiaofang Qi, Ziyuan Wang, Junqiang Mao, Peng Wang', 'Automated Testing of Web Applications Using Combinatorial Strategies', 'application', '', '2017 Journal of Computer Science and Technology', 'JCS&T', '32', '1', '199-210', 'Springer', '10.1007/s11390-017-1699-x', 'Combinatorial Testing', 'Recently, testing techniques based on dynamic exploration, which try to automatically exercise every possible user interface element, have been extensively used to facilitate fully testing web applications. Most of such testing tools are however not effective in reaching dynamic pages induced by form interactions due to their emphasis on handling client-side scripting. In this paper, we present a combinatorial strategy to achieve a full form test and build an automated test model. We propose an algorithm called pairwise testing with constraints (PTC) to implement the strategy. Our PTC algorithm uses pairwise coverage and handles the issues of semantic constraints and illegal values. We have implemented a prototype tool ComjaxTest and conducted an empirical study on five web applications. Experimental results indicate that our PTC algorithm generates less form test cases while achieving a higher coverage of dynamic pages than the general pairwise testing algorithm. Additionally, our ComjaxTest generates a relatively complete test model and then detects more faults in a reasonable amount of time, as compared with other existing tools based on dynamic exploration.', NULL);
INSERT INTO `list` VALUES (642, '2017-05-09', 2017, 'article', 'Kamal Z. Zamli, Fakhrud Din, Graham Kendall, Bestoun S. Ahmed', 'An experimental study of hyper-heuristic selection and acceptance mechanism for combinatorial t-way test suite generation', 'Generation', 'Search Based', '2017 Information Sciences', 'INFS', '399', '', '121-153', 'Elsevier', '10.1016/j.ins.2017.03.007', 'Combinatorial Testing', 'Recently, many meta-heuristic algorithms have been proposed to serve as the basis of a t-way test generation strategy (where t indicates the interaction strength) including Genetic Algorithms (GA), Ant Colony Optimization (ACO), Simulated Annealing (SA), Cuckoo Search (CS), Particle Swarm Optimization (PSO), and Harmony Search (HS). Although useful, meta-heuristic algorithms that make up these strategies often require specific domain knowledge in order to allow effective tuning before good quality solutions can be obtained. Hyper-heuristics provide an alternative methodology to meta-heuristics which permit adaptive selection and/or generation of meta-heuristics automatically during the search process. This paper describes our experience with four hyper-heuristic selection and acceptance mechanisms namely Exponential Monte Carlo with counter (EMCQ), Choice Function (CF), Improvement Selection Rules (ISR), and newly developed Fuzzy Inference Selection (FIS), using the t-way test generation problem as a case study. Based on the experimental results, we offer insights on why each strategy differs in terms of its performance.\r\n\r\n', NULL);
INSERT INTO `list` VALUES (643, '2017-05-09', 2016, 'inproceedings', 'Yasmeen Akhtar, Soumen Maity, Reshma C. Chandrasekharan', 'Generating Test Suites with High 3-Way Coverage for Software Testing', 'Generation', '', '2016 International Conference on Computer and Information Technology ', 'ICCIT', '', '', '10-17', 'IEEE', '10.1109/CIT.2016.89', 'Combinatorial Testing', 'Software testing is the process of executing a program or system with the intent of finding errors. Budgets assigned for software testing are generally limited. Performing exhaustive testing which tests all possible input combinations (test cases) is practically impossible. A major challenge in testing is how to achieve maximum test coverage using limited number of test cases. In this article, we propose an algebraic method of creating test suites with high 3-way configuration coverage within a fixed number of test cases.', NULL);
INSERT INTO `list` VALUES (644, '2017-05-09', 2017, 'article', 'Bestoun S. Ahmed, Luca M. Gambardella, Wasif Afzal, Kamal Z. Zamli', 'Handling constraints in combinatorial interaction testing in the presence of multi objective particle swarm and multithreading', 'Generation', 'Search Based, Constraint', '2017 Information and Software Technology', 'IST', '86', '', '20-36', 'Elsevier', '10.1016/j.infsof.2017.02.004', 'Combinatorial Testing', 'Context: Combinatorial testing strategies have lately received a lot of attention as a result of their diverse applications. In its simple form, a combinatorial strategy can reduce several input parameters (configurations) of a system into a small set based on their interaction (or combination). In practice, the input configurations of software systems are subjected to constraints, especially in case of highly configurable systems. To implement this feature within a strategy, many difficulties arise for construction. While there are many combinatorial interaction testing strategies nowadays, few of them support constraints. Objective: This paper presents a new strategy, to construct combinatorial interaction test suites in the presence of constraints. Method: The design and algorithms are provided in detail. To overcome the multi-judgment criteria for an optimal solution, the multi-objective particle swarm optimization and multithreading are used. The strategy and its associated algorithms are evaluated extensively using different benchmarks and comparisons. Results: Our results are promising as the evaluation results showed the efficiency and performance of each algorithm in the strategy. The benchmarking results also showed that the strategy can generate constrained test suites efficiently as compared to state-of-the-art strategies. Conclusion: The proposed strategy can form a new way for constructing of constrained combinatorial interaction test suites. The strategy can form a new and effective base for future implementations.', NULL);
INSERT INTO `list` VALUES (645, '2017-05-09', 2012, 'article', 'Sreedevi Sampath, Renée C. Bryce', 'Improving the effectiveness of test suite reduction for user-session-based testing of web applications', 'Application', '', '2012 Information and Software Technology', 'IST', '54', '7', '724-738', 'Elsevier', '10.1016/j.infsof.2012.01.007', 'Combinatorial Testing', 'Context\r\nTest suite reduction is the problem of creating and executing a set of test cases that are smaller in size but equivalent in effectiveness to an original test suite. However, reduced suites can still be large and executing all the tests in a reduced test suite can be time consuming.\r\n\r\nObjective\r\nWe propose ordering the tests in a reduced suite to increase its rate of fault detection. The ordered reduced test suite can be executed in time constrained situations, where, even if test execution is stopped early, the best test cases from the reduced suite will already be executed.\r\n\r\nMethod\r\nIn this paper, we present several approaches to order reduced test suites using experimentally verified prioritization criteria for the domain of web applications. We conduct an empirical study with three subject applications and user-session-based test cases to demonstrate how ordered reduced test suites often make a practical contribution. To enable comparison between test suites of different sizes, we develop Mod_APFD_C, a modification of the traditional prioritization effectiveness measure.\r\n\r\nResults\r\nWe find that by ordering the reduced suites, we create test suites that are more effective than unordered reduced suites. In each of our subject applications, there is at least one ordered reduced suite that outperforms the best unordered reduced suite and the best prioritized original suite.\r\n\r\nConclusions\r\nOur results show that when a tester does not have enough time to execute the entire reduced suite, executing an ordered reduced suite often improves the rate of fault detection. By coupling the underlying system’s characteristics with observations from our study on the criteria that produce the best ordered reduced suites, a tester can order their reduced test suites to obtain increased testing effectiveness.\r\n\r\n', NULL);
INSERT INTO `list` VALUES (646, '2017-05-09', 2017, 'article', 'Jose Torres-Jimenez, Arturo Rodriguez-Cristerna', 'Metaheuristic post-optimization of the NIST repository of covering arrays', 'Optimization', '', '2017 CAAI Transactions on Intelligence Technology', 'other', '2', '1', '31-38', 'Elsevier', '10.1016/j.trit.2016.12.006', 'Combinatorial Testing', 'Construction of Covering Arrays (CA) with minimum possible number of rows is challenging. Often the available CA have redundant combinatorial interaction that could be removed to reduce the number of rows. This paper addresses the problem of removing redundancy of CA using a metaheuristic post-optimization (MPO) approach. Our approach consists of three main components: a redundancy detector (RD); a row reducer (RR); and a missing-combinations reducer (MCR). The MCR is a metaheuristic component implemented using a simulated annealing algorithm. MPO was instantiated with \r\n CA taken from the National Institute of Standards and Technology (NIST) repository. It is a remarkable result that this instantiation of MPO has delivered 349 new upper bounds for these CA.', NULL);
INSERT INTO `list` VALUES (647, '2017-05-09', 2008, 'inproceedings', 'Alexander Pretschner, Tejeddine Mouelhi, Yves Le Traon', 'Model-Based Tests for Access Control Policies', 'Evaluation', '', '2008 International Conference on Software Testing, Verification and Validation', 'ICST', '', '', '338-347', 'IEEE', '10.1109/ICST.2008.44', 'Combinatorial Testing', 'We present a model-based approach to testing access control requirements. By using combinatorial testing, we first automatically generate test cases from and without access control policies-i.e., the model- and assess the effectiveness of the test suites by means of mutation testing. We also compare them to purely random tests. For some of the investigated strategies, non-random tests kill considerably more mutants than the same number of random tests. Since we rely on policies only, no information on the application is required at this stage. As a consequence, our methodology applies to arbitrary implementations of the policy decision points', NULL);
INSERT INTO `list` VALUES (648, '2017-05-09', 2017, 'inproceedings', 'D. Richard Kuhn, Raghu N. Kacker, Yu Lei', 'A Model for T-Way Fault Profile Evolution during Testing', 'Evaluation', '', '2017 International Workshop on Combinatorial Testing', 'IWCT', '', '', '162-170', 'IEEE', '10.1109/ICSTW.2017.35', 'Combinatorial Testing', 'Empirical studies have shown that most software interaction faults involve one or two variables interacting, with progressively fewer triggered by three to six variables interacting. This paper introduces a model for the origin of this distribution. We start with two empirically reasonable assumptions regarding the distribution of branch conditions in code and the proportion of t-way combinations seen in testing, and show that the model closely reproduces empirical data on t-way fault distributions. Although the model was developed to explain the distribution of faults by t-way interaction strength, it is shown to reproduce the basic exponential reliability model as a special case at each level of interaction, t. The paper evaluates model predictions against empirical data, and discusses implications for detection and removal of interaction faults.', NULL);
INSERT INTO `list` VALUES (649, '2017-05-09', 2017, 'inproceedings', 'Hermann Felbinger, Franz Wotawa, Mihai Nica', 'Mutation Score, Coverage, Model Inference: Quality Assessment for T-Way Combinatorial Test-Suites', 'Evaluation', '', '2017 International Workshop on Combinatorial Testing', 'IWCT', '', '', '171-180', 'IEEE', '10.1109/ICSTW.2017.36', 'Combinatorial Testing', 'In this paper we assess and evaluate the quality of t-way combinatorial test-suites using three different test-suite quality assessment methods. As t-way combinatorial test-suites reduce the input space of a program under test, we investigate how an increasing t affects the quality of the test-suite. There are some limitations of existing test-suite quality assessment methods e.g. the number of mutants is limited by execution time and code coverage measurement might be intrusive due to changes of the behavior of the program under test when instrumenting the code. Here we generate t-way combinatorial test-suites for Java programs of different size. We compute mutation score and code coverage for the generated test-suites, and apply additionally a new model inference based approach, that does not require to execute the program under test, to compare the generated test-suites with each other and assign a quality valuation to the test-suites. Our results show that an increasing t generally raises test-suite quality in terms of mutation score, coverage, and model inference. However, the model inference approach is only applicable, if the outcomes of the programs under test are discrete values, and if the number of discrete values is less than the test-suite size.', NULL);
INSERT INTO `list` VALUES (650, '2017-05-09', 2017, 'inproceedings', 'Feng Duan, Yu Lei, Linbin Yu, Raghu N. Kacker, D. Richard Kuhn', 'Optimizing IPOG\'s Vertical Growth with Constraints Based on Hypergraph Coloring', 'Generation', '', '2017 International Workshop on Combinatorial Testing', 'IWCT', '', '', '181-188', 'IEEE', '10.1109/ICSTW.2017.37', 'Combinatorial Testing', 'In this paper, we present an optimization of IPOG\'s vertical growth phase in the presence of constraints. The vertical growth problem is modeled as a classical NP-hard graph problem called \"Minimum Vertex Coloring\". In the graph model, vertices are either missing tuples that are waiting to be colored or existing tests that are already colored in different colors at the initial state, edges/hyperedges are conflicts among vertices that cannot be put in a same test. After coloring, a group of vertices in same color can be transformed to exactly a valid test. Since the original IPOG algorithm uses an arbitrary order to cover missing tuples during vertical growth, in order to reduce the number of tests, we compute the Degree of Conflicts (DOC) for each tuple, and cover the tuples in the non-increasing order of DOC. We implement a new IPOG algorithm incorporating this optimization. The experimental results show that the new IPOG algorithm reduces the number of tests for many real-life systems with constraints.', NULL);
INSERT INTO `list` VALUES (651, '2017-05-09', 2017, 'inproceedings', 'Macario Polo, Francisco Ruiz Romero, Rosana Rodriguez-Bobada Aranda, Ignacio Garcia Rodriguez', 'Test Case Generation with Regular Expressions and Combinatorial Techniques', 'Application', '', '2017 International Workshop on Combinatorial Testing', 'IWCT', '', '', '189-198', 'IEEE', '10.1109/ICSTW.2017.38', 'Combinatorial Testing', 'A test case describes a specific execution scenario of the system under test (SUT). Its goal is to discover errors by means of its oracle, that emits a pass or fail verdict depending on the SUT behavior. The test case has a sequence of calls to SUT\'s operations with specific test data, which may come from the application of a combinatorial algorithm. This paper describes a method to describe generic test scenarios by means of regular expressions, whose symbols point to a SUT operation. The tester assigns values to each operation\'s parameter. A further step expands the regular expression and produces a set of operation sequences, which are then passed to a combinatorial algorithm to generate actual test cases. Regular expressions are annotated with a set of when clauses, that are processed by the combinatorial algorithm to include the oracle in the generated test cases.', NULL);
INSERT INTO `list` VALUES (652, '2017-05-09', 2017, 'inproceedings', 'Chang Rao, Jin Guo, Nan Li, Yu Lei, Yadong Zhang, Yao Li, Yaxin Cao', 'Applying Combinatorial Testing to High-Speed Railway Track Circuit Receiver', 'Application', '', '2017 International Workshop on Combinatorial Testing', 'IWCT', '', '', '199-207', 'IEEE', '10.1109/ICSTW.2017.39', 'Combinatorial Testing', 'A track circuit is a critical component of a modern railway system. The circuit is used to detect the absence of a train on rail tracks and produce corresponding control signals. A railway track has many block sections, each of which has a separate track circuit device. A track circuit receiver analyzes signals sent from a track circuit sender and produces a signal to control a relay. When the train is in a section, the relay must be down, otherwise, the relay must be up. We tested a track circuit receiver product that is widely used in high-speed railways in China. We extracted three input parameters from a signal sent to the receiver and create an Input Domain Model (IDM). We generated pair-wise test sets using the IDM. Moreover, from the requirements, we derived two UML finite state machines (FSMs) in the presence of multiple signals. In the FSMs, a transition can represent a signal input to the system. We first generated test paths from the FSMs, and then applied combinatorial testing to the parameters used in the test paths. We generated a total of 13,971 tests, which allowed us to detect four new faults in a release version of the product.', NULL);
INSERT INTO `list` VALUES (653, '2017-05-09', 2017, 'inproceedings', 'Murat Ozcan', 'Applications of Practical Combinatorial Testing Methods at Siemens Industry Inc., Building Technologies Division', 'Application', '', '2017 International Workshop on Combinatorial Testing', 'IWCT', '', '', '208-215', 'IEEE', '10.1109/ICSTW.2017.40', 'Combinatorial Testing', 'The goal of software testing is to find defects before the product is released to the customer. Siemens has a Zero Defect Culture which strives to continuously improve our software testing methods. The current methods use automated testing and manual testing. This paper examines the use of mixed-strength covering arrays, resulting in requiring fewer tests for higher strength coverage. Using the Combinatorial Test Coverage Measurement command line version (CCM) developed by the National Institute of Standards and Technology (NIST), we found practical ways to measure the coverage percentage and the strength of covering arrays, as well as any given test suite. This enabled us to show where we are and the direction we should take with minimal cost improvements. We investigated combinatorial methods, the use of covering arrays for test inputs and test configurations, and methods to combine the two in various ways during the product life cycle. The goal was to craft the leanest and most impactful formal testing and devise optimal configurations for the system under test. In particular, we consider the problem of testing a large number of setup configurations where each configuration requires many tests. Tradeoffs for producing practical test sets are analyzed, with overall and minimum combinatorial coverage measured, demonstrating significant combinatorial coverage improvements while keeping test set size tractable.', NULL);
INSERT INTO `list` VALUES (654, '2017-05-09', 2017, 'inproceedings', 'Henning Bergstrom, Eduard Paul Enoiu', 'Using Timed Base-Choice Coverage Criterion for Testing Industrial Control Software', 'Application', '', '2017 International Workshop on Combinatorial Testing', 'IWCT', '', '', '216-219', 'IEEE', '10.1109/ICSTW.2017.41', 'Combinatorial Testing', 'The base-choice criterion was proposed as a suitable technique for testing software based on its nominal choice of input parameters. Test cases are created based on this strategy by varying the values of one input parameter at a time while keeping the values of the other parameters fixed on the base choice. However, this strategy might not be as effective when used on industrial control software for testing timed behavior. We propose to incorporate time as another parameter when generating and executing tests by defining the timed base-choice coverage criterion. We performed an empirical evaluation using 11 industrial programs written in the IEC 61131-3 programming language. We found that tests generated for timed base-choice criterion show better code coverage (7% improvement) and fault detection (27% improvement) in terms of mutation score than tests satisfying base-choice coverage criterion. The results demonstrate the feasibility of applying timed base-choice criterion for testing industrial control software.', NULL);
INSERT INTO `list` VALUES (655, '2017-05-09', 2017, 'inproceedings', 'Tatsuya Konishi, Hideharu Kojima, Hiroyuki Nakagawa, Tatsuhiro Tsuchiya', 'Finding Minimum Locating Arrays Using a SAT Solver', 'Generation', '', '2017 International Workshop on Combinatorial Testing', 'IWCT', '', '', '276-277', 'IEEE', '10.1109/ICSTW.2017.49', 'Combinatorial Testing', 'Locating arrays provide combinatorial test suites not only for detecting the presence of an interaction fault but also for locating the fault. Compared with test suites for ordinary combinatorial testing, however, the fault locating capability entails a substantial increase in the size of test suites. In this position paper, we consider the problem: how small can locating arrays be? To answer the question, we develop a method that finds a locating array of a given size using a SAT solver. We report the size of the smallest locating arrays discovered by using our method. This result provides the smallest known upper bound on the size of the minimum locating arrays.', NULL);
INSERT INTO `list` VALUES (656, '2017-05-09', 2017, 'inproceedings', 'Saritha Route', 'Test Optimization Using Combinatorial Test Design: Real-World Experience in Deployment of Combinatorial Testing at Scale', 'Application', '', '2017 International Workshop on Combinatorial Testing', 'IWCT', '', '', '278-279', 'IEEE', '10.1109/ICSTW.2017.50', 'Combinatorial Testing', 'Clients today want more for less and the IBM test mantra of Test Less Test Right helps address this ask by placing Combinatorial Test Design (CTD) at the heart of the solution. This document presents two case studies of CTD implementation in client engagements and focuses on the approach, process and challenges addressed to scale up the implementation and make CTD a mainstream activity. The IBM Focus tool was used in both cases to implement Combinatorial Test Design for optimization of tests and for reducing test effort while increasing test coverage.', NULL);
INSERT INTO `list` VALUES (657, '2017-05-09', 2017, 'inproceedings', 'Preeti Satish, Milind B., Medhini S. Narayan, Krishnan Rangarajan', 'Building Combinatorial Test Input Model from Use Case Artefacts', 'Model', '', '2017 International Workshop on Combinatorial Testing', 'IWCT', '', '', '220-228', 'IEEE', '10.1109/ICSTW.2017.42', 'Combinatorial Testing', 'Combinatorial Testing is a test design methodology that aims to detect the interaction failures existing in the software under test. The combinatorial input space model comprises of the parameters and the values it can take. Building this input space model is a domain knowledge and experience intensive task. The objective of the paper is to assist test designer in building this test model. A rule based semi-automatic approach is proposed to derive the input space model elements from Use case specifications and UML use case diagrams. A natural language processing based parser and an XMI based parser are implemented. The rules formulated are applied on synthetic case studies and the output model is evaluated using precision and recall metrics. The results are promising and this approach will be of good use to the test designer.', NULL);
INSERT INTO `list` VALUES (658, '2017-05-09', 2017, 'inproceedings', 'Ludwig Kampel, Bernhard Garn, Dimitris E. Simos', 'Combinatorial Methods for Modelling Composed Software Systems', 'Model', '', '2017 International Workshop on Combinatorial Testing', 'IWCT', '', '', '229-238', 'IEEE', '10.1109/ICSTW.2017.43', 'Combinatorial Testing', 'In this paper, we review and prove certain properties regarding t-way coverage when covering arrays are merged together to form larger arrays. Moreover, we build upon these theoretical observations to formulate a procedure on how, from the input space model of a composed SUT and t-way test suites for its components, to create a larger and unified t-way test suite. The proposed modelling methodologies for a composed SUT involve a hierarchy between the different input models of the components of the SUT, which is nested in such a way that it can be linked to certain combinatorial constructions for covering arrays. As a proof of concept of our modelling methodology, that arises from such combinatorial constructions, we apply it to a sample of composed SUTs to validate our approach in practice.', NULL);
INSERT INTO `list` VALUES (659, '2017-05-09', 2017, 'inproceedings', 'Angelo Gargantini, Justyna Petke, Marco Radavelli', 'Combinatorial Interaction Testing for Automated Constraint Repair', 'Model', 'Constraint', '2017 International Workshop on Combinatorial Testing', 'IWCT', '', '', '239-248', 'IEEE', '10.1109/ICSTW.2017.44', 'Combinatorial Testing', 'Highly-configurable software systems can be easily adapted to address user\'s needs. Modelling parameter configurations and their relationships can facilitate software reuse. Combinatorial Interaction Testing (CIT) methods are already often used to drive systematic testing of software system configurations. However, a model of the system\'s configurations not conforming with respect to its software implementation, must be repaired in order to restore conformance. In this paper we extend CIT by devising a new search-based technique able to repair a model composed of a set of constraints among the various software system\'s parameters. Our technique can be used to detect and fix faults both in the model and in the real software system. Experiments for five real-world systems show that our approach can repair on average 37% of conformance faults. Moreover, we also show it can infer parameter constraints in a large real-world software system, hence it can be used for automated creation of CIT models.', NULL);
INSERT INTO `list` VALUES (660, '2017-05-09', 2017, 'inproceedings', 'Anna Zamansky, Eitan Farchi, Sery Khoury, Amir Schwartz', 'A composition-based method for combinatorial test design', 'Model', '', '2017 International Workshop on Combinatorial Testing', 'IWCT', '', '', '249-252', 'IEEE', '10.1109/ICSTW.2017.45', 'Combinatorial Testing', 'The notion of composition in the context of combinatorial test design naturally arises in situations where the output of one module is used as an input to another module. Composability of tests plans has several important benefits as it facilitates both test and model reuse in such sequential scenarios. In this paper we describe a method for an automatic construction of composable tests plans, one by-product of which is a test plan for the SUT, obtained by their composition. The proposed method is implemented using binary decision diagrams (BDDs), which allows for an efficient and scalable composition-oriented CTD for real-life testing problems. We evaluate the method on a case study of a composition of two Unix Shell operations.', NULL);
INSERT INTO `list` VALUES (661, '2017-05-09', 2017, 'inproceedings', 'Jaganmohan Chandrasekaran, Huadong Feng, Yu Lei, D. Richard Kuhn, Raghu N. Kacker', 'Applying Combinatorial Testing to Data Mining Algorithms', 'Application', '', '2017 International Workshop on Combinatorial Testing', 'IWCT', '', '', '253-261', 'IEEE', '10.1109/ICSTW.2017.46', 'Combinatorial Testing', 'Data mining algorithms are used to analyze and discover useful information from data. This paper presents an experiment that applies Combinatorial Testing (CT) to five data mining algorithms implemented in an open-source data mining software called WEKA. For each algorithm, we first run the algorithm with 51 datasets to study the impact different datasets have on the test coverage. We select one dataset that achieves the highest branch coverage. Next we construct positive and negative combinatorial test sets of configuration options and execute each test set with the selected dataset. Test effectiveness is measured using branch and mutation coverage. Our results suggest that when testing data mining algorithms: (1) larger datasets do not necessarily achieve higher coverage than smaller datasets, (2) test coverage increases progressively slower as test strength increases, and (3) branch coverage correlates well with mutation coverage.', NULL);
INSERT INTO `list` VALUES (662, '2017-05-09', 2017, 'inproceedings', 'Xi Deng, Tianyong Wu, Jun Yan, Jian Zhang', 'Combinatorial Testing on Implementations of HTML5 Support', 'Application', '', '2017 International Workshop on Combinatorial Testing', 'IWCT', '', '', '262-271', 'IEEE', '10.1109/ICSTW.2017.47', 'Combinatorial Testing', 'The fifth version of HTML standard, which is widely accepted in the diverse landscape of browser vendors and their continuously upgrading releases, requires web browsers to support playback of multimedia natively, instead of by third-party plugins. Works on testing browsers\' implementations of the HTML5 support, however, are not efficient enough till now. Regarding a browser\'s processing on HTML5 element tags of web pages and attributes of multimedia files, this paper treats the browser as a parameterized black-box and employs the combinatorial testing technique to design web pages to test its system behavior. Experiments are conducted on two sets of browsers. The first set includes nine popular ones in both desktop and mobile for discovering the distribution of multimedia related errors, and the second set contains five versions of the same browser for revealing the evolution of such errors. The experimental results indicate that the proposed approach is promising as it can reveal errors in browsers by various vendors and in various versions, and that the upgrades of the browser will not necessarily fix the existing bugs, and even introduce new ones, due to inefficient testing.', NULL);
INSERT INTO `list` VALUES (663, '2017-05-09', 2017, 'inproceedings', 'Shaojiang Wang, Tianyong Wu, Yuan Yao, Beihong Jin, Liping Ding', 'Combinatorial Testing on MP3 for Audio Players', 'Application', '', '2017 International Workshop on Combinatorial Testing', 'IWCT', '', '', '273-275', 'IEEE', '10.1109/ICSTW.2017.48', 'Combinatorial Testing', 'Audio players form a type of frequently used software, in which there are still bugs. In this paper, we investigate the test on MP3 for audio player, a mainstream audio format. An MP3 file consists of ID3v2 tag and MPEG layer III frames, with which there are standards for them. We first introduce the standards through the official documents, then summarize several potentially error-prone points for audio players. For our purpose, we use two black-box test design methods, combinatorial testing namely (CT) and random testing (RT). We test 10 popular audio players and 4 web browser built-in players for supporting audio tag in html5 with these test cases and find 7 types of bugs. Our experimental results show that, although there are standards for ID3v2 tag and MPEG frames, different audio player implementors have different understanding and implementations. We also compare the bugs detected by the test cases with CT and RT.', NULL);
INSERT INTO `list` VALUES (664, '2017-08-30', 2017, 'inproceedings', 'Sergiy Vilkomir, Aparna Alluri, D. Richard Kuhn, Raghu N. Kacker', 'Combinatorial and MC/DC Coverage Levels of Random Testing', 'Evaluation', '', '2017 International Conference on Software Quality, Reliability and Security Companion', 'QRS-C', '', '', '61-68', 'IEEE', '10.1109/QRS-C.2017.19', 'Combinatorial Testing', 'Software testing criteria differ in their effectiveness, the numbers of test cases required, and the processes of test generation. Specific criteria often are compared to random testing, and in some cases, random testing shows a surprisingly high level of effectiveness. One reason that this is the case is that any random test set has a specific level of coverage according to any coverage criterion. Numerical evaluation of coverage levels of random testing according to various coverage criteria is an interesting research task and is important in understanding the relationship between different testing approaches. In this paper, we performed an experimental evaluation of the coverage levels of random testing for two criteria: MC/DC and combinatorial t-way testing. Our experiments showed that, when the number of random test cases increased, a high level of coverage was reached rapidly, both for MC/DC and t-way. However, many more random tests are required to reach 100% coverage. An unexpected result was that there were significant differences in the measurement of partial MC/DC coverage by various tools. The results may be used to select optimal methods for practical testing and develop new testing methods based on the integration of existing approaches.', NULL);
INSERT INTO `list` VALUES (665, '2017-08-30', 2017, 'inproceedings', 'M.S. Raunak, D. Richard Kuhn, Raghu N. Kacker', 'Combinatorial Testing of Full Text Search in Web Applications', 'Application', '', '2017 International Conference on Software Quality, Reliability and Security Companion', 'QRS-C', '', '', '100-107', 'IEEE', '10.1109/QRS-C.2017.24', 'Combinatorial Testing', 'Database driven web applications are some of the\r\nmost widely developed systems today. In this paper, we\r\ndemonstrate use of combinatorial testing for testing database\r\nsupported web applications, especially where full-text search\r\nis provided or many combinations of search options are\r\nutilized. We develop test-case selection techniques, where test\r\nstrings are synthesized using characters or string fragments\r\nthat may lead to system failure. We have applied our approach\r\nto the National Vulnerability Database (NVD) application and\r\nhave discovered a number of \"corner-cases\" that had not been\r\nidentified previously. We also present simple heuristics for\r\nisolating the fault causing factors that can lead to such system\r\nfailures. The test method and input model described in this\r\npaper have immediate application to other systems that\r\nprovide complex full text search', NULL);
INSERT INTO `list` VALUES (666, '2017-08-30', 2017, 'inproceedings', 'Miroslav Bures, Bestoun S. Ahmed', 'On the Effectiveness of Combinatorial Interaction Testing: A Case Study', 'Evaluation', '', '2017 International Conference on Software Quality, Reliability and Security Companion', 'QRS-C', '', '', '69-76', 'IEEE', '10.1109/QRS-C.2017.20', 'Combinatorial Testing', 'Combinatorial interaction testing (CIT) stands as one of the efficient testing techniques that have been used in different applications recently. The technique is useful when there is a need to take the interaction of input parameters into consideration for testing a system. The key insight the technique is that not every single parameter may contribute to the failure of the system and there could be interactions among these parameters. Hence, there must be combinations of these input parameters based on the interaction strength. This technique has been used in many applications to assess its effectiveness. In this paper, we are addressing the effectiveness of CIT for a real-world case study using model-based mutation testing experiments. The contribution of the paper is threefold: First we introduce an effective testing application for CIT; Second, we address the effectiveness of increasing the interaction strength beyond the pairwise (i.e., interaction of more than two parameters); Third, model-based mutation testing is used to mutate the input model of the program in contrast to the traditional code-based mutation testing process. Experimental results showed that CIT is an effective testing technique for this kind of application. In addition, the results also showed the usefulness of model-based mutation testing to assess CIT applications. For the subject of this case study, the results also indicate that 3-way test suite (i.e., interaction of three parameters) could detect new faults that can not be detected by pairwise.', NULL);
INSERT INTO `list` VALUES (667, '2017-08-30', 2017, 'inproceedings', 'Hanefi Mercan, Cemal Yilmaz, Kamer Kaya', 'An Approach for Choosing the Best Covering Array Constructor to Use', 'Generation', '', '2017 International Conference on Software Quality, Reliability and Security Companion', 'QRS-C', '', '', '77-84', 'IEEE', '10.1109/QRS-C.2017.21', 'Combinatorial Testing', 'Covering arrays have been extensively used for software testing. Therefore, many covering array constructors have been developed. However, each constructor comes with its own pros and cons. That is, the best constructor to use typically depends on the specific application scenario at hand. To improve both the efficiency and effectiveness of covering arrays, we, in this work, present a classification-based approach to predict the \"best\'\" covering array constructor to use for a given configuration space model, coverage strength, and optimization criterion, i.e., minimizing the construction time or the covering array size. We also empirically evaluate the proposed approach by using a relatively small, yet quite realistic space of application scenarios. The approach predicted the best constructors for reducing the construction times with an accuracy of 86% and the best constructors for reducing the covering array sizes with an accuracy 90%. When two predictions were made, rather than one, the accuracy of correctly predicting the best constructors increased to 94% and 98%, respectively.', NULL);
INSERT INTO `list` VALUES (668, '2017-08-30', 2017, 'inproceedings', 'Fakhrud Din, A.A. Alsewari, Kamal Z. Zamli', 'A Parameter Free Choice Function Based Hyper-Heuristic Strategy for Pairwise Test Generation', 'Generation', 'Search Based', '2017 International Conference on Software Quality, Reliability and Security Companion', 'QRS-C', '', '', '85-91', 'IEEE', '10.1109/QRS-C.2017.22', 'Combinatorial Testing', 'Hyper-heuristics are advanced high-level search methodologies that solve hard computational problems indirectly via low-level heuristics. Choice function based hyper-heuristics are selection and acceptance hyper-heuristics that use statistical information to rank low-level heuristics for selection. In this paper, we describe a choice function based hyper-heuristic called Pairwise Choice Function based Hyper-heuristic (PCFHH) for the pairwise test generation problem. PCFHH uses a combination of three measures to select and apply an effective low-level heuristic from a set of four low-level heuristics at any stage of the search. Our experimental results have been encouraging as PCFHH outperforms most of pairwise test generation strategies on many of the problem instances.', NULL);
INSERT INTO `list` VALUES (669, '2017-08-30', 2017, 'inproceedings', 'Sergiy Vilkomir, Jiabin Wang, Nam Le Thai, Junhua Ding', 'Combinatorial Methods of Feature Selection for Cell Image Classification', 'Application', 'Machine Learning', '2017 International Conference on Software Quality, Reliability and Security Companion', 'QRS-C', '', '', '55-60', 'IEEE', '10.1109/QRS-C.2017.18', 'Combinatorial Testing', 'Feature selection is a major task in machine learning for selecting the most impactful features that will result in better accuracy and performance. Experiment-based feature selection is one of the main approaches to this task. However, this approach is not feasible in many cases due to the large number of experiments needed in order to effectively select the optimized feature set. In this paper, we propose the use of an experiment based feature selection guided by combinatorial methods such as t-way coverage. This approach can significantly reduce the required number of experiments in a study while selecting the best feature set to achieve a high level of accuracy. We conducted a case study of the feature selection process for a Support Vector Machine (SVM) classification of biomedical images for cell typing. Three thousand labeled images were used in the experimental SVM classification, and 32 features were evaluated for each image. We considered feature sets of different sizes ranging from 6 to 32, and, for each size, we generated t- way combinations of features for t from 2 to 6. The accuracy of each combinatorial combination was evaluated, which allowed us to select the optimal set of features for use in the classification process. The experiment results show that the proposed approach is an effective way to conduct feature selection and that it can be adapted easily for feature selection in other machine learning algorithms.', NULL);
INSERT INTO `list` VALUES (670, '2017-08-30', 2017, 'inproceedings', 'Peter Charbachi, Linus Eklund, Eduard Enoiu', 'Can Pairwise Testing Perform Comparably to Manually Handcrafted Testing Carried Out by Industrial Engineers?', 'Evaluation', '', '2017 International Conference on Software Quality, Reliability and Security Companion', 'QRS-C', '', '', '92-99', 'IEEE', '10.1109/QRS-C.2017.23', 'Combinatorial Testing', 'Testing is an important activity in engineering of industrial software. For such software, testing is usually performed manually by handcrafting test suites based on specific design techniques and domain-specific experience. To support developers in testing, different approaches for producing good test suites have been proposed. In the last couple of years combinatorial testing has been explored with the goal of automatically combining the input values of the software based on a certain strategy. Pairwise testing is a combinatorial technique used to generate test suites by varying the values of each pair of input parameters to a system until all possible combinations of those parameters are created. There is some evidence suggesting that these kinds of techniques are efficient and relatively good at detecting software faults. Unfortunately, there is little experimental evidence on the comparison of these combinatorial testing techniques with, what is perceived as, rigorous manually handcrafted testing. In this study we compare pairwise test suites with test suites created manually by engineers for 45 industrial programs. The test suites were evaluated in terms of fault detection, code coverage and number of tests. The results of this study show that pairwise testing, while useful for achieving high code coverage and fault detection for the majority of the programs, is almost as effective in terms of fault detection as manual testing. The results also suggest that pairwise testing is just as good as manual testing at fault detection for 64% of the programs.', NULL);
INSERT INTO `list` VALUES (671, '2017-08-30', 2017, 'inproceedings', 'Yongming Yao, Yiyang Yan, Ziyuan Wang, Chen Liu', 'Design and Implementation of Combinatorial Testing Tools', 'Application', 'Tool', '2017 International Conference on Software Quality, Reliability and Security Companion', 'QRS-C', '', '', '320-325', 'IEEE', '10.1109/QRS-C.2017.61', 'Combinatorial Testing', 'As an effective software testing technique, combinatorial testing has been gradually applied in various types of test practice. In this case, it is necessary to provide useful combinatorial testing tools to support the application of combinatorial testing technique on industrial scenarios, as well as the academic research for combinatorial testing technique. To this end, on the basis of the research results of this group, a suite of combinatorial testing tools has been developed, whose functions include test case generation, test case optimization, and etc. For the requirements from both industrial and academic scenarios, the tools should be configurable, scalable, modular, and etc. This paper gives a brief introduction to the design and implementation of these tools. Keywords—combinatorial testing, combinatorial testing tools, test generation, test prioritization.', NULL);
INSERT INTO `list` VALUES (672, '2017-08-30', 2017, 'inproceedings', 'Dong Li, Linghuan Hu, Ruizhi Gao, W. Eric Wong, D. Richard Kuhn, Raghu N. Kacker', 'Improving MC/DC and Fault Detection Strength Using Combinatorial Testing', 'Evaluation', '', '2017 International Conference on Software Quality, Reliability and Security Companion', 'QRS-C', '', '', '297-303', 'IEEE', '10.1109/QRS-C.2017.131', 'Combinatorial Testing', 'Software, in many different fields and tasks, hasplayed a critical role and even replaced humans to improveefficiency and safety. However, catastrophic consequences can becaused by implementation bugs and design defects. Modifiedcondition/decision coverage (MC/DC), required by the FederalAviation Administration on Level A (the most safety criticalsystem), has been shown to be effective in detecting softwarebugs. However, generating tests to achieve high MC/DC can bevery expensive and time consuming. Recently, many studiesshowed that combinatorial testing (CT) could generate highqualitytest cases in a cost-effective way. Can CT generate testcases to achieve high MC/DC? In this paper, we conduct anempirical study on two real-life programs to evaluate theefficiency and effectiveness of using combinatorial testing toimprove MC/DC coverage achievement, as well as the faultdetection strength.', NULL);
INSERT INTO `list` VALUES (673, '2017-08-30', 2017, 'inproceedings', 'Kinari Nishiura, Eun-Hye Choi, Osamu Mizuno', 'Improving Faulty Interaction Localization Using Logistic Regression', 'Diagnosis', '', '2017 International Conference on Software Quality, Reliability and Security', 'QRS-C', '', '', '138-149', 'IEEE', '10.1109/QRS.2017.24', 'Combinatorial Testing', 'Combinatorial testing is a widely used technique to detect failures caused by interactions of system under test (SUT) parameters. Faulty interaction localization (FIL) is a problem to locate parameter-value combinations that trigger failures from combinatorial test cases and their testing results. FIL is important for debugging, but is expensive for large test suites and SUTs since the number of candidates of faulty interactions increases exponentially with the number of parameters and the size of interactions. To address this problem, this paper proposes a method employing logistic regression. The proposed FIL based on Regression coefficients Of loGistic regression analysis (called FROG) computes the suspiciousness of each parameter-value combination to be included in a faulty interaction from its corresponding regression coefficient. We evaluate the proposed method by applying FROG to combinatorial t-way test cases (2 ≤ t ≤ 4) for real application SUT models, e.g. TCAS, GCC, and Apache. Our experiment results show that FROG can effectively locate faulty interactions injected while efficiently reducing the number of candidates of potential faulty interactions to be checked.', NULL);
INSERT INTO `list` VALUES (674, '2017-08-30', 2017, 'article', 'Jose Carlos Perez-Torres, Jose Torres-Jimenez', 'A graph-based postoptimization approach for covering arrays', 'Generation', '', '2017 Quality and Reliability Engineering International', 'QREI', '', '', 'not found', 'Wiley', '10.1002/qre.2176', 'Combinatorial Testing', 'Covering arrays (CAs) are combinatorial objects with interesting features that have practical applications such as experimental design and fault detection in hardware and software. We introduce a graph-based postoptimization (GBPO) approach to reduce the size of CAs exploiting the redundancy in CAs previously constructed. To evidence the advantages of using GBPO, we have instantiated it with 2 sets of CAs: (1) 560 CAs of strength 2≤t≤6, alphabet 2≤v≤6, and parameters 3≤k≤32 generated by an optimized version of In-Parameter-Order-Generalized (IPOG-F) and GBPO improved all CAs, and 37 cases matched the best-known upper bounds; and (2) 32 CAs of strength t=2, alphabet 3≤v≤6, and number of parameters 8≤k≤146; in this set, 16 cases were improved, and 16 cases were matched.', NULL);
INSERT INTO `list` VALUES (675, '2017-08-30', 2017, 'article', 'Kai Cui, Kuanjiu Zhou, Tie Qiu, Mingchu Li, Leiming Yan', 'A hierarchical combinatorial testing method for smart phone software in wearable IoT systems', 'Application', '', '2017 Computers & Electrical Engineering', 'Comput. Electr. Eng', '61', '', '250-265', 'Elsevier', '10.1016/j.compeleceng.2017.06.004', 'Combinatorial Testing', 'As the Internet of Things technology is finding more wide applications; wearable smart systems such as smart phones have gradually come into our lives. The smart wearable systems with numerous states usually lead to various unanticipated problems. A connective and semantic similarity clustering algorithm (CSSCA) and a hierarchical combinatorial test model based on finite state machine (FSM) are proposed to solve the problem. The FSM model of user manipulations is usually used to model the system design specification of a smart phone for black-box testing, and then it is converted into a regular expression, and some testing cases are generated according to the regular expression. Many experiments show that a large in scale and complicated in structure smart phone software can be tested using our innovative algorithms to discover more deep hidden logical errors efficiently and effectively.', NULL);
INSERT INTO `list` VALUES (676, '2017-08-30', 2017, 'inproceedings', 'Philippe Galinier, Segla Kpodjedo, Giulio Antoniol', 'A penalty-based Tabu search for constrained covering arrays', 'Generation', 'Search Based', '2017 Genetic and Evolutionary Computation Conference', 'GECCO', '', '', '1288-1294', 'ACM', '10.1145/3071178.3071324', 'Combinatorial Testing', 'Combinatorial Interaction Testing is a black-box testing technique particularly used for highly configurable software systems, which involve a number of factors (and values) that can be combined, according to some constraints. In this context, constrained covering array (CCA) is a central combinatorial problem tasked with building a test suite of minimum size and maximum coverage of the factors\' interactions.\r\n\r\nIn this paper, we propose CATS (Covering Array by Tabu Search), a new penalty-based tabu search algorithm for the CCA problem. Our local search approach differs from the ones previously proposed primarily by its use of a search space that allows solutions that violate inter-factor constraints. Other prominent features of CATS are the definition of strategic moves used to restrict the neighborhood, and a technique to vary the tabu tenure throughout the search.\r\n\r\nWe performed tests with CATS on 2-way constrained problems using 35 widely used benchmarks. Results suggest that CATS consistently outperforms previous approaches, both on the size of the test suites and the needed computation times.', NULL);
INSERT INTO `list` VALUES (677, '2017-08-30', 2017, 'article', 'Bhargava Rohit Sagi, Rachel Silvestrini', 'Application of combinatorial tests in video game testing', 'Application', '', '2017 Quality Engineering', 'Qual. Eng.', '', '', '1-15', '', '10.1080/08982112.2017.1300919', 'Combinatorial Testing', 'Video games comprise a multi-billion-dollar industry. Companies invest huge amounts of money for the release of their games. A part of this money is invested in testing the games. Current game testing methods include manual execution of pre-written test cases in the game. Each test case may or may not result in a bug. In a game, a bug is said to occur when the game does not behave per its intended design. The process of writing the test cases to test games requires standardization. We believe that this standardization can be achieved by implementing experimental design to video game testing. In this research, we discuss the implementation of combinatorial testing, specifically covering arrays, to test games. Combinatorial testing is a method of experimental design that is used to generate test cases and is primarily used for commercial software testing. In addition to the discussion of the implementation of combinatorial testing techniques in video game testing, we present an algorithm that can be used to sort test cases to aid developers in finding the combination of settings resulting in a bug.', NULL);
INSERT INTO `list` VALUES (679, '2017-08-30', 2017, 'article', 'Manuj Aggarwal, Sangeeta Sabharwal', 'Combinatorial Test Set Prioritization Using Data Flow Techniques', 'Optimization', 'Prioritization', '2017 Arabian Journal for Science and Engineering', 'Arab. J. Sci. Eng.', '', '', '1-15', 'Springer', '10.1007/s13369-017-2631-y', 'Combinatorial Testing', 'Software testing is an expensive and important part of the software development process. One of the effective and cost- efficient test generation techniques is combinatorial testing, which identifies interaction faults that arise due to faulty combinations of few input parameters. However, for a large-sized system, it is practically impossible to execute the complete t-way test set due to time or resources constraints. As a result, only a portion of the test set can be executed leading to possible loss of fault detection capability. Prioritizing the test set helps in improving the fault detection capability. In this paper, prioritization of combinatorial test set is proposed using data flow technique. Different methods of prioritization criterion are proposed, and their effectiveness is compared by taking two software subjects. The effectiveness is compared by measuring percentage of pairs covered, percentage of weight covered and rate of fault detection. Computational results indicate that prioritized t-way test set achieves better fault detection rate as compared to unordered t-way test set.\r\n\r\n', NULL);
INSERT INTO `list` VALUES (680, '2017-08-30', 2017, 'inproceedings', 'Rachel Tzoref-Brill, Shahar Maoz', 'Syntactic and semantic differencing for combinatorial models of test designs', 'Model', 'Constraint', '2017 International Conference on Software Engineering', 'ICSE', '', '', '621-631', 'ACM', '10.1109/ICSE.2017.63', 'Combinatorial Testing', 'Combinatorial test design (CTD) is an effective test design technique, considered to be a testing best practice. CTD provides automatic test plan generation, but it requires a manual definition of the test space in the form of a combinatorial model. As the system under test evolves, e.g., due to iterative development processes and bug fixing, so does the test space, and thus, in the context of CTD, evolution translates into frequent manual model definition updates. Manually reasoning about the differences between versions of real-world models following such updates is infeasible due to their complexity and size. Moreover, representing the differences is challenging. In this work, we propose a first syntactic and semantic differencing technique for combinatorial models of test designs. We define a concise and canonical representation for differences between two models, and suggest a scalable algorithm for automatically computing and presenting it. We use our differencing technique to analyze the evolution of 42 real-world industrial models, demonstrating its applicability and scalability. Further, a user study with 16 CTD practitioners shows that comprehension of differences between real-world combinatorial model versions is challenging and that our differencing tool significantly improves the performance of less experienced practitioners. The analysis and user study provide evidence for the potential usefulness of our differencing approach. Our work advances the state-of-the-art in CTD with better capabilities for change comprehension and management.', NULL);
INSERT INTO `list` VALUES (681, '2017-08-30', 2017, 'inproceedings', 'Hiroshi Ukai, Xiao Qu', 'Test Design as Code: JCUnit', 'Application', 'Tool', '2017 International Conference on Software Testing, Verification and Validation', 'ICST', '', '', '508-515', 'IEEE', '10.1109/ICST.2017.58', 'Combinatorial Testing', 'In a development process where testing is highly automated, there is a major challenge to cope with issues such as huge test size and test stability. In this paper, we propose a model-based testing (MBT) tool called JCUnit, which generates a test suite from a model given as a Java class. Unlike other tools, it is designed to generate small and stable test suites and supports various popular models. With this tool, developers can apply MBT approach to their products without learning domain-specific language of proprietary MBT tools. Moreover, features such as portability and pluggability make it useful in a wide range of phases from unit testing to system testing. As a result, the efforts required in practical software testing will be reduced.', NULL);
INSERT INTO `list` VALUES (682, '2017-08-30', 2017, 'inproceedings', 'Kristoffer Kleine, Dimitris E. Simos', 'Coveringcerts: Combinatorial Methods for X.509 Certificate Testing', 'Application', '', '2017 International Conference on Software Testing, Verification and Validation', 'ICST', '', '', '69-79', 'IEEE', '10.1109/ICST.2017.14', 'Combinatorial Testing', 'Correct behaviour of X.509 certificate validation code in SSL/TLS implementations is crucial to ensure secure communication channels. Recently, there have been major efforts in testing these implementations, namely frankencerts and mucerts, which provide new ways to generate test certificates which are likely to reveal errors in the implementations of X.509 validation logic. However, it remains a significant challenge to generate effective test certificates. In this paper, we explore the applicability of a prominent combinatorial method, namely combinatorial testing, for testing of X.509 certificates. We demonstrate that combinatorial testing provides the theoretical guarantees for revealing errors in the certificate validation logic of SSL/TLS implementations. Our findings indicate that the introduced combinatorial testing constructs, coveringcerts, compare favorably to existing testing methods by encapsulating the semantics of the validation logic in the input model and employing combinatorial strategies that significantly reduce the number of tests needed. Besides the foundations of our approach, we also report on experiments that indicate its practical use.', NULL);
INSERT INTO `list` VALUES (683, '2017-08-30', 2017, 'inproceedings', 'Teru Ohashi, Tatsuhiro Tsuchiya', 'Generating High Strength Test Suites for Combinatorial Interaction Testing Using ZDD-Based Graph Algorithms', 'Generation', '', '2017 Pacific Rim International Symposium on Dependable Computing', 'PRDC', '', '', '78-85', 'IEEE', '10.1109/PRDC.2017.19', 'Combinatorial Testing', 'Combinatorial interaction testing is a well practiced method for detecting faults for various computing systems. This method requires that any t-wise parameter interactions must be exercised by at least one test case. The value of t is usually referred to as strength. A large body of research exists about constructing test suites of small or moderate strength, typically t = 2 or 3; but very few techniques are known for constructing those of very high strength. This paper proposes the use of ZDD-based graph algorithms to construct a very high strength combinatorial test suite. Constructing high strength test suites is challenging because of the large number of interactions that must be handled during test suite construction. A ZDD is a data structure that can be used to enumerate a very large number of paths in an undirected graph and to perform operations on large sets of graphs. In our approach test cases and interactions are represented as subgraphs of the same graph. Using a ZDDbased graph library to operate on the graphs, we succeeded in constructing test suites of high strength up to t = 11 for some problem instances.', NULL);
INSERT INTO `list` VALUES (684, '2017-08-30', 2017, 'inproceedings', 'Eun-Hye Choi, Tsuyoshi Fujiwara, Osamu Mizuno', 'Weighting for Combinatorial Testing by Bayesian Inference', 'Model', '', '2017 International Conference on Software Testing, Verification and Validation Workshops', 'ICSTW', '', '', '389-391', 'IEEE', '10.1109/ICSTW.2017.73', 'Combinatorial Testing', 'Combinatorial testing (CT) is a widely-used technique to detect system interaction failures. To improve the test effectiveness of CT, prioritized combinatorial testing inputs priority weights of parameter-values, and generates combinatorial test suites based on the weights. This paper proposes a method to automatically determine the weights of parameter-values by Bayesian inference using previous testing results. Using two open source projects, we evaluate the fault detection effectiveness of the proposed weighting based prioritized combinatorial testing. ', NULL);
INSERT INTO `list` VALUES (685, '2017-09-14', 2017, 'article', 'Sergiy Vilkomir', 'Multi-device coverage testing of mobile applications', 'Application', '', '2017 Software Quality Journal', 'Softw. Qual. J', '', '', '1-19', 'Springer', '10.1007/s11219-017-9357-7', 'Combinatorial Testing', 'This paper evaluates the effectiveness of coverage approaches for selecting mobile devices (i.e., smartphones and tablets) to test mobile software applications. Due to the large number of such devices on the market and the variations in their characteristics, it is hard to guarantee that an application will work as intended on all devices. For this reason, multi-device testing is necessary. The goal of this research was to determine how many devices must be tested and which methods for device selection are best for revealing device-specific faults. We experimentally investigated a simple coverage of all values of each device’s features separately and the each-choice coverage (i.e., the coverage of all device characteristics at the same time). To collect the experimental data, 15 Android applications were tested on 30 mobile devices and 24 device-specific faults were detected. Our research shows that a random selection of 13 devices achieved 100% effectiveness. However, coverage of device characteristics in the selection process yielded an acceptable 90% level of effectiveness with a set of only five devices. The most successful approaches were the coverage of different types of Android operating systems and the each-choice coverage. Our results include recommendations for increasing the effectiveness while decreasing the costs of mobile testing.', NULL);
INSERT INTO `list` VALUES (686, '2017-09-14', 2016, 'inproceedings', 'Mary Frances Moore, Sergiy Vilkomir', 'Practical Combinatorial Testing Approaches: A Case Study of a University Portal Application', 'Application', '', '2016 International Conference on Software Engineering & Knowledge Engineering', 'SEKE', '', '', '474-479', '', '10.18293/SEKE2016-045', 'Combinatorial Testing', 'Time and quality are important factors when determining the proper approach for software testing. A software program can often be used in various environments (different platforms, operating systems, browsers, networks, etc.) and require thorough testing to provide high quality and reliability in different configurations. Combinatorial testing is an effective approach to testing hardware and software configurations. However, testing resources are often restricted in real practice. Because business goals require different testing methods, there is no best one-size-fits-all testing approach. For this reason, we experimentally investigated and analyzed several combinatorial approaches based on Each Choice and pairwise methods (with and without the consideration of operational profiles) through the testing of an Adviser Scheduling application located in a university web portal. Test sets with various configurations were generated according to six different combinatorial strategies. The Advanced Combinatorial Testing System (ACTS) tool, which was provided by the National Institute of Standards and Technology (NIST), was used to generate pairwise test sets automatically. The case study software application was retested for each of the proposed testing approaches, and the results were compared after taking into account the number of test cases and the corresponding detected faults. Based on this analysis, we provide recommendations for the selection of testing approaches to align with different business goals. The recommendation chosen for the university web portal application allowed for improved quality and reduced time for software testing. ', NULL);
INSERT INTO `list` VALUES (687, '2017-09-14', 2015, 'inproceedings', 'Sergiy Vilkomir, Katherine Marszalkowski, Chauncey Perry, Swetha Mahendrakar', 'Effectiveness of Multi-Device Testing Mobile Applications', 'Application', '', '2015 International Conference on Mobile Software Engineering and Systems', 'MobileSoft', '', '', '44-47', 'IEEE', '10.1109/MobileSoft.2015.12', 'Combinatorial Testing', 'The paper evaluates methods of selecting mobile devices (i.e., Smartphones and tablets) to test mobile software applications. Due to the number of such devices on the market and the variations in their characteristics, it is hard to guarantee that an application will work properly on all devices. Software faults found only in certain devices are known as device-specific faults. The goal of this research was to determine how many devices must be tested and which methods of device selection are best for revealing these device-specific faults. To collect the experimental data, 15 Android applications were tested on 30 mobile devices using real devices and remote testing services such as Test Object, pCloudy, and others. In total, 24 device-specific faults were detected. Using our data, we analyzed the different methods of selection based on the characteristics of each device. Our research showed that a random selection of 13 devices achieved 100% effectiveness. However, coverage of device characteristics in the selection process enables the achievement of an acceptable 90% level of effectiveness with sets of only five devices. The most successful approach was the coverage of different types of Android operating systems. Our results include recommendations that will help increase the effectiveness and decrease the costs of mobile testing.', NULL);
INSERT INTO `list` VALUES (689, '2017-09-14', 2010, 'inproceedings', 'William Alton Ballance, William Jenkins, Sergiy Vilkomir', 'Probabilistic Assessment of Effectiveness of Software Testing for Safety-Critical Systems', 'Evaluation', '', '2010 International Probabilistic Safety Assessment & Management Conference', 'PSAM ', '', '', '7-11', '', 'not found', 'Combinatorial Testing', 'This paper provides the results of experimental evaluation of effectiveness of pair-wise testing. We consider a non-traditional area of pair-wise testing application, namely using pair-wise approach for testing logical expressions. A tool has been developed for experimental numerical investigation. This tool generates faults of various specific types and applies the previously derived test sets to determine if the testing method detected those faults. The user can see how effective a particular test case was at discovering a particular fault type. We investigate fault detection for five various types of faults in 20 different logical expressions which contain from 5 to 14 logical variables each. Three different pair-wise test sets, generated by two different tools, are applied for each logical expression and each generated fault. The program calculates probabilities of faults revealed over single expressions, the entire test set, and between fault types. We compare our results with results by other researchers and provide recommendation for practical testing. The tool has been used for analysis of pair-wise testing, however, it can be also used to analyze other testing criteria.', NULL);
INSERT INTO `list` VALUES (691, '2017-12-04', 2016, 'inproceedings', 'Sunint Kaur Khalsa, Yvan Labiche', 'An extension of category partition testing for highly constrained systems', 'Generation', 'Constraint', '2016 International Symposium on High Assurance Systems Engineering', 'HASE', '', '', '47-54', 'IEEE', '10.1109/HASE.2016.45', 'Combinatorial Testing', 'To ensure software is performing as intended it can be black-box or white-box tested. Category partition is a black box, specification based testing technique which begins by identifying the parameters, categories (characteristics of parameters) and choices (acceptable values for categories). These choices are then combined to form test frames on the basis of various criteria such as base choice and each choice. To ensure that the combinations of choices are feasible, constraints are introduced. While combining choices to form an each choice adequate test set it is feasible (e.g., using constrained covering arrays from combinatorial testing), the base choice criterion has not been defined to specifically account for constraints on choices. In this paper, we introduce two extensions of the base choice criterion to specifically account for complex constraints among choices. Adequate test suites of the different criteria are compared in terms of cost and effectiveness (code coverage and fault detection) on an academic and industrial case study.', NULL);
INSERT INTO `list` VALUES (692, '2017-12-04', 2016, 'inproceedings', 'Sompong Nakornburi, Taratip Suwannasart', 'A tool for constrained pairwise test case generation using statistical user profile based prioritization', 'Generation', 'Tool', '2016 International Joint Conference on Computer Science and Software Engineering', 'JCSSE', '', '', '1--6', 'IEEE', '10.1109/JCSSE.2016.7748881', 'Combinatorial Testing', 'Pairwise testing is a wildly used approach in order to reduce the size of test suite and take steps to combinatorial testing problems because of an extensively large number of possible combinations between input parameters and values. In some cases, there will be invalid combinations between input parameters and values if constraints have not been handled. In this paper, we present a pairwise test generation tool called CPTG, a tool to generate test cases for pairwise testing by applying user profile for guiding and prioritizing in order to select optimal input parameters and values which do not depend on individual tester skills and also providing constraint handling solution between input parameters and values. We performed experiments and comparison with other tools. The experimental results of our tool demonstrated that our tool becomes particularly valuable in guiding testing with a maximized reliability by testing the most frequently used of the system and can generate comparable results of the size of the test case set.', NULL);
INSERT INTO `list` VALUES (693, '2017-12-04', 2016, 'inproceedings', 'Stefan Fischer, Lukas Linsbauer, Roberto E. Lopez-Herrejon, Alexander Egyed', 'A source level empirical study of features and their interactions in variable software', 'Evaluation', 'Software Product Line', '2016 International Working Conference on Source Code Analysis and Manipulation', 'SWCAM', '', '', '197-206', 'IEEE', '10.1109/SCAM.2016.16', 'Combinatorial Testing', 'Robust and effective support for the detection and management of features and their interactions is crucial for many software development tasks but has proven to be an elusive goal despite the extensive research and practice on the subject. Providing the required support becomes even more challenging with variable software whereby multiple variants of a system and their features must be collectively considered. An important premise to provide better support for feature interactions in variable systems is the need of a deeper understanding on how features interact at different levels starting from the source level. In this context, recent work has looked at feature interactions from different angles and for different purposes, for instance for developing performance models, extracting interfaces for maintenance or describing feature evolution patterns. However, there is a gap in understanding how features interact in fact at the source level in contrast with how features ought to interact according to variability models that describe the valid combinations of features in variable software systems. In this paper we perform an empirical study to explore this gap. We use seven case studies, implemented in Java and C, totalling over nine million LoC, and analysed over seven thousand feature interactions. Our study revealed important inconsistencies between how feature interactions occur at source level and how they are modeled, and corroborated that the majority of source level interactions involve less than three features. We discuss the implications of our findings and avenues for further research', NULL);
INSERT INTO `list` VALUES (694, '2017-12-04', 2009, 'inproceedings', 'Jianjun Yuan, Changjun Jiang, Zuowen Jiang', 'Improved Extremal Optimization for Constrained Pairwise Testing', 'Generation', 'Search Based, Constraint', '2009 International Conference on Research Challenges in Computer Science', 'ICARCCS', '', '', '108-111', 'IEEE', '10.1109/ICRCCS.2009.35', 'Combinatorial Testing', 'Pairwise testing, which requires that every combination of valid values of each pair of system factors be covered by at lease one test case, plays an important role in software testing since many faults are caused by unexpected 2-way interactions among system factors. In real systems, constraints usually exist between values, which means that some values cannot coexist in a valid test. Although meta-heuristic strategies like simulated annealing can generally discover smaller pairwise test suite in the presence of constraints, they may cost more time to perform search, compared with greedy algorithms. We propose a new method, improved extremal optimization, for constructing constrained pairwise test suites. Experimental results show that improved extremal optimization gives similar size of resulting pairwise test suite and yields a 13% reduction in solution time over simulated annealing.', NULL);
INSERT INTO `list` VALUES (695, '2017-12-04', 2016, 'article', 'Aymeric Hervieu, Dusica Marijan, Arnaud Gotlieb, Benoit Baudry', 'Practical minimization of pairwise-covering test configurations using constraint programming', 'Generation', 'Constraint, Software Product Line', '2016 Information and Software Technology', 'IST', '71', '', '129-146', '', '10.1016/j.infsof.2015.11.007', 'Combinatorial Testing', 'Context: Testing highly-configurable software systems is challenging due to a large number of test configurations that have to be carefully selected in order to reduce the testing effort as much as possible, while maintaining high software quality. Finding the smallest set of valid test configurations that ensure sufficient coverage of the system’s feature interactions is thus the objective of validation engineers, especially when the execution of test configurations is costly or time-consuming. However, this problem is NP-hard in general and approximation algorithms have often been used to address it in practice.\r\n\r\nObjective: In this paper, we explore an alternative exact approach based on constraint programming that will allow engineers to increase the effectiveness of configuration testing while keeping the number of configurations as low as possible.\r\n\r\nMethod: Our approach consists in using a (time-aware) minimization algorithm based on constraint programming. Given the amount of time, our solution generates a minimized set of valid test configurations that ensure coverage of all pairs of feature values (a.k.a. pairwise coverage). The approach has been implemented in a tool called PACOGEN.\r\n\r\nResults: PACOGEN was evaluated on 224 feature models in comparison with the two existing tools that are based on a greedy algorithm. For 79% of 224 feature models, PACOGEN generated up to 60% fewer test configurations than the competitor tools. We further evaluated PACOGEN in the case study of an industrial video conferencing product line with a feature model of 169 features, and found 60% fewer configurations compared with the manual approach followed by test engineers. The set of test configurations generated by PACOGEN decreased the time required by test engineers in manual test configuration by 85%, increasing the feature-pairs coverage at the same time.\r\n\r\nConclusion: Our experimental evaluation concluded that optimal time-aware minimization of pairwise-covering test configurations is efficiently addressed using constraint programming techniques.', NULL);
INSERT INTO `list` VALUES (696, '2017-12-04', 2016, 'article', 'Mustafa Al-Hajjaji, Thomas Thum, Malte Lochau, Jens Meinicke, Gunter Saake', 'Effective product-line testing using similarity-based product prioritization', 'Optimization', 'Priority, Software Product Line', '2016 Software & Systems Modeling', 'SoSyM', '', '', '1--23', '', '10.1007/s10270-016-0569-2', 'Combinatorial Testing', 'A software product line comprises a family of software products that share a common set of features. Testing an entire product-line product-by-product is infeasible due to the potentially exponential number of products in the number of features. Accordingly, several sampling approaches have been proposed to select a presumably minimal, yet sufficient number of products to be tested. Since the time budget for testing is limited or even a priori unknown, the order in which products are tested is crucial for effective product-line testing. Prioritizing products is required to increase the probability of detecting faults faster. In this article, we propose similarity-based prioritization, which can be efficiently applied on product samples. In our approach, we incrementally select the most diverse product in terms of features to be tested next in order to increase feature interaction coverage as fast as possible during product-by-product testing. We evaluate the gain in the effectiveness of similarity-based prioritization on three product lines with real faults. Furthermore, we compare similarity-based prioritization to random orders, an interaction-based approach, and the default orders produced by existing sampling algorithms considering feature models of various sizes. The results show that our approach potentially increases effectiveness in terms of fault detection ratio concerning faults within real-world product-line implementations as well as synthetically seeded faults. Moreover, we show that the default orders of recent sampling algorithms already show promising results, which, however, can still be improved in many cases using similarity-based prioritization.', NULL);
INSERT INTO `list` VALUES (697, '2017-12-04', 2012, 'article', 'Gilles Perrouin, Sebastian Oster, Sagar Sen, Jacques Klein, Benoit Baudry, Yves Le Traon', 'Pairwise testing for software product lines: comparison of two approaches', 'Evaluation', 'Software Product Line', '2012 Software Quality Journal', 'Softw. Qual. J', '20', '3-4', '605-643', '', '10.1007/s11219-011-9160-9', 'Combinatorial Testing', 'Software Product Lines (SPL) are difficult to validate due to combinatorics induced by variability, which in turn leads to combinatorial explosion of the number of derivable products. Exhaustive testing in such a large products space is hardly feasible. Hence, one possible option is to test SPLs by generating test configurations that cover all possible t feature interactions (t-wise). It dramatically reduces the number of test products while ensuring reasonable SPL coverage. In this paper, we report our experience on applying t-wise techniques for SPL with two independent toolsets developed by the authors. One focuses on generality and splits the generation problem according to strategies. The other emphasizes providing efficient generation. To evaluate the respective merits of the approaches, measures such as the number of generated test configurations and the similarity between them are provided. By applying these measures, we were able to derive useful insights for pairwise and t-wise testing of product lines.', NULL);
INSERT INTO `list` VALUES (698, '2017-12-04', 2016, 'inproceedings', 'Mustafa Al-Hajjaji, Sebastian Krieter, Thomas Thum, Malte Lochau, Gunter Saake', 'IncLing: efficient product-line testing using incremental pairwise sampling', 'Generation', 'Constraint, Software Product Line', '2016 International Conference on Generative Programming: Concepts and Experiences', 'GPCE', '', '', '144-155', 'ACM', '10.1145/2993236.2993253', 'Combinatorial Testing', 'A software product line comprises a family of software products that share a common set of features. It enables customers to compose software systems from a managed set of features. Testing every product of a product line individually is often infeasible due to the exponential number of possible products in the number of features. Several approaches have been proposed to restrict the number of products to be tested by sampling a subset of products achieving sufficient combinatorial interaction coverage. However, existing sampling algorithms do not scale well to large product lines, as they require a considerable amount of time to generate the samples. Moreover, samples are not available until a sampling algorithm completely terminates. As testing time is usually limited, we propose an incremental approach of product sampling for pairwise interaction testing (called IncLing), which enables developers to generate samples on demand in a step-wise manner. Furthermore, IncLing uses heuristics to efficiently achieve pairwise interaction coverage with a reasonable number of products. We evaluated IncLing by comparing it against existing sampling algorithms using feature models of different sizes. The results of our approach indicate efficiency improvements for product-line testing.', NULL);
INSERT INTO `list` VALUES (699, '2017-12-04', 2017, 'article', 'Yunlong Sheng, Changan Wei, Shouda Jiang', 'Constraint Test Cases Generation Based on Particle Swarm Optimization', 'Generation', 'Search Based, Constraint', '2017 International Journal of Reliability, Quality and Safety Engineering', 'IJRQSE', '24', '5', '1--21', '', '10.1142/S0218539317500218', 'Combinatorial Testing', 'The testing of configurations with constraints still faces a great challenge. Although artificial intelligence (AI)-based algorithms perform better than greedy algorithms on t\r\n-way testing because of the good searching ability of optimal solutions, only a few AI-based algorithms can support constraints currently. Moreover, the AI-based algorithms can only ignore the conflicting candidate test cases subject to constraints, even though they are optimal. In this paper, we demonstrate two novel particle swarm optimization (PSO)-based constraint test cases generation (PCTG) methods. In the two methods, the strategies of avoiding the selection of conflicting test cases and replacing conflicting test cases are applied to handle constraints, respectively. They guide the process of searching for optimal solutions from different perspectives, according to different handling of constraints. We evaluate the availability of these two methods with some excellent existing strategies in terms of performance. The evaluation results indicate that our proposed methods, in most cases, outperform other strategies as far as the generated constraints covering array sizes.\r\n\r\n', NULL);
INSERT INTO `list` VALUES (700, '2017-12-04', 2012, 'inproceedings', 'A.A. Alsewari, Kamal Z. Zamli', 'Constraints Dependent T-Way Test Suite Generation Using Harmony Search Strategy', 'Generation', 'Search Based, Constraint', '2012 Pacific Rim Knowledge Acquisition Workshop', 'PKAW', '', '', '1--11', '', 'https://doi.org/10.1007/978-3-642-32541-0_1', 'Combinatorial Testing', 'Recently, many new researchers have considered the adoption of Artificial Intelligence-based Algorithm for the construction of t-way test suite generation strategies (where t indicates the interaction strengths). Although useful, most existing AI-based strategies have not sufficiently dealt or even experimented with the problem of constraints. Here, it is desirable for a particular AI-based strategy of interest to be able to automatically exclude the set of impossible or forbidden combinations from the final t-way generated suite. This paper describes our experience dealing with constraints from within a Harmony Search Algorithm based strategy, called HSS. Our experience with HSS is encouraging as we have obtained competitive test size as overall.', NULL);
INSERT INTO `list` VALUES (702, '2017-12-04', 2016, 'inproceedings', 'Hai Liu, Feifei Ma, Jian Zhang', 'Generating Covering Arrays With Pseudo-Boolean Constraint Solving and Balancing Heuristic', 'Generation', '', '2016 Pacific Rim International Conference on Artificial Intelligence', 'PRICAI', '', '', '262-270', '', '10.1007/978-3-319-42911-3_22', 'Combinatorial Testing', 'Covering arrays (CAs) are interesting objects in combinatorics and they also play an important role in software testing. It is a challenging task to generate small CAs automatically and efficiently. In this paper, we propose a new approach which generates a CA column by column. A kind of balancing heuristic is adopted to guide the searching procedure. At each step (column extension), some pseudo Boolean constraints are generated and solved by a PBO solver. A prototype tool is implemented, which turns out to be able to find smaller CAs than other tools, for some cases.', NULL);
INSERT INTO `list` VALUES (704, '2017-12-04', 2015, 'inproceedings', 'Sylvain Halle, Edmond La Chance, Sebastien Gaboury', 'Graph Methods for Generating Test Cases with Universal and Existential Constraints', 'Generation', 'Constraint', '2015 IFIP International Conference on Testing Software and Systems', 'ICTSS', '', '', '55-70', '', '10.1007/978-3-319-25945-1_4', 'Combinatorial Testing', 'We introduce a generalization of the t-way test case generation problem, where parameter t is replaced by a set Φ\r\n of Boolean conditions on attribute values. We then present two reductions of this problem to graphs; first, to graph colouring, where we link the minimal number of tests to the chromatic number of some graph; second, to hypergraph vertex covering. This latter formalization allows us to handle problems with constraints of two kinds: those that must be true for every generated test case, and those that must be true for at least one test case. Experimental results show that the proposed solution produces test suites of slightly smaller sizes than a range of existing tools, while being more general: to the best of our knowledge, our work is the first to allow existential constraints over test cases.', NULL);
INSERT INTO `list` VALUES (705, '2017-12-04', 2008, 'inproceedings', 'Feifei Ma, Jian Zhang', 'Finding Orthogonal Arrays Using Satisfiability Checkers and Symmetry Breaking Constraints', 'Generation', '', '2008 Pacific Rim International Conference on Artificial Intelligence', 'PRICAI', '', '', '247-259', '', '10.1007/978-3-540-89197-0_25', 'Combinatorial Testing', 'Orthogonal arrays are very important combinatorial objects\r\nwhich can be used in software testing and other areas. Mathematical\r\nmethods for constructing such arrays have been studied extensively in\r\nthe past decades. In contrast, computer search techniques, in particular\r\nexhaustive search methods, are rarely used to solve the problem. In this\r\npaper, we present an algorithm which finds orthogonal arrays of given\r\nsizes or shows their non-existence. The algorithm is essentially a backtrack search procedure, but enhanced with some novel symmetry breaking (isomorphism elimination) techniques. The orthogonal array is generated column by column, and the constraints are checked by an efficient\r\nSAT solver or pseudo-Boolean constraint solver. We have implemented\r\na tool called BOAS (Backtrack-style OA Searcher) using MiniSat and\r\nPBS. Experimental results show that our tool can find many orthogonal\r\narrays quickly, especially those with strength higher than 2.', NULL);
INSERT INTO `list` VALUES (706, '2017-12-04', 2016, 'article', 'Jose A. Galindo, Hamilton Turner, David Benavides, Jules White', 'Testing variability intensive systems using automated analysis: An application to Android', 'Application', 'Software Product Line', '2016 Software Quality Journal', 'Softw. Qual. J', '24', '2', '365-405', '', '10.1007/s11219-014-9258-y', 'Combinatorial Testing', 'Software product lines are used to develop a set of software products that, while being different, share a common set of features. Feature models are used as a compact representation of all the products (e.g., possible configurations) of the product line. The number of products that a feature model encodes may grow exponentially with the number of features. This increases the cost of testing the products within a product line. Some proposals deal with this problem by reducing the testing space using different techniques. However, a daunting challenge is to explore how the cost and value of test cases can be modeled and optimized in order to have lower-cost testing processes. In this paper, we present TESting vAriAbiLity Intensive Systems (TESALIA), an approach that uses automated analysis of feature models to optimize the testing of variability-intensive systems. We model test value and cost as feature attributes, and then we use a constraint satisfaction solver to prune, prioritize and package product line tests complementing prior work in the software product line testing literature. A prototype implementation of TESALIA is used for validation in an Android example showing the benefits of maximizing the mobile market share (the value function) while meeting a budgetary constraint.', NULL);
INSERT INTO `list` VALUES (707, '2017-12-04', 2017, 'article', 'Aitor Arrieta, Goiuria Sagardui, Leire Etxeberria, Justyna Zander', 'Automatic generation of test system instances for configurable cyber-physical systems', 'Application', '', '2017 Software Quality Journal', 'Softw. Qual. J', '25', '3', '1041-1083', '', '10.1007/s11219-016-9341-7', 'Combinatorial Testing', 'Cyber-physical systems (CPSs) are ubiquitous systems that integrate digital technologies with physical processes. These systems are becoming configurable to respond to the different needs that users demand. As a consequence, their variability is increasing, and they can be configured in many system variants. To ensure a systematic test execution of CPSs, a test system must be elaborated encapsulating several sources such as test cases or test oracles. Manually building a test system for each configuration is a non-systematic, time-consuming, and error-prone process. To overcome these problems, we designed a test system for testing CPSs and we analyzed the variability that it needed to test different configurations. Based on this analysis, we propose a methodology supported by a tool named ASTERYSCO that automatically generates simulation-based test system instances to test individual configurations of CPSs. To evaluate the proposed methodology, we selected different configurations of a configurable Unmanned Aerial Vehicle, and measured the time required to generate their test systems. On average, around 119 s were needed by our tool to generate the test system for 38 configurations. In addition, we compared the process of generating test system instances between the method we propose and a manual approach. Based on this comparison, we believe that the proposed tool allows a systematic method of generating test system instances. We believe that our approach permits an important step toward the full automation of testing in the field of configurable CPSs.', NULL);
INSERT INTO `list` VALUES (708, '2017-12-04', 2015, 'article', 'Toru Nanba, Tatsuhiro Tsuchiya, Tohru Kikuno', 'Using Satisfiability Solving for Pairwise Testing in the Presence of Constraints', 'Generation', 'Constraint', '2015 IEICE Transactions on Fundamentals of Electronics, Communications and Computer Sciences', 'IEICE', '95', '9', '1501-1505', '', '10.1587/transfun.E95.A.1501', 'Combinatorial Testing', 'This letter discusses the applicability of boolean satisfiability (SAT) solving to pairwise testing in practice. Due to its recent rapid advance, using SAT solving seems a promising approach for search-based testing and indeed has already been practiced in test generation for pairwise testing. The previous approaches use SAT solving either for finding a small test set in the absence of parameter constraints or handling constraints, but not for both. This letter proposes an approach that uses a SAT solver for constructing a test set for pairwise testing in the presence of parameter constraints. This allows us to make full use of SAT solving for pairwise testing in practice.', NULL);
INSERT INTO `list` VALUES (710, '2017-12-04', 2011, 'inproceedings', 'Toru Nanba, Tatsuhiro Tsuchiya, Tohru Kikuno', 'Constructing Test Sets for Pairwise Testing: A SAT-Based Approach', 'Generation', 'Constraint', '2011 International Conference on Networking and Computing', 'ICNC', '', '', '271-274', '', '10.1109/ICNC.2011.49', 'Combinatorial Testing', 'In this paper pair wise testing, a well-practiced software testing method, is discussed. Specifically an automatic test generation approach is proposed for this particular testing method. The proposed approach makes full use of a boolean satisfiability solver (SAT solver). Due to recent rapid advance, modern SAT solvers are able to handle very large problem instances. Using a SAT solver thus allows us both to efficiently find hidden constraints on possible tests and to search for a good test set.', NULL);
INSERT INTO `list` VALUES (711, '2017-12-04', 2018, 'article', 'Sajad Esfandyari, Vahid Rafe', 'A tuned version of genetic algorithm for efficient test suite generation in interactive t-way testing strategy', 'Generation', 'Search Based', '2018 Information and Software Technology', 'IST', '94', '', '165-185', '', '10.1016/j.infsof.2017.10.007', 'Combinatorial Testing', 'Context\r\nTo improve the quality and correctness of a software product it is necessary to test different aspects of the software system. Among different approaches for software testing, combinatorial testing along with covering array is a proper testing method. The most challenging problem in combinatorial testing strategies like t-way, is the combinatorial explosion which considers all combinations of input parameters. Many evolutionary and meta-heuristic strategies have been proposed to address and mitigate this problem.\r\n\r\nObjective\r\nGenetic Algorithm (GA) is an evolutionary search-based technique that has been used in t-way interaction testing by different approaches. Although useful, all of these approaches can produce test suite with small interaction strengths (i.e. t ≤ 6). Additionally, most of them suffer from expensive computations. Even though there are other strategies which use different meta-heuristic algorithms to solve these problems, in this paper, we propose an efficient uniform and variable t-way minimal test suite generation approach to address these problems using GA, called Genetic Strategy (GS).\r\n\r\nMethod\r\nBy changing the bit structure and accessing test cases quickly, GS improves performance of the fitness function. These adjustments and reduction of the complexities of GA in the proposed GS decreases the test suite size and increases the speed of test suite generation up to\r\n.\r\n\r\nResults\r\nTo evaluate the efficiency and performance of the proposed GS, various experiments are performed on different set of benchmarks. Experimental results show that not only GS supports higher interaction strengths in comparison with the existing GA-based strategies, but also its supported interaction strength is higher than most of other AI-based and computational-based strategies.\r\n\r\nConclusion\r\nFurthermore, experimental results show that GS can compete against the existing (both AI-based and computational-based) strategies in terms of efficiency and performance in most of the case studies.', NULL);
INSERT INTO `list` VALUES (712, '2017-12-04', 2013, 'inproceedings', 'Christopher Henard, Mike Papadakis, Gilles Perrouin, Jacques Klein, Yves Le Traon', 'Multi-objective test generation for software product lines', 'Generation', 'Software Product Line, Constraint, Search Based', '2013 International Software Product Line Conference', 'SPLC', '', '', '62-71', 'ACM', '10.1145/2491627.2491635', 'Combinatorial Testing', 'Software Products Lines (SPLs) are families of products sharing common assets representing code or functionalities of a software product. These assets are represented as features, usually organized into Feature Models (FMs) from which the user can configure software products. Generally, few features are sufficient to allow configuring millions of software products. As a result, selecting the products matching given testing objectives is a difficult problem.\r\n\r\nThe testing process usually involves multiple and potentially conflicting testing objectives to fulfill, e.g. maximizing the number of optional features to test while at the same time both minimizing the number of products and minimizing the cost of testing them. However, most approaches for generating products usually target a single objective, like testing the maximum amount of feature interactions. While focusing on one objective may be sufficient in certain cases, this practice does not reflect real-life testing situations.\r\n\r\nThe present paper proposes a genetic algorithm to handle multiple conflicting objectives in test generation for SPLs. Experiments conducted on FMs of different sizes demonstrate the effectiveness, feasibility and practicality of the introduced approach.', NULL);
INSERT INTO `list` VALUES (713, '2017-12-04', 2016, 'article', 'Yin Li, Zhi-an Sun, Jian-Yong Fang', 'Generating an Automated Test Suite by Variable Strength Combinatorial Testing for Web Services', 'Generation', 'Constraint', '2016 Journal of computing and information technology', 'JCOMPUTINFOTECH', '24', '3', '271-282', '', '10.20532/cit.2016.1002727', 'Combinatorial Testing', 'Testing Web Services has become the spotlight of\r\nsoftware engineering as an important means to assure the quality of Web application. Due to lacking of\r\ngraphic interface and source code, Web services need\r\nan automated testing method, which is an important\r\npart in efficiently designing and generating test suite.\r\nHowever, the existing testing methods may lead to the\r\nredundancy of test suite and the decrease of fault-detecting ability since it cannot handle scenarios where\r\nthe strengths of the different interactions are not uniform. With the purpose of solving this problem, firstly\r\nthe formal tree model based on WSDL is constructed\r\nand the actual interaction relationship of each node is\r\nmade sufficient consideration into, then the combinatorial testing is proposed to generate variable strength\r\ncombinatorial test suite based on One-test-at-a-time\r\nstrategy. At last test cases are minimized according to\r\nconstraint rules. The results show that compared with\r\nconventional random testing, the proposed approach\r\ncan detect more errors with the same amount of test\r\ncases which turning out to be more ideal than existing\r\nones in size.', NULL);
INSERT INTO `list` VALUES (715, '2017-12-04', 2010, 'article', 'Peter M. Kruse, Magdalena Luniak', 'Automated test case generation using classification tree', 'Generation', '', '2010 Software Quality Professional', 'SQP', '13', '1', '4--12', '', 'not found', 'Combinatorial Testing', 'The basic problem in software testing is selecting a set of test cases. This article presents a test case design using the Classification Tree Editor, a test case generation software tool. It shows how to integrate weighting factors into classification trees and generate prioritized test suites. The classification tree editor includes classical approaches such as minimal combination and pair-wise as well as weighted counterparts, statistical testing and new generating rules. The software allows for prioritization by occurrence probability, error probability or risk.', NULL);
INSERT INTO `list` VALUES (721, '2017-12-04', 2017, 'inproceedings', 'Dong Yan, Linjie Pan, Rongjie Yan, Jun Yan, Jian Zhang', 'Comprehensive Static Analysis for Configurable Software via Combinatorial Instantiation', 'Application', '', '2017 Annual Computer Software and Applications Conference', 'COMPSAC', '', '', '67-74', 'IEEE', '10.1109/COMPSAC.2017.91', 'Combinatorial Testing', 'Equipped with customized parameters, configurable software is more flexible when facing various hardware platforms and scenario options. The configurability can tailor the source code to different instances. Consequently, it is difficult for developers to enumerate all possible configurations for finding bugs, especially for large-scale configurable software systems. In this paper, we propose a method to efficiently detect bugs of such systems with static analysis techniques. The method takes advantage of combinatorial testing techniques to generate sufficient configurations. It first extracts required parameters and the corresponding constraints from a configure file. The parameters together with constraints are employed to generate configurations with required coverage. Considering the features of configuration options, we further classify the parameters into clusters, according to the tightness of their relations. Inspired from the idea of divide-and-conquer, every cluster can be assigned with a local strength, such that the tightly coupled options can be covered, without incurring other unnecessary options. Such improvement can reduce the number of required configurations, thus improving the efficiency of static analysis. The experimental results over four real-world configurable systems demonstrate the efficiency, scalability and practicality of our method.', NULL);
INSERT INTO `list` VALUES (722, '2017-12-04', 2016, 'inproceedings', 'Eun-Hye Choi, Osamu Mizuno, Yifan Hu', 'Code Coverage Analysis of Combinatorial Testing', 'Evaluation', '', '2016 International Workshop on Quantitative Approaches to Software Quality', 'QASQ', '', '', '43-49', '', 'not found', 'Combinatorial Testing', 'Combinatorial t-way testing with small t is known as an e cient black-box testing technique to detect parameter interaction failures. So far, several empirical studies have reported the e↵ectiveness of t-way testing on fault detection abilities. However, few studies have investigated the e↵ectiveness of t-way testing on code coverage, which is one of the most important coverage criteria widely used for software testing. This paper presents a quantitative analysis to evaluate the code-coverage e↵ectiveness of t-way testing. Using three open source utility programs, we compare t-way testing with exhaustive (all combination) testing w. r. t. code coverage and test suite sizes. Keywords-Combinatorial testing; t-way testing; Exhaustive testing; Code coverage; Line coverage; Branch coverage.', NULL);
INSERT INTO `list` VALUES (723, '2017-12-04', 2017, 'inproceedings', 'Mutsunori Banbara, Katsumi Inoue, Hiromasa Kaneyuki, Tenda Okimoto, Torsten Schaub, Takehide Soh, Naoyuki Tamura', 'catnap: Generating Test Suites of Constrained Combinatorial Testing with Answer Set Programming', 'Generation', 'Constraint', '2017 International Conference on Logic Programming and Nonmonotonic Reasoning', 'LPNMR', '', '', '265-278', 'Springer', '10.1007/978-3-319-61660-5_24', 'Combinatorial Testing', 'We develop an approach to test suite generation for Constrained Combinatorial Testing (CCT), one of the most widely studied combinatorial testing techniques, based on Answer Set Programming (ASP). The resulting catnap system accepts a CCT instance in fact format and combines it with a first-order encoding for generating test suites, which can subsequently be solved by any off-the-shelf ASP systems. We evaluate the effectiveness of our approach by empirically contrasting it to the best known bounds obtained via dedicated implementations.', NULL);
INSERT INTO `list` VALUES (724, '2017-12-04', 2018, 'article', 'Kristoffer Kleine, Dimitris E. Simos', 'An Efficient Design and Implementation of the In-Parameter-Order Algorithm', 'Generation', '', '2018 Mathematics in Computer Science', 'Math. Comput. Sci.', '', '', '1--17', 'Springer', '10.1007/s11786-017-0326-0', 'Combinatorial Testing', 'The In-Parameter-Order-General algorithm is one of the most widely used algorithms for covering array generation. It has found wide adoption in the field of combinatorial testing as it produces acceptably small covering arrays while being faster than alternative algorithms. In this paper we describe in detail how to efficiently design an efficient implementation, referred to as Fast In-Parameter-Order-General algorithm, which improves test generation times significantly while maintaining a low memory footprint compared to existing implementations. Besides the general algorithmic engineering and optimization considerations, we analyse and evaluate their benefits in an experimental study.', NULL);
INSERT INTO `list` VALUES (726, '2017-12-04', 2017, 'inproceedings', 'Khandakar F. Rabbi, Quazi Mamun, Rafiqul Islam', 'A Novel Swarm Intelligence Based Strategy to Generate Optimum Test Data in T-Way Testing', 'Generation', 'Search Based', '2017 International Conference on Applications and Techniques in Cyber Security and Intelligence', 'ATCI', '', '', '247-255', 'Springer', '10.1007/978-3-319-67071-3_31', 'Combinatorial Testing', 'The limitation of resources and the deadline of software and hardware projects inhibits the exhaustive testing of a system. The most effective way\r\nto overcome this problem is to generation of optimal test suite. Heuristic searches are used to optimize the test suite since 1992. Recently, the interest and\r\nactivities is increasing in this area. In theory, the changes to the parameter\r\ninteraction (the t) can significantly reduce the number data in the test suite.\r\nUsing this principle many scientists and practitioners created some effective test\r\nsuite generation strategies. The implementation of heuristic search in the generation of optimum and minimum test suite is the most effective. However,\r\nproducing the optimum test data is a NP-hard problem (Non-deterministic\r\npolynomial). Thus, it is impossible for any strategy that can produce the optimum test suite in any circumstance. This paper represents a novel swarm\r\nintelligent based searching strategy (mSITG) to generate optimum test suite. The\r\nperformances of the mSITG are analyzed and compared with other well-known\r\nstrategies. Empirical result shows that the proposed strategy is highly acceptable\r\nin terms of the test data size.', NULL);
INSERT INTO `list` VALUES (753, '2018-07-19', 2017, 'article', 'Bestoun S. Ahmed, Kamal Z. Zamli, Wasif Afzal, Miroslav Bures', 'Constrained Interaction Testing: A Systematic Literature Study', 'Other', 'Survey', '2017 IEEE Access', 'Access', '5', '', '25706--25730', ' ', '10.1109/ACCESS.2017.2771562', 'Combinatorial Testing', 'Interaction testing can be used to effectively detect faults that are otherwise difficult to find by other testing techniques. However, in practice, the input configurations of software systems are subjected to constraints, especially in the case of highly configurable systems. Handling constraints effectively and efficiently in combinatorial interaction testing is a challenging problem. Nevertheless, researchers have attacked this challenge through different techniques, and much progress has been achieved in the past decade. Thus, it is useful to reflect on the current achievements and shortcomings and to identify potential areas of improvements. This paper presents the first comprehensive and systematic literature study to structure and categorize the research contributions for constrained interaction testing. Following the guidelines of conducting a literature study, the relevant data are extracted from a set of 103 research papers belonging to constrained interaction testing. The topics addressed in constrained interaction testing research are classified into four categories of constraint test generation, application, generation and application, and model validation studies. The papers within each of these categories are extensively reviewed. Apart from answering several other research questions, this paper also discusses the applications of constrained interaction testing in several domains, such as software product lines, fault detection and characterization, test selection, security, and graphical user interface testing. This paper ends with a discussion of limitations, challenges, and future work in the area.', NULL);
INSERT INTO `list` VALUES (754, '2018-07-19', 2017, 'article', 'Juliana M. Balera, Valdivino A. de Santiago Junior', 'An algorithm for combinatorial interaction testing: definitions and rigorous evaluations', 'Generation', '', '2017 Journal of Software Engineering Research and Development', 'J. Softw. Eng. Res. Dev.', '5', '', '10', ' ', '10.1186/s40411-017-0043-z', 'Combinatorial Testing', 'Combinatorial Interaction Testing (CIT) approaches have drawn attention of the software testing community to generate sets of smaller, efficient, and effective test cases where they have been successful in detecting faults due to the interaction of several input parameters. Recent empirical studies show that greedy algorithms are still competitive for CIT. It is thus interesting to investigate new approaches to address CIT test case generation via greedy solutions and to perform rigorous evaluations within the greedy context.', NULL);
INSERT INTO `list` VALUES (755, '2018-07-19', 2017, 'article', 'Preeti Satish, Peri Nikhil, Krishnan Rangarajan', 'A Test Prioritization Algorithm That Cares for \"Don\'t Care\" Values and Higher Order Combinatorial Coverage', 'Optimization', 'Priority', '2017 ACM SIGSOFT Software Engineering Notes', 'SIGSOFT', '42', '4', '1--9', ' ', '10.1145/3149485.3149510', 'Combinatorial Testing', 'The efficiency of prioritization algorithms depends on how early the faults are detected. In this paper, we present a novel prioritization algorithm for combinatorial testing. Our approach takes ACTS tool generated test cases with \"don\'t care\" values as the starting point and refines them for increased effectiveness without increasing the number of test cases. Our algorithm maximizes the number of higher order combinations tested, by filling the \"don\'t care\" values in the test suite effectively. It also orders the test cases using a cost function that includes higher order coverage, thereby achieving early fault detection. The effectiveness of our algorithms is demonstrated by performing a comparative evaluation using the metric t way Rate of Fault Detection, on 2 real life case studies and numerous synthetic covering arrays of different sizes. The results show that our algorithms perform better in terms of covering higher order pairs and also faster.', NULL);
INSERT INTO `list` VALUES (757, '2018-07-19', 2018, 'inproceedings', 'Mosab Bazargani, John H. Drake, Edmund K. Burke', 'Late Acceptance Hill Climbing for Constrained Covering Arrays', 'Generation', 'Search Based', '2018 International Conference on Applications of Evolutionary Computation', 'EvoApplications', '', '', '778--793', ' ', '10.1007/978-3-319-77538-8_52', 'Combinatorial Testing', 'The Late Acceptance Hill-Climbing (LAHC) algorithm is a one-point search meta-heuristic with a single parameter. Like Simulated Annealing (SA) it sometimes accepts worsening moves, however it is far more simple and does not require complex parameter setting. In this paper we study an application of LAHC to the Combinatorial Interaction Testing (CIT) problem. CIT is a cost-effective black-box sampling technique for discovering interaction faults in highly configurable systems. There are several techniques for CIT; one of the most established and well-known is Covering Arrays by Simulated Annealing (CASA). CASA is a layered search framework using SA in its most inner layer. Here we replace SA in CASA with LAHC, proposing a modified framework, Covering Arrays by Late Acceptance (CALA). Our experimental evaluation demonstrates that LAHC yields better or equal quality solutions compared to SA for all but one of the 35 benchmark instances tested.', NULL);
INSERT INTO `list` VALUES (759, '2018-07-19', 2018, 'article', 'David Adamo, Dmitry Nurmuradov, Shraddha Piparia, Renée C. Bryce', 'Combinatorial-based event sequence testing of Android applications', 'Application', '', '2018 Information and Software Technology', 'Inf. Softw. Technol', '99', '', '98--117', ' ', '10.1016/j.infsof.2018.03.007', 'Combinatorial Testing', 'Several studies show that combinational-based reduction techniques that consider user event combinations and sequences have the potential to reduce regression testing costs while maintaining high code coverage and fault finding effectiveness for desktop GUI and web-based applications. This work expands existing techniques to the mobile testing domain by utilizing not only user event coverage, but additionally element coverage. We use sequences of size t=2 to reduce test suites by user event coverage and element coverage using three scenarios for each, including sequences without respect to order of occurrence, sequences with respect to order of occurrence, and sequences of consecutive occurrences only. The results demonstrate that reductions guided by event sequences reduce the test suite by between 24.67%-66% while losing at most 0.39% code coverage. Element sequence guided reductions reduce the test suites more dramatically by 40% to 72.67%, losing less than 0.87% code coverage.', NULL);
INSERT INTO `list` VALUES (760, '2018-07-19', 2018, 'article', 'Yuexing Wang, Min Zhou, Xiaoyu Song, Ming Gu, Jiaguang Sun', 'Constructing Cost-Aware Functional Test-Suites Using Nested Differential Evolution Algorithm', 'Generation', 'Search Based', '2018 IEEE Transactions on Evolutionary Computation', 'Trans. Evol. Comput.', '22', '3', '334--346', ' ', '10.1109/TEVC.2017.2747638', 'Combinatorial Testing', 'Combinatorial testing can test software that has various configurations for multiple parameters efficiently. This method is based on a set of test cases that guarantee a certain level of interaction among parameters. Mixed covering array (MCA) can be used to represent a test-suite. Each row of the array corresponds to a test case. In general, a smaller size of MCA does not necessarily imply less testing time. There are certain combinations of parameter values which would take much longer time than other cases. Based on this observation, it is more valuable to construct MCAs that are better in terms of testing effort characterization other than size. We present a method to find cost-aware MCAs. The method contains two steps. First, simulated annealing algorithm is used to get an MCA with a small size. Then we propose a novel nested differential evolution algorithm to improve the solution with its testing effort. The experimental results indicate that our method succeeds in constructing cost-aware MCAs for real-world applications. The testing effort is significantly reduced compared with representative state-of-the-art algorithms.', NULL);
INSERT INTO `list` VALUES (761, '2018-07-19', 2018, 'incollection', 'Dmitry Nurmuradov, Renée C. Bryce, Shraddha Piparia, Barrett Bryant', 'Clustering and Combinatorial Methods for Test Suite Prioritization of GUI and Web Applications', 'Optimization', 'Priority', '2018 Information Technology - New Generations', 'Book', '', '', '459--466', ' ', '10.1007/978-3-319-77028-4_60', 'Combinatorial Testing', 'This work introduces a novel test case prioritization method that combines clustering methods, dimensionality reduction techniques (DRTs), and combinatorial-based two-way prioritization for GUI and web applications. The use of clustering with interleaved cluster prioritization increases the diversity of the earliest selected test cases. The study applies four DRTs, four clustering algorithms, and three inter-cluster ranking methods to three GUI and one web applications in order to determine the best combination of methods. We compare the proposed clustering and dimensionality reduction approaches to random and two-way inter-window prioritization techniques. The outcome of the study indicates that the Principal Component Analysis (PCA) dimensionality reduction technique and Mean Shift clustering method outperform other techniques. There is no statistical difference between the three inter-cluster ranking criteria. In comparison to two-way inter-window prioritization, the Mean Shift clustering algorithm with PCA or Independent Component Analysis (FICA) generally produces faster rates of fault detection in the studies.', NULL);
INSERT INTO `list` VALUES (762, '2018-07-19', 2017, 'inproceedings', 'Arash Sabbaghi, Mohammad Reza Keyvanpour', 'A novel approach for combinatorial test case generation using multi objective optimization', 'Generation', 'Search Based', '2017 International Conference on Computer and Knowledge Engineering', 'ICCKE', '', '', '411--418', ' ', '10.1109/ICCKE.2017.8167914', 'Combinatorial Testing', 'Combinatorial testing is a promising technique for testing highly-configurable systems. Software systems become larger and more complex every day, and due to the time and cost limitations, it is infeasible to test everything in a software with a large configuration space, or a graphical user interface with many settings and events. Combinatorial testing generates an interaction test suite to discover faults caused by parameter interactions using a systematic sampling method. Generation of an optimal test suite in combinatorial testing despite the necessity of determining the execution order of test cases and considering constraints is a challenging process. In this paper, we consider the combinatorial testing as a multiobjective optimization problem and propose a novel approach to generate combinatorial test cases by considering all metrics simultaneously. The experimental results showed the effectiveness of the proposed approach in generating test suites with reduced size and increased priority while the higher priority test cases are generated earlier and the higher priority parameter-values appear more frequently.', NULL);
INSERT INTO `list` VALUES (764, '2018-07-19', 2018, 'article', 'Idelfonso Izquierdo-Marquez, Jose Torres-Jimenez, Brenda Acevedo-Juarez, Himer Avila-George', 'A greedy-metaheuristic 3-stage approach to construct covering arrays', 'Generation', 'Search Based', '2018 Information Sciences', 'INFS', '460-461', '', '172-189', ' ', '10.1016/j.ins.2018.05.047', 'Combinatorial Testing', 'Covering arrays are combinatorial designs used as test-suites in software and hardware testing. Because of their practical applications, the construction of covering arrays with a smaller number of rows is desirable. In this work we develop a greedy-metaheuristic 3-stage approach to construct covering arrays that improve some of the best-known ones. In the first stage, a covering perfect hash family is created using a metaheuristic approach; this initial array may not be complete, and so the derived covering array may have missing tuples. In the second stage, the covering perfect hash family is converted to a covering array and, in case there are missing tuples, a greedy approach completes the covering array through the addition of some rows. The third stage is an iterative postoptimization stage that combines two greedy algorithms and a metaheuristic algorithm; the greedy algorithms detect and reduce redundancy in the covering array, and the metaheuristic algorithm covers the tuples that may become uncovered after the reduction of redundancy. The effectiveness of our greedy-metaheuristic 3-stage approach is assessed through the construction of covering arrays of order four and strengths 3–6; the main results are the improvement of 9473 covering arrays of strength three, 9303 of strength four, 2150 of strength five, and 291 of strength six. To see how to apply covering arrays to real testing scenarios, the final part of this work presents the use of covering arrays of order four for setting up a composting process.', NULL);
INSERT INTO `list` VALUES (765, '2018-07-19', 2018, 'inproceedings', 'Rubing Huang, Yunan Zhou, Dave Towey, Tsong Yueh Chen, Jinfu Chen', 'An experimental analysis of fault detection capabilities of covering array constructors', 'Evaluation', '', '2018 ICSE \'18: Proceedings of the 40th International Conference on Software Engineering: Companion ProceeedingsMay 2018 ', 'ICSE', '', '', '246--247', ' ', '10.1145/3183440.3194953', 'Combinatorial Testing', 'Combinatorial Interaction Testing (CIT) aims at constructing an effective test suite, such as a Covering Array (CA), that can detect faults that are caused by the interaction of parameters. In this paper, we report on some empirical studies conducted to examine the fault detection capabilities of five popular CA constructors: ACTS, Jenny, PICT, CASA, and TCA. The experimental results indicate that Jenny has the best performance, because it achieves better fault detection than the other four constructors in many cases. Our results also indicate that CAs generated using ACTS, PICT, or CASA should be prioritized before testing.', NULL);
INSERT INTO `list` VALUES (766, '2018-08-28', 2009, 'inproceedings', 'Mohammed I. Younis, Kamal Z. Zamli', 'ITTW: T-way minimization strategy based on intersection of tuples', 'Generation', '', '2009 IEEE Symposium on Industrial Electronics and Applications', 'ISIEA', '1', '', 'not found', '', '10.1109/ISIEA.2009.5356469', 'Combinatorial Testing', 'Despite being an important activity in the software development cycle (i.e. to ensure quality and reliability), exhaustive testing is prohibitively impossible. Systematic minimization strategy based on coverage or t-way parameter interactions are often sought for to help minimize the test space. Unlike coverage based minimization strategy which takes a white box approach, t-way parameter interactions based strategy (i.e. termed t-way testing) takes a black box approach in the sense that no information regarding the implementation is required to perform the reduction. Instead, t-way testing strategy solely relies on parameter interactions between input variables. Building from earlier work, this paper proposes a new strategy, called ITTW, to minimize the number of test set using the intersection of t-way tuples. In doing so, this paper also demonstrates the correctness of the ITTW strategy. Additionally, this paper also compares ITTW strategy against existing strategies, namely: IPOG, IPOD, IPOF, IPOF2, ITCH, Jenny, TVGII, and TConfig. The results demonstrate that ITTW, in most cases, outperforms other existing strategies in terms of test size and execution time.', NULL);
INSERT INTO `list` VALUES (768, '2018-08-28', 2018, 'inproceedings', 'Sven Dominka, Michael Mandl, Michael Dubner, Dominik Ertl', 'Using combinatorial testing for distributed automotive features: Applying combinatorial testing for automated feature-interaction-testing', 'Application', '', '2018 IEEE 8th Annual Computing and Communication Workshop and Conference (CCWC)', 'CCWC', '', '', '490-495', '', '10.1109/CCWC.2018.8301632', 'Combinatorial Testing', 'Modern passenger cars have a comprehensive embedded distributed system with a huge number of bus devices interlinked in several communication networks. The number of (distributed) features and hence the risk of undesired feature-interaction within this distributed system rises significantly. Such distributed automotive features pose a huge challenge in terms of efficient testing. Bringing together Combinatorial Testing with Automated Feature-Interaction Testing reduces the testing effort for such features significantly.', NULL);
INSERT INTO `list` VALUES (769, '2018-08-28', 2018, 'article', 'Jose Torres-Jimenez, Idelfonso Izquierdo-Marquez, Himer Avila-George', 'Search-based software engineering for constructing covering arrays', 'Generation', 'Search Based', '2018 IET Software', 'IET Softw', '12', '4', '324-332', 'IET', 'https://doi.org/10.1049/iet-sen.2018.5141', 'Combinatorial Testing', 'Search-based software engineering involves the application of optimisation methods to solve software engineering problems. One of the most significant difficulties in testing software systems is the effort needed to build the test suites required to validate a software system, which efficiently exposes faults. Given the importance of the software testing stage, a specific sub-area known as search-based software testing has become relevant in recent years. In this work, a search-based software testing algorithm for constructing covering arrays is proposed. A covering array is a combinatorial structure that can be used as a set of test cases. By utilising this algorithm, the authors reduce the size of 893 test suites.', NULL);
INSERT INTO `list` VALUES (772, '2018-08-28', 2014, 'inproceedings', 'Hanefi Mercan, Cemal Yilmaz', 'Pinpointing Failure Inducing Event Orderings', 'Generation', 'Sequence CA', '2014 The 25th IEEE International Symposium on Software Reliability EngineeringAt: Naples, ITALY', 'ISSRE', '', '', '232–237', '', '10.1109/ISSREW.2014.34', 'Combinatorial Testing', 'Abstract and Figures\r\nA new method is designed to pinpoint failure inducing event orderings in Event Based Systems. Sequence Covering Arrays are used as test suites for systems under test which have only deterministic type of failures. After testing all test cases of SCA to get full coverage on event orderings of length 2 and 3, new test cases are generated using a new method inspired from Delta Debugging Algorithm. Suspicious set of event orderings which are most likely failures, are constructed for each failure type, and this sets are narrowed down adaptively with the result of newly generated test cases. Experiments are carried out with different fault scenarios. Our results suggest that proposed algorithm can detect all failure inducing event orderings using small number of extra test cases.', NULL);
INSERT INTO `list` VALUES (777, '2018-08-28', 2011, 'article', 'Victor V Kuliamin, AA Petukhov', 'A survey of methods for constructing covering arrays', 'Generation', 'Survey', '2011 Programming and Computer Software', 'Prog. Comput. Softw.', '37', '3', '121–146', 'Springer', 'https://doi.org/10.1134/S0361768811030029', 'Combinatorial Testing', 'The paper presents a survey of methods for constructing covering arrays used in generation of tests for interfaces with a great number of parameters. The application domain of these methods and algorithms used in them are analyzed. Specific characteristics of the methods, including time complexity and estimates of the required memory, are presented. Various—direct, recursive, optimization, genetic, and backtracking—algorithms used for constructing covering arrays are presented. Heuristics are presented that allow one to reduce arrays without loss of completeness, and application domains of these heuristics are outlined.', NULL);
INSERT INTO `list` VALUES (778, '2018-08-28', 2018, 'inproceedings', 'Manuel Leithner, Kristoffer Kleine, Dimitris E. Simos', 'CAmetrics: A tool for advanced combinatorial analysis and measurement of test sets', 'Application', 'Tool', '2018 IEEE International Conference on Software Testing, Verification and Validation Workshops (ICSTW)', 'IWCT', '', '', '318-327', '', '10.1109/ICSTW.2018.00067', 'Combinatorial Testing', 'Combinatorial testing (CT) has established itself as an efficient and effective approach for generating test sets, guaranteeing that all interactions of parameters up to a given strength t are covered. While numerous publications in recent years have addressed the problem of generating Covering Arrays (CAs), the central mathematical construct used in CT, as well as measuring various aspects of these test sets, there is a distinct lack of usable and automated means to derive these measurements and thus determine the combinatorial quality of a test set and evaluate the behavior of the algorithm that produced it. We therefore introduce cametrics, a tool to compute various combinatorial coverage measures of a given test set, distribution of parameter value combinations, i.e. how the different t-tuples are distributed, as well as distance metrics and coverage gain per test. Such combinatorial analysis of test sets is crucial also for practitioners to estimate the residual risk that remains after testing by revealing untested parameter interactions. The tool is available as a web-based application allowing users to easily visualize the combinatorial metrics computed for test sets. Our experimental evaluation and the feature set of cametrics compares favorably to existing tools in the field.', NULL);
INSERT INTO `list` VALUES (780, '2018-08-28', 2016, 'inproceedings', 'Lydie du Bousquet, Mickael Delahaye, Catherine Oriat', 'Applying a pairwise coverage criterion to scenario-based testing', 'Application', '', '2016 International Conference on Software Testing, Verification and Validation Workshops', 'ICSTW ', '', '', '83-91', '', '10.1109/ICSTW.2016.23', 'Combinatorial Testing', 'Some scenario-based testing approaches propose to express a test suite as a regular expression (called scenario or pattern). It specifies a set of valid sequences of operations in a abstract way. When the regular expression is \"unfold\", test sequences are obtained. Usually, the unfolding is done in an exhaustive way, which can result in a combinatorial explosion. In this article, we explore a pairwise coverage criterion to select a subset of test sequences satisfying the pattern, in order to decrease the number of test sequences. The originality of the approach lies in the fact that the pairwise criterion is applied to the instantiated method calls (and not on the parameters). We applied this strategy to generate unit tests for Java classes. The quality of the test suites is evaluated with a mutation analysis and compared to test suites randomly generated.', NULL);
INSERT INTO `list` VALUES (781, '2018-08-28', 2016, 'inproceedings', 'Charles J. Colbourn, Violet R Syrotiuk', 'Coverage, location, detection, and measurement', 'Evaluation', '', '2016 IEEE Ninth International Conference on Software Testing, Verification and Validation Workshops (ICSTW)', 'IWCT', '', '', '19-25', '', '10.1109/ICSTW.2016.38', 'Combinatorial Testing', 'Complex engineered systems arise throughout computing, communications, and networking. Many factors, each having a finite number of levels, impact the behaviour of the system either singly or in interaction with one another. Testing or evaluating such a system involves formulating a set of tests, when executed, responses or outcomes from the tests are analyzed. A single round of testing is conducted. To witness the effect of an interaction, some test must cover it, this does not suffice in general to locate the interaction or to measure its effect. When there are few factors or many tests, experimental designs can measure (and hence locate) the interactions. When there are many factors and few tests, can we locate the interaction(s)? Can we efficiently detect them?Combinatorial arrays, locating and detecting arrays, are introduced to address such location and detection in the context of combinatorial testing. Locating and detecting arrays are contrasted with covering arrays and with experimental designs. An application to a 75 factor protocol stack for file transfer is given to demonstrate their practical use. Finally, their place in the literature of combinatorial testing is discussed and some directions are outlined.', NULL);
INSERT INTO `list` VALUES (783, '2018-08-28', 2012, 'inproceedings', 'Soumen Maity', 'Software testing with budget constraints', 'Application', '', '2012 Ninth International Conference on Information Technology - New Generations, \r\n  title=Software Testing with Budget Constraints', 'ITNG ', '', '', '258-262', '', '10.1109/ITNG.2012.44', 'Combinatorial Testing', 'This article deals with constructions of covering arrays which are extremely useful in software testing in order to guarantee 3-way coverage of parameter values, while trying to minimize the number of test cases. A practical limitation in the realm of testing is budget. In most software development environments, time, computing and human resources needed to perform the testing of a component is strictly limited. In order to deal with such situations, we consider the problem of creating the best possible test suite (covering the maximum number of 3-tuples) within a fixed number of test cases. This paper proposes a method of constructing strength three covering arrays with budget constraints.', NULL);
INSERT INTO `list` VALUES (784, '2018-08-28', 2014, 'article', 'AA Petukhov', 'Mixed optimization combinatorial method for constructing covering arrays', 'Generation', '', '2014 Programming and Computer Software', 'Prog. Comput. Softw.', '40', '1', '10-–20', 'Springer', 'https://doi.org/10.1134/S036176881401006X', 'Combinatorial Testing', 'Covering arrays are used for generating tests for interfaces with a large number of parameters. In this paper, a new method is described for constructing homogeneous and heterogeneous covering arrays that is based on a combination of combinatorial and optimization methods. In a wide class of particular cases, the method speeds up the construction of arrays several times (depending on a particular case) compared with well-known, widely used optimization methods. In most cases, the sizes of the arrays obtained are approximately the same as those of the arrays constructed by other optimization methods; in a number of particular cases, one could obtain arrays that are smaller by 5–15%. The application range of the new method is analyzed.', NULL);
INSERT INTO `list` VALUES (786, '2018-08-28', 2018, 'inproceedings', 'Xu Guo, Xiaoyu Song, Jian-tao Zhou', 'Effective Discrete Memetic Algorithms for Covering Array Generation', 'Generation', 'Search Based', '2018 Annual Computer Software and Applications Conference', 'COMPSAC', '', '', '298-303', '', 'https://doi.org/10.1109/COMPSAC.2018.00047', 'Combinatorial Testing', 'Combinatorial testing is an important software engineering problem. Covering array generation (CAG), a discrete optimization problem, is the most popular field of research in combinatorial testing (CT). The problem has attracted many researchers in the community of software engineering. This paper presents two novel versions of discrete particle-swarm-simulated-annealing-based memetic algorithms named D-PSMA for CAG problem. We elaborate with both particle swarm optimization searching operators and simulated annealing local searching operators synthetically to equilibrate the exploration and exploitation capabilities. The concept of suboptimal solution acceptance rate is introduced for excellent suboptimal solution. After each iteration, multiple test cases are generated that improve the efficiency of test suite generation. Meanwhile, an improved boundary constraint strategy are proposed. In the experiment, we used different test suite generation strategies, boundary constraint strategies and discrete memetic algorithm in the general framework, and found the optimal combination for CAG problem. Extensive experiments demonstrate that D-PSMA has competitiveness when compared to other existing classical algorithms.', NULL);
INSERT INTO `list` VALUES (787, '2018-08-28', 2007, 'inproceedings', 'Jangbok Kim, Kyunghee Choi, Daniel M. Hoffman, Gihyun Jung', 'White box pairwise test case generation', 'Generation', '', '2007 International Conference on Quality Software', 'QSIC', '', '', '286-291', '', '10.1109/QSIC.2007.4385509', 'Combinatorial Testing', 'Pairwise testing is an intuitive approach to test case generation, and has already seen use in commercial tools and practical applications. Pairwise testing is black box, in the sense that the test selection is independent of the internal structure of the system. We present a white box extension which selects additional test cases for the system based on specifications for one or more internal sub- operations. We have developed a novel algorithm for generating test cases for the full system which achieve pairwise coverage of the sub-operations. We have evaluated the algorithm using a case study, which indicates the practicality and effectiveness of the approach.', NULL);
INSERT INTO `list` VALUES (790, '2018-08-28', 2018, 'inproceedings', 'Dale Blue, Orna Raz, Rachel Tzoref-Brill, Paul Wojciak, Marcel Zalmanovici', 'Proactive and pervasive combinatorial testing', 'Application', '', '2018 International Conference on Software Engineering: Software Engineering in Practice', 'ICSE', '', '', '144-152', '', 'https://doi.org/10.1145/3183519.3183522', 'Combinatorial Testing', 'Combinatorial testing (CT) is a well-known technique for improving the quality of test plans while reducing testing costs. Traditionally, CT is used by testers at testing phase to design a test plan based on a manual definition of the test space. In this work, we extend the traditional use of CT to other parts of the development life cycle. We use CT at early design phase to improve design quality. We also use CT after test cases have been created and executed, in order to find gaps between design and test. For the latter use case we deploy a novel technique for a semi-automated definition of the test space, which significantly reduces the effort associated with manual test space definition. We report on our practical experience in applying CT for these use cases to three large and heavily deployed industrial products. We demonstrate the value gained from extending the use of CT by (1) discovering latent design flaws with high potential impact, and (2) correlating CT-uncovered gaps between design and test with field reported problems.', NULL);
INSERT INTO `list` VALUES (791, '2018-08-28', 2018, 'inproceedings', 'Rubing Huang, Weiwen Zong, Tsong Yueh Chen, Dave Towey, Jinfu Chen, Yunan Zhou, Weifeng Sun', 'On the Selection of Strength for Fixed-Strength Interaction Coverage Based Prioritization', 'Optimization', 'Priority', '2018 Annual Computer Software and Applications Conference', 'COMPSAC', '01', '', '310-315', '', '10.1109/COMPSAC.2018.00049', 'Combinatorial Testing', 'Abstract test cases are derived by modeling the system under test, and have been widely applied in practice, such as for software product line testing, and combinatorial testing. Abstract test case prioritization (ATCP) is used to prioritize abstract test cases, and aims at achieving higher rates of fault detection. Many ATCP algorithms have been proposed, using different prioritization criteria and information. One ATCP approach makes use of fixed-strength level-combinations information covered by abstract test cases, and is called fixed-strength interaction coverage based prioritization (FICBP). Before using FICBP, the prioritization strength λ needs to be decided. Previous studies have generally focused on λ values ranging between 1 and 6. However, no study has investigated the appropriateness of such a range, nor how to assign the prioritization strength for FICBP. To answer these questions, this paper reports on an empirical study involving four real-life programs (each of which with six versions). The experimental results indicate that λ should be set approximately equal to a value corresponding to half of the number of parameters, when testing resources are sufficient. Our results also show that when testing resources are limited or insufficient, either small or large λ values are suggested for FICBP', NULL);
INSERT INTO `list` VALUES (792, '2018-08-28', 2018, 'inproceedings', 'Lampros Pyrgas, Paris Kitsos', 'A Hybrid FPGA Trojan Detection Technique Based-on Combinatorial Testing and On-chip Sensing', 'Application', '', '2018 International Symposium on Applied Reconfigurable Computing. Architectures, Tools, and Applications', 'ARC', '10824', '', '294--303', '', 'https://doi.org/10.1007/978-3-319-78890-6_24', 'Combinatorial Testing', 'A hybrid Hardware Trojan detection technique is proposed in this paper that combines Combinatorial Testing in order to consistently trigger the Hardware Trojan, if one is present, and a grid of compact on-chip sensors in order to detect differentiations in the circuit of the FPGA. Each sensor mainly consist of a three stage Ring Oscillator and a compact Residue Number System ring counter and requires just two FPGA slices, leading to a total overhead of less than 2% in hardware resources. The proposed technique was tested on a cryptographic module performing AES cipher. To emulate the effects of a Hardware Trojan, we used a 64-bit Linear Feedback Shift Register. The experimental results prove that the proposed hybrid technique can detect the presence of a Hardware Trojan.', NULL);
INSERT INTO `list` VALUES (794, '2018-08-28', 2017, 'inproceedings', 'Lixin Wang', 'A reduction method of combinatorial testing based on input parameter constraints', 'Generation', 'Constraint', '2017 International Conference on Communication Software and Networks', 'ICCSN', '', '', '1482-1485', '', '10.1109/ICCSN.2017.8230354.', 'Combinatorial Testing', 'Firstly, the definitions of software combination coverage test and several combinatorial coverage algorithms are briefly introduced, and the advantages and defects of the combinatorial testing methods are compared. Then the concepts of input parameters constraints are descripted in detail. At last, a method of reducing the combinatorial test case sets based on parameter constraint relations is presented, and the experimental results of the reducing method are shown. From the aspect of the test case number, the two reduction results of the full combinational test case and pairwise based on parameter constraints are compared in the experiment, and the test case number rates of after and before reducing are 39.1% and 80.7%, respectively.', NULL);
INSERT INTO `list` VALUES (798, '2018-08-28', 2018, 'inproceedings', 'Hermann Felbinger, Franz Wotawa, Mihai Nica', 'Adapting unit tests by generating combinatorial test data', 'Application', '', '2018 International Workshops on Combinatorial Testing', 'IWCT', '', '', '352-355', '', '10.1109/ICSTW.2018.00072.', 'Combinatorial Testing', 'Conventional unit tests are still mainly handcrafted. Generalizing conventional unit tests to parameterized unit tests supports automatic test data generation. Methods that were introduced to instantiate parameterized unit tests with concrete values as test data are based on search based approaches, dynamic symbolic execution, or property based testing. In this work, we introduce an approach that retrofits existing conventional unit tests into parameterized unit tests by generalization, and generate test data by combinatorial valuation to adapt existing conventional unit test suites. We conduct an empirical study to investigate whether our test suite adaption approach is beneficial in terms of additional fault detection capabilities and code coverage. Our results show that mutation score and condition coverage increase with feasible effort compared to existing conventional unit tests.', NULL);
INSERT INTO `list` VALUES (800, '2018-08-28', 2016, 'article', 'Youngil Kim, Dae-Heung Jang, Christine M. Anderson-Cook', 'Graphical methods for evaluating covering arrays', 'Evaluation', '', '2016 Quality and Reliability Engineering International', 'QREI', '32', '4', '1467-1481', 'Wiley Online Library', 'https://doi.org/10.1002/qre.1857', 'Combinatorial Testing', 'Covering arrays relax the condition of orthogonal arrays by only requiring that all combination of levels be covered but not requiring that the appearance of all combination of levels be balanced. This allows for a much larger number of factors to be simultaneously considered but at the cost of poorer estimation of the factor effects. To better understand patterns between sets of columns and evaluate the degree of coverage to compare and select between alternative arrays, we suggest several new graphical methods that show some of the patterns of coverage for different designs. These graphical methods for evaluating covering arrays are illustrated with some examples. Copyright © 2015 John Wiley & Sons, Ltd.', NULL);
INSERT INTO `list` VALUES (801, '2018-08-28', 2017, 'article', 'Youngil Kim, Dae-Heung Jang, Christine M. Anderson-Cook', 'Selecting the best wild card entries in a covering array', 'Generation', '', '2017 Quality and Reliability Engineering International', 'QREI', '33', '7', '1615-1627', 'Wiley Online Library', 'https://doi.org/10.1002/qre.2129', 'Combinatorial Testing', 'For some covering arrays, there are some wild card positions in the array where there is flexibility about what factor levels can be chosen with no impact on the basic properties of covering array, because all of the required pairs have been covered. The choice of how to fill these wild card positions can influence other properties, such as the degrees of orthogonality or three-way coverage of the array. In this paper, some criteria are proposed for identifying the best choices for the wild card positions to create covering arrays with highly desirable properties. Accompanying graphical summaries are also described to highlight differing performance for several examples. Copyright © 2017 John Wiley & Sons, Ltd.', NULL);
INSERT INTO `list` VALUES (802, '2018-08-28', 2012, 'inproceedings', 'Arnaud Gotlieb, Aymeric Hervieu, Benoit Baudry', 'Minimum pairwise coverage using constraint programming techniques', 'Generation', 'Constraint', '2012 International Conference on Software Testing, Verification and Validation', 'ICST', '', '', '773-774', '', '10.1109/ICST.2012.174', 'Combinatorial Testing', 'This paper presented the global constraint pairwise that can be used to enforce the presence of a given pair within a set of test cases or configurations. It also introduced several optimizations for implementing a method that computes the minimum set of test cases that covers pairwise. In addition, the method, seen as a constraint optimization problem, provides a way to compromise between time and efficiency by allowing anytime interruption or time-contract execution. Our approach has been implemented and evaluated on several instances of a test configurations generation problems [5] where input variables are boolean only. We envision to address other instances of these problem where the variables take their values in larger finite domains.', NULL);
INSERT INTO `list` VALUES (803, '2018-08-28', 2017, 'inproceedings', 'Joseph Morgan, Ryan Lekivetz, Tom Donnelly', 'Covering arrays: Evaluating coverage and diversity in the presence of disallowed combinations', 'Evaluation', 'Constraint', '2017 IEEE 28th Annual Software Technology Conference (STC)', 'STC', '', '', '1-4', '', '10.1109/STC.2017.8234455.', 'Combinatorial Testing', 'Test engineers are often faced with the challenge of selecting test cases that maximize the chance of discovering faults while working with a limited budget. Combinatorial testing is an effective test case selection strategy to address this challenge. The basic idea is to select test cases that ensure that all possible combinations of settings from two (or more) inputs are accounted for, regardless of which subset of two (or more) inputs are selected. Currently, combinatorial testing usually implies a covering array as the underlying mathematical construct. Yet, despite their demonstrated utility, practitioners sometimes encounter challenges that impede their use. For example, given a covering array with constraints on allowed combinations of settings for some subset of inputs, it is often unclear how to assess the coverage and diversity [2] properties of the resulting covering array.', NULL);
INSERT INTO `list` VALUES (804, '2018-08-28', 2013, 'inproceedings', 'Jose Torres-Jimenez', 'A max-SAT-based approach to constructing optimal covering arrays', 'Generation', '', '2013 International Conference of the Catalan Association for Artificial Intelligence Research and Development', 'CCIA', '256', '', 'not found', '', '10.3233/978-1-61499-320-9-51', 'Combinatorial Testing', 'This paper investigates a new exact method for constructing optimal covering arrays based on first encoding the problem as a Partial MaxSAT instance, and then solving the resulting instance with a state-of-the-art MaxSAT solver. To this end, we define an original MaxSAT encoding for covering arrays, and report on the experimentation performed to evaluate our MaxSAT-based approach. The obtained results indicate that MaxSAT is a good alternative for constructing optimal covering arrays, and it is worth to further investigate this new research direction in the area of combinatorial designs.', NULL);
INSERT INTO `list` VALUES (805, '2018-08-28', 1998, 'inproceedings', 'Brett Stevens, Eric Mendelsohn', 'Efficient software testing protocols', 'Application', '', '1998 Proceedings of the 1998 Conference of the Centre for Advanced Studies on Collaborative Research', 'other', '', '', '22', '', '10.5555/783160.783182,', 'Combinatorial Testing', 'Testing software against failure rapidly, efficiently and comprehensively is of vital importance to software programmers and designers. Complete testing is far too slow and costly. Randomized testing can suffer from deficiencies of the pseudo-random number generator used. Testing all pairwise input interactions is a relatively new idea that resolves this problem. It is extraordinarily efficient; the number of test cases only grows as the log of the number of inputs. Recent evidence shows that the vast majority of all software failures are single or pairwise input interactions. A test protocol that covers all pairwise interactions of inputs is called a covering array. For applications, the central issue is to be able to produce small covering arrays with given parameters on demand. This paper presents a number of methods to generate efficient pairwise testing protocols. A software package using these methods to generate test protocols is also discussed.', NULL);
INSERT INTO `list` VALUES (806, '2018-08-28', 2009, 'inproceedings', 'Daniel Hoffman, Lewis Sobotkiewicz, Hong-Yi Wang, Paul Strooper, Gary Bazdell, Brett Stevens', 'Test generation with context free grammars and covering arrays', 'Generation', '', '2009 Testing: Academic and Industrial Conference - Practice and Research Techniques', 'TAIC-PART', '', '', '43-47', '', '10.1109/TAICPART.2009.35', 'Combinatorial Testing', 'Covering arrays and context-free grammars have seen extensive use in software test generation. A covering-array algorithm takes a list of domains and generates a subset of the cartesian product of the domains. A grammar-based test generation (GBTG) algorithm takes a grammar G and generates a subset of the language accepted by G. Covering arrays and GBTG are usually applied independently. We show that CFG rules and covering-array specifications can be freely intermixed, with precise, intuitive semantics and efficient generation. We present a novel approach for ``tagging\'\' grammars with specifications for mixed-strength covering arrays, a generalization of conventional covering arrays. We have developed algorithms for test generation and implemented a tool for generating test cases from tagged grammars.', NULL);
INSERT INTO `list` VALUES (809, '2018-08-28', 2015, 'inproceedings', 'Alexandre Chaves da Silva, Lucas Roberto Correa, Luiz Alberto Vieira Dias, Adilson Marques da Cunha', 'A Case Study Using Testing Technique for Software as a Service (SaaS)', 'Application', '', '2015 International Conference on Information Technology: New Generations', 'ITNG', '', '', '761-62', '', '10.1109/ITNG.2015.133', 'Combinatorial Testing', 'In the second semester of 2013, during the development of the Customer Relationship Management (CRM) System at Brazilian global company, there was the necessity to execute software testing. However, it was done using techniques, such as Script-based Testing, Integration Testing and User Acceptance Testing. These techniques were inadequate to the cloud environment. Thus, the pair wise technique was chosen for the software cloud testing. Comparing the results from the traditional techniques to the pair wise testing it was noticed that the number of test cases was reduced and testing time was cut by one-sixth. So, it was concluded that pair wise testing is effective as an initial testing technique in the cloud, in conditions in which it is applicable.', NULL);
INSERT INTO `list` VALUES (810, '2018-08-28', 2014, 'article', 'Jinfu Chen, Qing Li, Chengying Mao, Dave Towey, Yongzhao Zhan, Huanhuan Wang', 'A Web services vulnerability testing approach based on combinatorial mutation and SOAP message mutation', 'Application', '', '2014 Service Oriented Computing and Applications', 'other', '8', '1', '1-13', 'Springer', 'https://doi.org/10.1007/s11761-013-0139-1', 'Combinatorial Testing', 'The testing of Web services is an essential aspect of their quality assurance, however, because this testing often involves injecting only one mutant at one time, some vulnerability faults cannot be detected. To address this, the current paper presents a set of mutation operators that can be combined and defines the corresponding combinatorial strategies based on data perturbation and combinatorial testing. Based on this, multiple mutants can be injected at one time to help uncover interactive faults. To improve testing efficiency and effectiveness, a combinatorial testing approach focusing on Web service vulnerability is proposed: Firstly, initial test data are generated with perturbation techniques based on Web Services Description Language documents and Simple Object Access Protocol messages. Then, a combinatorial testing cases generation (CTCG) algorithm is used to generate the final combinatorial test data according to the proposed strategies. Furthermore, for some special Web services in which there is only one parameter or one method in service interface, a fuzzy mutation approach algorithm, as a complementary approach to CTCG, is also proposed. Finally, some testing experiments are conducted to verify the effectiveness of the proposed approaches in an integrated testing platform. The experiments show that proposed approaches are both feasible and effective: They can find more vulnerability faults than the traditional approaches.', NULL);
INSERT INTO `list` VALUES (812, '2018-08-28', 2010, 'inproceedings', 'Victor Kuliamin, Alexander Petukhov', 'Covering arrays generation methods survey', 'Generation', 'Survey', '2010 International Symposium On Leveraging Applications of Formal Methods, Verification and Validation', 'ISoLA', '', '', '382--396', '', 'https://doi.org/10.1007/978-3-642-16561-0_36', 'Combinatorial Testing', 'This paper is a survey of methods for covering arrays generation. Covering arrays are used in test data generation for program interfaces with many parameters. The effectiveness and the range of application of these methods are analysed. The algorithms used in these methods are analysed for their time complexity and memory usage. In this paper combinatorial, recursive, greedy algorithms are observed. Several heuristics for reducing the size and the time for construction of covering arrays are observed.', NULL);
INSERT INTO `list` VALUES (813, '2018-08-28', 2018, 'inproceedings', 'Hao Jin, Takashi Kitamura, Eun-Hye Choi, Tatsuhiro Tsuchiya', 'A satisfiability-based approach to generation of constrained locating arrays', 'Generation', '', '2018 International Workshops on Combinatorial Testing', 'IWCT', '', '', '285-294', '', '10.1109/ICSTW.2018.00062', 'Combinatorial Testing', 'A locating array is a mathematical object that is intended to be used for fault localization in combinatorial interaction testing. However, applying it to a real-world testing is difficult because a system under test often has constraints among test parameter values. Test cases must satisfy such constraints to be executed; but the definition of locating arrays does not consider constraints. Hence directly using a locating array as a test suite results in interactions that are not tested as well as faulty interactions that cannot be identified. In this paper, we propose a method of generating Constrained Locating Arrays (CLAs), which are a constraint-aware extension of locating arrays. The proposed method uses a Satisfiability Modulo Theories (SMT) solver to search for a CLA. Experimental results show that the proposed method is often fast enough to find a minimum CLA for a nontrivial case.', NULL);
INSERT INTO `list` VALUES (814, '2018-08-28', 2018, 'inproceedings', 'Yuper Lay Myint, Hironori Washizaki, Yoshiaki Fukazawa, Hideyuki Kanuka, Hiroki Ohbayashi', 'Test case reduction based on the join condition in pairwise coverage-based database testing', 'Application', '', '2018 International Workshops on Combinatorial Testing', 'IWCT', '', '', '239-243', '', '10.1109/ICSTW.2018.00055.', 'Combinatorial Testing', 'Testing database applications correctly and effectively remains an issue. This study improves Selected Pairwise Coverage Testing (SPCT), which is a pairwise coverage-based test method for database applications that can discover bugs not detected by conventional methods. Because SPCT considers only selected columns in the SQL query and the conditions in the simple WHERE clause, achieving full pairwise coverage has some redundancies. In this work, we propose a new pairwise coverage-based test method, Join-based Pairwise Coverage Testing (JPCT) by considering the condition in the JOIN clause to further reduce the redundant parameter combinations. The experimental results are evaluated to con?rm the effectiveness of the proposed method, JPCT compared to SPCT.', NULL);
INSERT INTO `list` VALUES (818, '2018-08-28', 2018, 'inproceedings', 'Ryan Lekivetz, Joseph Morgan', 'Fault Localization: Analyzing Covering Arrays Given Prior Information', 'Diagnosis', '', '2018 International Conference on Software Quality, Reliability and Security Companion', 'QRS-C', '', '', '116-121', '', '10.1109/QRS-C.2018.00033.', 'Combinatorial Testing', 'Covering arrays are being increasingly used as a tool to determine test cases for testing complex engineered systems. The primary appeal of using covering arrays for this purpose is that they are an efficient way to construct test cases that are effective at precipitating failures that are due to the combination of several inputs. However, when failures occur, determining the inputs that triggered the failures is usually a time consuming task. In this article we present a method that allows a test engineer to efficiently analyze the outcomes of a set of test cases by making use of prior knowledge about the system under test. This analysis provides a ranking of input combinations that potentially triggered the failures.', NULL);
INSERT INTO `list` VALUES (819, '2018-08-28', 2013, 'inproceedings', 'Toshifusa Sekizawa, Tsugu Kotorii', 'A case study: Verification of specifications of an embedded system and generation of verification items using pairwise testing', 'Application', '', '2013 Asia-Pacific Software Engineering Conference', 'APSEC', '2', '', '146-151', '', '10.1109/APSEC.2013.130.', 'Combinatorial Testing', 'Ensuring the reliability of embedded systems has become very important. Reliability may be ensured by a number of formal methods. We study one such verification technique by applying it to an in-house development product in Mitsubishi Space Software Co., Ltd. This is a practical industrial case study, we describe our approaches and present verification results. Our aim is to check the correctness of specifications which include a set of constraints on parameters individually called an evaluation item. To that end, we adopt model checking and satisfiability checking. In our study, we set conversion rules from specifications to formal models. Part of the conversion is done by hand in this study. Manual generation limits the preparation of individual evaluation items. To overcome this limitation we present an approach for automatically generating combinations of parameters for verification by applying the pair wise testing method. Finally, we present experimental results. Note that the application of formal techniques, in this setting, is still in its preliminary stages. It is intended to develop formal techniques to the point where products may be automatically verified.', NULL);
INSERT INTO `list` VALUES (820, '2018-08-28', 2018, 'inproceedings', 'Konrad Fogen, Horst Lichter', 'Combinatorial testing with constraints for negative test cases', 'Generation', 'Constraint', '2018 International Workshops on Combinatorial Testing', 'IWCT', '', '', '328-331', '', '10.1109/ICSTW.2018.00068.', 'Combinatorial Testing', 'Constraint handling is an important extension of combinatorial testing to exclude irrelevant combinations which could otherwise lead to the input masking effect. A special handling of invalid values is also important because of potential input masking. Unfortunately, existing CT approaches only consider invalid values explicitly. Invalid value combinations are equally important but only indirectly supported . Therefore, we present a concept that allows to specify invalid value combinations as logical expressions to generate negative test cases.', NULL);
INSERT INTO `list` VALUES (821, '2018-08-28', 2018, 'inproceedings', 'Artur Andrzejak, Thomas Bach', 'Practical amplification of condition/decision test coverage by combinatorial testing', 'Application', '', '2018 International Workshops on Combinatorial Testing', 'IWCT', '', '', '341-347', '', '10.1109/ICSTW.2018.00070', 'Combinatorial Testing', 'Test suites in complex software projects might grow over time to considerable sizes, incurring high maintenance effort and prolonged execution times. Maintaining their quality and efficiency require pruning of redundancies while increasing, or at least retaining their coverage levels. We propose a lightweight method to tackle these problems with focus on condition/decision coverage (C/D coverage). First, we describe a method to reduce the size of unit tests suites while preserving the degree of their C/D coverage. We then introduce an approach which combines combinatorial testing and input space modeling to further increase the degree of the C/D coverage. Our semi-automated method works even in absence of models or documentation, and it produces a low number of new test cases requiring queries to a test oracle. We also do not use symbolic execution techniques due to their complexity and limited tool availability for some languages. These properties make our approach practically applicable in industrial projects, and simpler to implement. We evaluate our approach on selected examples from SAP HANA, a very large industrial application in C++. We demonstrate that it is possible to generate from integration tests new suites of unit tests with high C/D-coverage but with only few test cases. At the same time, the human effort of creating such suites is moderate.', NULL);
INSERT INTO `list` VALUES (822, '2018-08-28', 2016, 'inproceedings', 'Dimitris E. Simos, Kristoffer Kleine, Artemios G. Voyiatzis, D. Richard Kuhn, Raghu N. Kacker', 'TLS Cipher Suites Recommendations: A Combinatorial Coverage Measurement Approach', 'Application', '', '2016 International Conference on Software Quality, Reliability and Security', 'QRS', '', '', '69-73', '', '10.1109/QRS.2016.18.', 'Combinatorial Testing', 'We present a coverage measurement for TLS cipher suites recommendations provided by various regulatory and intelligence organizations such as the IETF, Mozilla, ENISA, German BSI, and USA NSA. These cipher suites are measured and analyzed using a combinatorial approach, which was made feasible via developing the necessary input models. Besides shedding light on the coverage achieved by the proposed recommendations, we discuss implications towards aspects of test quality. One of them relates to the testing of a TLS implementation, where a system designer or tester should expand the TLS cipher suite registry and integrate the information back to the TLS implementation itself such that the (overall) testing effort is reduced.', NULL);
INSERT INTO `list` VALUES (823, '2018-08-28', 2012, 'inproceedings', 'Ismail Ari, Erdi Olmezougullari, Hasan Sozer', 'Application of combinatorial testing techniques in complex event processing engines', 'Application', '', '2012 Signal Processing and Communications Applications Conference', 'SPCA', '', '', '1-4', '', '10.1109/SIU.2012.6204535', 'Combinatorial Testing', 'Testing practice has a critical place during the design, implementation and integration of software, hardware and complex systems composed of these. Cost of failures caused by bugs that could not be detected and fixed early in the process increase in a multiplicative way and adversely affect the overall projects costs. However, trying to do comprehensive tests generating correct outputs is also costly both time-wise and money-wise. Combinatorial Testing Techniques (CTT) have been a preferred method in software testing due to their quantifiable case coverage guarantees and appropriateness for automation. We observed that, Complex Event Processing (CEP) engines - commonly used today for real-time analysis over critical, high-volume signal processing applications (e.g. mobile communication, sensors, radar) - are NOT being systematically tested with approaches such as CTT. In this paper, we uniquely show applicability of CTT to CEP for fast creation of continuous query test suites and obtain promising results.', NULL);
INSERT INTO `list` VALUES (825, '2018-08-28', 2017, 'inproceedings', 'Syahrul Afzal Che Abdullah, Zainal Hisham Che Soh, Shahrani Shahbudin, Kamal Z. Zamli', 'Integrating crash recovery support for t-way test generation strategy', 'Application', '', '2017 International Conference on Electrical, Electronics and System Engineering', 'ICEESE', '', '', '17-20', '', '10.1109/ICEESE.2017.8298403', 'Combinatorial Testing', 'not found', NULL);
INSERT INTO `list` VALUES (826, '2018-08-28', 2018, 'article', 'Himer Avila-George, Jose Torres-Jimenez, Idelfonso Izquierdo-Marquez', 'Improved pairwise test suites for non-prime-power orders', 'Generation', '', '2018 IET Software', 'IET Softw', '', '', '215-224', 'IET', 'https://doi.org/10.1049/iet-sen.2017.0107', 'Combinatorial Testing', 'Software testing has become a critical component of the modern software development process. Therefore, a lot of research has been done in this area in recent years, and as a result new algorithms, methodologies, and tools have been created. One of the most used testing strategies is pairwise testing; this technique ensures that all possible combinations of values between any two input parameters are covered by at least one test. In this work, a new algorithm called add factor and stochastic optimisation (AFSO) is used to build small pairwise test suites for non-prime-power orders. Starting from an orthogonal array of order urn:x-wiley:17518806:media:sfw2bf00156:sfw2bf00156-math-0002, AFSO iteratively adds a factor and then reduces to zero the number of uncovered combinations by means of a simulated annealing algorithm. The results of the AFSO algorithm improved the size of 92 pairwise test suites with non-prime-power orders. One of these improved test suites is used in a real-word application to show the usefulness of the new results.', NULL);
INSERT INTO `list` VALUES (828, '2018-08-28', 2017, 'inbook', 'Wei-Tek Tsai, Guanqiu Qi', 'Combinatorial Testing in Cloud Computing', 'Application', '', '2017 Combinatorial Testing in Cloud Computing', 'other', '', '', 'not found', 'Springer Singapore', 'not found', 'Combinatorial Testing', 'Introduces readers to an advanced combinatorial testing approach that delivers outstanding efficiency and effectiveness\r\n\r\nProvides a combinatorial testing solution for the cloud environment\r\n\r\nAddresses both theoretical and practical aspects of combinatorial testing and Testing-as-a-Service\r\n\r\nUses mathematical methods to detect fault locations and eliminate potential faults from testing considerations based on existing testing results', NULL);
INSERT INTO `list` VALUES (830, '2018-08-28', 2016, 'inproceedings', 'Juliana Marino Balera, Valdivino Alexandre de Santiago Junior', 'A controlled experiment for combinatorial testing', 'Generation', '', '2016 Brazilian Symposium on Systematic and Automated Software Testing', 'SAST', '', '', '1-10', '', 'https://doi.org/10.1145/2993288.2993289', 'Combinatorial Testing', 'In this paper, we present a controlled experiment for combinatorial designs algorithms aiming at software test case generation. We compare our recently proposed algorithm, TTR, to generate Mixed-Level Covering Array (MCA) with four other well-known combinatorial designs algorithms/tools regarding two aspects: cost in terms of the size of the set of test cases, and cost in terms of the time to generate the test suites. We used a set of 27 instances for this experiment. Results show that our algorithm was the best in terms of the size of the test suite, but was the poorest in terms of the time to generate the test cases. However, the not so good performance of our algorithm regarding the time to generate the test suite can be alleviated by the fact that TTR produces shorter set of test cases to be executed. We also made a comparison about the similarity of the test cases, i.e. to realize how similar are the test suites (test input data) of TTR compared with the other four algorithms/tools. We conclude that the TTR\'s test suite is not similar to any other test suites meaning that our algorithm has the potential to uncover different software defects by exercising different parts of the Software Under Test (SUT).', NULL);
INSERT INTO `list` VALUES (831, '2018-08-28', 2015, 'inproceedings', 'Ameen A Ba Homaid, AbdulRahman A. Alsewari', 'A variable combinatorial test suite strategy based on modified greedy algorithm', 'Generation', '', '2015 International Conference on Software Engineering and Computer Systems', 'ICSECS', '', '', '154-159', '', '10.1109/ICSECS.2015.7333101.', 'Combinatorial Testing', 'A software should be tested before released to the market to be sure that a software has been achieved the quality assurance measurement objectives. Therefore, one of the testing sorts is the combinatorial interaction testing (CIT) which is intended to discover the faults that are happened by interacting between the software features. Test case generation is the most active area of CIT research. As the problem of generating the most minimum test suite of CIT is NP-hard (i.e. NP where NP terms Non-deterministic Polynomial). Several researchers have been addressed the combinatorial interaction testing issues by developing the various strategies based on a search-based approach or a pure-computational approach, although, these are useful, but most of them have a lack to support the variable strength interaction which is one of CIT techniques. A variable strength interaction is the interaction between some of software features which have higher priority than the interaction between the others software features. This proposed will suggest a new CIT strategy based on a modified greedy algorithm (MGA) with addressing the supporting of variable strength interaction to generate a satisfactory test suite size.', NULL);
INSERT INTO `list` VALUES (832, '2018-08-28', 2016, 'inproceedings', 'Itai Segall', 'Repeated Combinatorial Test Design - Unleashing the Potential in Multiple Testing Iterations', 'Application', '', '2016 International Conference on Software Testing, Verification and Validation', 'ICST', '', '', '12-21', '', '10.1109/ICST.2016.14.', 'Combinatorial Testing', 'Test design is the process of planning and designing the tests to be performedon a software system. The time scale at which organizations perform and modifytheir test design is typically orders of magnitude larger than that ofdevelopment, especially in modern agile development processes. As a result, often the carefully designed and optimized test suites end up beingrepeatedly executed with no variability between iterations, thus wasting crucialtime and resources. In this work we propose a repeated test planningprocess based on Combinatorial Test Design (CTD), where test iterations areplanned and executed while taking into account the previously executediterations. While each iteration satisfies the same test requirements as before, we leverage the degrees of freedom in test planning in order to reach fullcoverage of higher levels of requirements over the course of iterations. Wesuggest algorithms for doing so efficiently, and evaluate our approach over aset of models collected from different sources in literature. The evaluation demonstrates significant improvement in coverage rate of higher levels, comparedto the naïve approaches.', NULL);
INSERT INTO `list` VALUES (833, '2018-08-28', 2017, 'inproceedings', 'M.S. Shwetha', 'Recast IPOG-D Algorithm with Constraint Handling for Combinatorial Testing', 'Generation', 'Constraint', '2017 International Conference on Recent Advances in Electronics and Communication Technology', 'ICRAECT', '', '', '179-185', '', '10.1109/ICRAECT.2017.62.', 'Combinatorial Testing', 'Testing is considered as indispensable part in the development process life cycle of any software. Testing is performed to improve the performance, quality and reliability of the software. Designing of relevant test cases plays a major role in deciding the quality of testing. Hence test case designing activity is crucial for the success of testing. Combinatorial strategies are one of those most extensively used methods for generating test cases. These strategies detect failures which are caused by interactions of parameters in the Software under Test(SUT) and by using some sampling mechanisms a covering array test suite is generated. With increase in the number of parameter coverage, the t-way test size sets also increase exponentially which would result in explosion problem. This paper presents a technique to generate minimal test suites in Combinatorial testing(CT). Optimization technique used is Greedy computation strategy for mutation and selection of test cases, used in selecting the locally worst test case for elimination. That is the test case that does not cover maximum number of uncovered interactions from a pool of candidate test cases. Additionally, Branch and bound technique is used for cross over. It is used to branch for the possibilities of number of test cases as cross over inputs. If a particular test case is not possible the bounding happens, else branched for further selection of test cases as input. Experimental results show that Recast Ipog-D generates better/comparable results as compared to the existing algorithm. Additionally, Recast IPOG-D has also contributed to enhance many known Variable Strength Covering array(VSCA) that exist in literature.', NULL);
INSERT INTO `list` VALUES (834, '2018-08-28', 2008, 'inproceedings', 'Mohammed I. Younis, Kamal Z. Zamli, N.A. Mat Isa', 'Algebraic strategy to generate pairwise test set for prime number parameters and variables', 'Generation', '', '2008 International conference on computer and information technology', 'ICCIT', '', '', '1-4', '', '10.1109/ITSIM.2008.4632002.', 'Combinatorial Testing', 'Generating pairwise test set when the total number of variables is prime numbers has a remarkable property in that the test case generation process can be simplified by applying straightforward strategy that does not require any storage. This paper discusses the said algebraic strategy and compares the results with the well-known orthogonal array strategy. Additionally, this paper also demonstrates the applicability and simplicity of the strategy as compared to orthogonal array to obtain optimal test set for pairwise testing.', NULL);
INSERT INTO `list` VALUES (835, '2018-08-28', 2012, 'inproceedings', 'Mohamed Zabil Mohd Hazli', 'Sequence-based interaction testing implementation using bees algorithm', 'Generation', 'Sequence CA, Search Based', '2012 Symposium on Computers & Informatics', 'ISCI', '', '', '81-85', '', '10.1109/ISCI.2012.6222671.', 'Combinatorial Testing', 'T-way strategies is used to generate test data to detect faults due to interaction. In the literature, there are many t-way strategies developed by researchers for the past 10 years. However, most of the strategies assumed sequence-less parameter interaction. In the real world, there are many systems that consider the sequence of the input parameter in order to produce correct output. These interactions of the sequence of inputs need to be tested to avoid fault due to sequence interaction. In this paper we present a sequence-based interaction testing strategy (termed as sequence covering array) using Bees Algorithm. We discuss the implementation, present and compare the results with existing sequence covering array algorithm.', NULL);
INSERT INTO `list` VALUES (837, '2018-08-28', 2017, 'inproceedings', 'Dimitris E. Simos, Josip Bozic, Feng Duan, Bernhard Garn, Kristoffer Kleine, Yu Lei, Franz Wotawa', 'Testing TLS using combinatorial methods and execution framework', 'Application', '', '2017 IFIP International Conference on Testing Software and Systems', 'ICTSS', '', '', '162--177', '', 'https://doi.org/10.1007/978-3-319-67549-7_10', 'Combinatorial Testing', 'The TLS protocol is the standard for secure Internet communication between two parties. Unfortunately, there have been recently successful attacks like DROWN or BREACH that indicate the necessity for thoroughly testing TLS implementations. In our research work, we focus on automated test case generation and execution for the TLS security protocol, where the aim is to make use of combinatorial methods for providing test cases that ideally also reveal previously unknown attacks. This is made feasible by creating appropriate input parameter models for different messages that can appear in a TLS message sequence. In this paper, we present the resulting test case generation and execution framework together with the corresponding testing oracle. Furthermore, we discuss first empirical results obtained using different TLS implementations and their releases.', NULL);
INSERT INTO `list` VALUES (839, '2018-08-28', 2016, 'article', 'Priti Bansal, Sangeeta Sabharwal, Nitish Mittal, Sarthak Arora', 'ABC-CAG: Covering Array Generator for Pair-wise Testing Using Artificial Bee Colony Algorithm', 'Generation', 'Search Based', '2016 e-Informatica Software Engineering Journal', 'EISEJ', '10', '1', '9-29', '', '10.5277/e-Inf160101', 'Combinatorial Testing', 'Testing is an indispensable part of the software development life cycle. It is performed to improve the performance, quality and reliability of the software. Various types of testing such as functional testing and structural testing are performed on software to uncover the faults caused by an incorrect code, interaction of input parameters, etc. One of the major factors in deciding the quality of testing is the design of relevant test cases which is crucial for the success of testing. In this paper we concentrate on generating test cases to uncover faults caused by the interaction of input parameters. It is advisable to perform thorough testing but the number of test cases grows exponentially with the increase in the number of input parameters, which makes exhaustive testing of interaction of input parameters imprudent. An alternative to exhaustive testing is combinatorial interaction testing (CIT) which requires that every t-way interaction of input parameters be covered by at least one test case. Here, we present a novel strategy ABC-CAG (Artificial Bee Colony-Covering Array Generator) based on the Artificial Bee Colony (ABC) algorithm to generate covering an array and a mixed covering array for pair-wise testing. The proposed ABC-CAG strategy is implemented in a tool and experiments are conducted on various benchmark problems to evaluate the ecacy of the proposed approach. Experimental results show that ABC-CAG generates better/comparable results as compared to the existing state-of-the-art algorithms', NULL);
INSERT INTO `list` VALUES (840, '2018-08-28', 2018, 'inproceedings', 'Abdullah B. Nasser, Kamal Z. Zamli', 'Parameter Free Flower Algorithm Based Strategy for Pairwise Testing', 'Generation', 'Search Based', '2018 International Conference on Software and Computer Applications', 'ICSCA', '', '', '46-50', '', 'https://doi.org/10.1145/3185089.3185109', 'Combinatorial Testing', 'Adopted to solve optimization problems, meta-heuristic algorithms aim to judiciously explore the search space in search of the good optimal solution. As such, the effectiveness of any particular meta-heuristic algorithm is heavily dependent on their control parameters, that is, to ensure balance exploration and exploitation. In the field of t-way testing, much work has been done to adopt meta-heuristic algorithms for generating interaction test suite (where t indicates the interaction strength). In this paper, we propose an Adaptive Flower Pollination Algorithm (AFPA) for pairwise testing. Unlike the original Flower Pollination Algorithm (FPA), our AFPA removes the static probability dependency inherent in FPA (i.e. for selection of local and global search operator). Specifically, we allow a dynamic and adaptive probability instead. The experimental results show that AFPA can produce the optimum results in many cases. AFPA also demonstrates its capacity to dynamically control global and local search based on the system configuration.', NULL);
INSERT INTO `list` VALUES (841, '2018-08-28', 2018, 'inproceedings', 'Robert Binder', 'Optimal scheduling for combinatorial software testing and design of experiments', 'Optimization', 'Priority', '2018 International Workshops on Combinatorial Testing', 'IWCT', '', '', '295-301', '', '10.1109/ICSTW.2018.00063.', 'Combinatorial Testing', 'Test case ordering can have significant effects on the cost, duration, or safety of a test suite. As the total number of possible orderings is n! for n test cases, finding a cost-optimal ordering can be a non-trivial problem. Combinatorial algorithms that generate t -wise test suites either explicitly randomize sequence or order them as a side effect of the algorithm. Design of experiments uses similar strategies to select test configurations and requires sequence randomization for statistical validity. Both approaches produce test sequences that are very likely sub-optimal with respect to cost. This paper presents an integer programming model that minimizes the total cost of a test sequence and notes, for experimental design, how statistical validity may be preserved for a non-random order.', NULL);
INSERT INTO `list` VALUES (842, '2018-08-28', 2018, 'inproceedings', 'Saritha Route, Sudheer Pendela', 'Combinatorial Test Design - A smarter way to connect with the business', 'Application', '', '2018 International Workshops on Combinatorial Testing', 'IWCT', '', '', '306-307', '', '10.1109/ICSTW.2018.00065.', 'Combinatorial Testing', 'A formal quality gate called the Test Readiness Review (TRR) is a typical pre-requisite for commencing System Integration Testing. For a large program that is currently underway, we were in the test design phase. There were continued delays in the Test Readiness sign off from the client. The main reason was the 300 plus open questions related to requirements clarity that was impacting the test preparation completion. To address this impasse, we introduced Combinatorial Test (CT). The aim was to provide coverage assurance and uncover gaps in tests and requirements using CT. The interactive CT design process would ensure that open questions, undocumented requirements and system interactions are highlighted using scientific methods without bias. Thus, aiding speedy closure of gaps in both requirements and test cases. We used the IBM IGNITE Method for deploying Combinatorial Test Design, which engages stakeholders and implements CT techniques with the Focus tool.', NULL);
INSERT INTO `list` VALUES (843, '2018-08-28', 2018, 'inproceedings', 'Chek Pin Yang, Gunwant Dhadyalla, James Marco, Paul Jennings', 'The effect of time-between-events for sequence interaction testing of a real-time system', 'Application', 'Sequence CA', '2018 International Workshops on Combinatorial Testing', 'IWCT', '', '', '332-340', '', '10.1109/ICSTW.2018.00069.', 'Combinatorial Testing', 'Automotive electronic control systems are expected to respond to input demands in real-time (circa: milliseconds) to ensure occupant and road user safety and comfort. System complexity and real-time computing requirements create significant challenges in proving the robustness of control systems; here robustness is the degree to which a system can function correctly in the presence of unexpected inputs. Evidence shows that faults still escape to customers incurring large warranty costs. Existing test methods can be ineffective in testing robustness with the primary focus being on requirements validation. Evidence from other industries such as IT and medical suggests faults that are difficult to find, manifest due to complex interactions and sequences of events. Whilst model based approaches are becoming more prevalent, they are still an abstraction of the real world and deal with \'time\' at this conceptual level. This can leave some doubt on their validity for representing real-time testing. However, there is little evidence within the literature pointing to effective sequence interaction testing (SIT) within real-time test environments. The novelty of the proposed approach is a methodology for creating and running t-way input sequence interaction test suites in real-time with the time between input events (TBE) considered as a critical test parameter. The effect of TBE on the triggering of faults for a safety monitoring system deployed in a prototype embedded electric machine control unit is presented to demonstrate the approach. The system is tested with 2688 3-way event sequence interaction tests across a TBE range from 1 millisecond to 500 milliseconds validating the effectiveness of the approach in eliciting faults.', NULL);
INSERT INTO `list` VALUES (844, '2018-08-28', 2018, 'inproceedings', 'Franz Wotawa', 'Combining combinatorial testing and metamorphic testing for testing a logic-based non-monotonic reasoning system', 'Application', '', '2018 International Workshops on Combinatorial Testing', 'IWCT', '', '', '348-351', '', '10.1109/ICSTW.2018.00071.', 'Combinatorial Testing', 'Combinatorial testing has proven to be a very valuable testing technique for automated generation of test suites given the domain of the inputs and the configuration parameters. In order to fully automate combinatorial testing, however, there is a need for an automated test oracle. In case of testing logic-based non-monotonic reasoning systems, we show how to generate test cases and how to make use of metamorphic testing in order to provide a test oracle. The combined testing method allows for complete test automation. We further discuss first experimental results obtained for an implementation of an assumption-based truth maintenance system implementing basic non-monotonic reasoning capabilities.', NULL);
INSERT INTO `list` VALUES (847, '2018-08-28', 2018, 'inproceedings', 'Angelo Gargantini, Marco Radavelli', 'Migrating combinatorial interaction test modeling and generation to the web', 'Application', 'Tool', '2018 International Workshops on Combinatorial Testing', 'IWCT', '', '', '308-317', '', '10.1109/ICSTW.2018.00066', 'Combinatorial Testing', 'Combinatorial Interaction Testing (CIT) is an effective technique that, however, requires a good tool support in order to be successfully applied. There are several tools and applications for CIT, and most of them are distributed as desktop applications or as special plugins of existing programs and require some installation procedures to be used. Software as a Service (SaaS) paradigm can be applied to CIT modeling and test generation, proving several advantages to the tester. There are already some attempts in this direction, but with some shortcomings (little editing support, for example). In this paper, we present CTWEDGE (Combinatorial Testing Web EDiting and GEneration), which defines a language for CIT models in the presence of constraints by using Xtext. It introduces a web service for editing CIT specifications and it interfaces, through a server, with other tools for test generation. CTWEDGE can improve the user experience by providing a complete environment for CIT modeling and generation on the web without sacrificing usability.', NULL);
INSERT INTO `list` VALUES (848, '2018-08-28', 2015, 'inproceedings', 'Juliana Marino Balera, Valdivino Alexandre de Santiago Junior', 'T-tuple reallocation: An algorithm to create mixed-level covering arrays to support software test case generation', 'Generation', '', '2015 International Conference on Computational Science and Its Applications', 'ICCSA', '', '', '503–517', '', 'https://doi.org/10.1007/978-3-319-21410-8_39', 'Combinatorial Testing', 'A fact that is known both by researchers and by industry professionals is that exhaustive software testing is impractical. Therefore, one of the most studied activities of software testing process is the generation/selection of test cases. However, selecting test cases that reveal the greatest number of defects within a software is a challenging task, due to the significantly high amount of entries that the system can receive, and even due to the different characteristics of software products in several application domains. This work presents a new algorithm, called T-Tuple Reallocation (TTR), to generate Mixed-Level Covering Array (MCA) which is one of the techniques of combinatorial designs that aims at test case generation. After studying various algorithms/techniques to generate combinatorial designs, starting with pairwise design, TTR was proposed aiming at decreasing the amount of test cases produced to test a software product. The new algorithm was able to create shorter sets of test cases in comparison with classical algorithms/tools proposed in the literature. Although TTR, in general, demanded longer time to generate the sets of test cases, this rise in time can be compensated by a smaller number of test cases so that less time is required for executing them. In the end, this may imply less time for accomplishing the testing process as a whole.', NULL);
INSERT INTO `list` VALUES (849, '2018-08-28', 2014, 'inproceedings', 'Cassiano BAL Monteiro, Luiz Alberto Vieira Dias, Adilson Marques da Cunha', 'A case study on pairwise testing application', 'Application', '', '2014 International Conference on Information Technology: New Generations', 'ITNG', '', '', '639-640', '', '10.1109/ITNG.2014.42', 'Combinatorial Testing', 'Amongst several software testing techniques, the pair wise testing presents itself as a very promising technique, drastically reducing the number of test cases for a satisfying coverage level. On the other hand, as it basically relies on empirical facts and few documented studies tackle its usage, the benefits of this technique are still uncertain. In order to better understand it, this case study presents a comparison of an ad-hoc testing against pair wise testing applied under the same conditions. Ad-hoc and pair wise test cases were generated and performed on an industry application, and the pair wise tests were able to expose exactly the same defects as the ad-hoc tests, with roughly five times less effort. With these results, it is suggested that pair wise testing, combined to other techniques, skills, and knowledge on the business might be useful to reduce testing cost while increasing test quality.', NULL);
INSERT INTO `list` VALUES (850, '2018-08-28', 2008, 'inproceedings', 'Mohammed I. Younis, Kamal Z. Zamli, Nor Ashidi Mat Isa', 'A strategy for grid based T-Way test data generation', 'Generation', '', '2008 International Conference on Distributed Framework and Applications', 'ICDFA', '', '', '73-78', '', '10.1109/ICDFMA.2008.4784416', 'Combinatorial Testing', 'Although desirable as an important activity for ensuring quality assurances and enhancing reliability, complete and exhaustive software testing is next to impossible due to resources as well as timing constraints. While earlier work has indicated that pairwise testing (i.e. based on 2-way interaction of variables) can be effective to detect most faults in a typical software system, a counter argument suggests such conclusion cannot be generalized to all software system faults. In some system, faults may also be caused by more than two parameters. As the number of parameter interaction coverage (i.e. the strength) increases, the number of t-way test set also increases exponentially. As such, for large system with many parameters, considering higher order t-way test set can lead toward combinatorial explosion problem (i.e. too many data set to consider). We consider this problem for t-way generation of test set using the Grid strategy. Building and complementing from earlier work in In-Parameter-Order-General (or IPOG) and its modification (or MIPOG), we present the Grid MIPOG strategy (G_MIPOG). Experimental results demonstrate that G_MIPOG scales well against the sequential strategies IPOG and MIPOG with the increase of the computers as computational nodes.', NULL);
INSERT INTO `list` VALUES (852, '2018-08-28', 2018, 'inproceedings', 'Hanefi Mercan, Kamer Kaya, Cemal Yilmaz', 'Enumerator: An efficient approach for enumerating all valid t-tuples', 'Generation', '', '2018 International Workshops on Combinatorial Testing', 'IWCT', '', '', '302-305', '', '10.1109/ICSTW.2018.00064', 'Combinatorial Testing', 'In this paper, we present an efficient approach for enumerating all valid t-tuples for a given configuration space model, which is an important task in computing covering arrays. The results of our experiments suggest that the proposed approach scales better than existing approaches.', NULL);
INSERT INTO `list` VALUES (853, '2018-08-28', 2009, 'inproceedings', 'James D. McCaffrey', 'Generation of pairwise test sets using a simulated bee colony algorithm', 'Generation', 'Search Based', '2009 International Conference on Information Reuse & Integration', 'IRI', '', '', '115-119', '', '10.1109/IRI.2009.5211598', 'Combinatorial Testing', 'Pairwise testing is a combinatorial technique used to reduce the number of test case inputs to a system in situations where exhaustive testing with all possible inputs is not feasible. The generation of pairwise test sets with a minimal size is an NP-complete problem and several deterministic algorithms have been published. This paper presents the results of generating pairwise test sets using a simulated bee colony algorithm. Compared to published results for seven benchmark problems, the simulated bee colony approach produced test sets which were comparable or better in terms of size for all seven problems. However, the simulated bee colony approach required significantly longer generation time than deterministic approaches in all cases. The results demonstrate that the generation of pairwise test sets using a simulated bee colony algorithm is possible, and suggest that the approach may be useful in testing scenarios where pairwise test set data will be reused.', NULL);
INSERT INTO `list` VALUES (855, '2018-08-28', 2015, 'inproceedings', 'Khandakar Rabbi, Quazi Mamun, M.D. Rafiqul Islam', 'An efficient particle swarm intelligence based strategy to generate optimum test data in t-way testing', 'Generation', 'Search Based', '2015 Conference on Industrial Electronics and Applications', 'IEACon', '', '', '123-128', '', '10.1109/ICIEA.2015.7334096', 'Combinatorial Testing', 'Limited resources and tight deadline factor inhibits exhaustive testing. Thus, generation of optimal test data in an acceptable number is very important to accelerate the overall software engineering process. Search based optimization technique has been used in software test data generation since 1992 with recently increasing interest and activity within this area. Brief literature shows that, a change to the parameter interaction (t-way interaction) can significantly reduce the number of test data. Based on this principle, many t-way test data generation strategies have been developed over the past decade. Recent finding state that, implementation of artificial intelligence based searching for test data generation can obtain near optimum solution. However, producing the optimum test data appear to be NP-hard problem (Non-deterministic polynomial). As such, it is almost impossible for a strategy to produce the optimal set of test data. With the analysis of recent studies of the valid different search based optimization approach, this paper represents a swarm intelligent based searching strategy to generate near optimum test data. The performances are analyzed and compared to other well-known strategies. Empirical result shows that the proposed strategy is highly acceptable in terms of the test data size.', NULL);
INSERT INTO `list` VALUES (856, '2018-08-28', 2015, 'inproceedings', 'Abdullah B Nasser, Yazan A. Sariera, AbdulRahman A. Alsewari, Kamal Z. Zamli', 'Assessing optimization based strategies for t-way test suite generation: the case for flower-based strategy', 'Generation', 'Search Based', '2015 International Conference on Control System, Computing and Engineering', 'ICCSCE', '', '', '150-155', '', '10.1109/ICCSCE.2015.7482175', 'Combinatorial Testing', 'Exhaustive testing is extremely difficult to perform owing to the large number of combinations. Thus, sampling and finding the optimal test suite from a set of feasible test cases becomes a central concern. Addressing this issue, the adoption of t-way testing (where t indicates the interaction strength) has come into the limelight. In order to summarize the achievements so far and facilitate future development, the main focus of this paper is, first, to present a critical comparison of adoption optimization algorithms (OA) as a basis of the t-way test suite generation strategy and, second, to propose a new t-way strategy based on Flower Pollination Algorithm, called Flower Strategy (FS). Analytical and experimental results demonstrate the applicability of FS for t-way test suite generation.', NULL);
INSERT INTO `list` VALUES (858, '2018-08-28', 2017, 'inproceedings', 'Michel Albonico, Stefano Di Alesio, Jean-Marie Mottu, Sagar Sen, Gerson Sunye', 'Generating Test Sequences to Assess the Performance of Elastic Cloud-based Systems', 'Application', '', '2017 International Conference on Cloud Computing', 'CLOUD', '', '', '383-390', '', '10.1109/CLOUD.2017.56.', 'Combinatorial Testing', 'Elasticity is one of the main features of cloud-based systems (CBSs), where elastic adaptations, such as those to deal with scaling in or scaling out of computational resources, help meet performance requirements under varying workload. There is an industrial need to find configurations of elastic adaptations and workload that could lead to degradation of performance in a CBS, serving possibly millions of users. However, the potentially great number of such configurations poses a challenge: executing and verifying all of them on the cloud can be prohibitively expensive in both, time and cost. We present an approach to model elasticity adaptation due to workload changes as a classification tree model and consequently generate short test sequences of configurations that cover all T-wise interactions between parameters in the model. These test sequences, when executed, help us assess the performance of elastic CBS. Using MongoDB as a case study, test sequences generated by our approach reveal several significant performance degradations.', NULL);
INSERT INTO `list` VALUES (859, '2018-08-28', 2010, 'inproceedings', 'Elke Salecker, Sabine Glesner', 'Pairwise test set calculation using k-partite graphs', 'Generation', '', '2010 International Conference on Software Maintenance', 'ICSM', '', '', '1-5', '', '10.1109/ICSM.2010.5609653', 'Combinatorial Testing', 'Many software faults are triggered by unusual combinations of input values and can be detected using pairwise test sets that cover each pair of input values. The generation of pairwise test sets with a minimal size is an NP-complete problem which implies that many algorithms are either expensive or based on a random process. In this paper we present a deterministic algorithm that exploits our observation that the pairwise testing problem can be modeled as a k-partite graph problem. We calculate the test set using well investigated graph algorithms that take advantage of properties of k-partite graphs. We present evaluation results that prove the applicability of our algorithm and discuss possible improvement of our approach.', NULL);
INSERT INTO `list` VALUES (860, '2018-08-28', 2018, 'inproceedings', 'Peng Sun, Xiaochuang Tang, Liang Luo', 'An Unsupervised Parameter Grouping Algorithm for Combinatorial Testing', 'Model', '', '2018 International Conference on Software Quality, Reliability and Security Companion', 'QRS-C', '', '', '377-381', '', '10.1109/QRS-C.2018.00072', 'Combinatorial Testing', 'With the development of cloud computing, cloud operating system tend to have many parameters. Cloud software testing faces the problem of a large test combination space. Combinatorial testing offers an effective testing technique for reducing test cases. Most of the current combinatorial testing methods manually conduct parameter grouping as a preprocessing step to reduce the combination space. This article proposes an automatic parameter grouping algorithm for combinatorial testing. First, the normalized mutual information is employed to measure the similarity of parameters. And a tree-structured algorithm is proposed for parameter grouping. Second, the Factorial Design method is employed to generate test cases. Finally, we apply the proposed approach for testing cloud operating system.', NULL);
INSERT INTO `list` VALUES (862, '2018-08-28', 2017, 'inproceedings', 'Chunfeng Hu, Jin Guo, Nan Li, Yao Li, Chang Rao, Siqi Liu', 'Towards Effective and Scalable Testing for Complex High-Speed Railway Signal Software', 'Application', '', '2017 International Conference on Software Quality, Reliability and Security Companion', 'QRS-C', '', '', '571-572', '', '10.1109/QRS-C.2017.98', 'Combinatorial Testing', 'Signal software for high-speed railways is safety-critical, controlling communications between trains, tracks, stations, and signals. It is necessary to test railway signal software rigorously. However, ad-hoc approaches still dominate in practice. We proposed a hybrid approach that uses combinatorial testing (CT) and model-based testing (MBT). We applied this systematic approach to testing track circuit receivers (TCRs) and compared it with an ad-hoc approach. The systematic approach was more effective than the ad-hoc approach.Although our approach is effective in testing TCR, TCR is relatively simple. Testing complex signal software used in Chinese high-speed railways can be challenging. In this paper, we summarize our approach used in testing TCR. Moreover, we identify challenges and present directions for testing complex signal systems in a scalable manner.', NULL);
INSERT INTO `list` VALUES (864, '2018-08-28', 2018, 'inproceedings', 'Jing Zhao, Gao-Rong Ning, HL Lu, YB Wang, Yan Cai, Jian Zhang', 'A weight-based approach to combinatorial test generation', 'Generation', '', '2018 International Conference on Software Engineering Companion', 'ICSE', '', '', '378-379', '', 'https://doi.org/10.1145/3183440.3195018', 'Combinatorial Testing', 'Combinatorial testing (CT) is very efficient to test parameterized systems. Kuhn et al. investigated the interaction faults of some real programs, and found that the faulty combinations are caused by the combination of no more than 6 parameters. Three or fewer parameters triggered a total of almost 90% of the failures in the application[3]. However, for high-quality software, simply testing all 3-way combinations is not sufficient [5], which may increase the risk of residual errors that lead to system failures and security weakness[4]. In addition, the number of test cases at 100% coverage for high-way is huge, which is beyond the farthest test overhead restrictions. Covering array is typically used as the test suite in CT, which should convey much information for the fault detection. We firstly proposed a weighted combinatorial coverage (CC), focusing on the fault detection capability of each test case instead of 100% percent t-way CC. Secondly, we give the test case selection algorithm FWA (fixed weight algorithm) using weighted CC metric. For generating each test case, our method first randomly generates several candidates, and selects the one that has the highest fault-detection possibility with the different sampling pool size. Thirdly, we give the theorems for our algorithm and definitions for the weighted CC. Finally, we compared the selected sample sized and the fault-detection capabilities of FWA as well as t-wise algorithms by using the four benchmarks with configuration options interaction faults, and we found FWA is able to detect higher number of faults with the less selected sample size, specifically, FWA is able to detect high-wise interaction faults with the less selected sample size compared with the 4-wise as well as 5-wise algorithms.', NULL);
INSERT INTO `list` VALUES (865, '2018-08-28', 2017, 'inproceedings', 'Rubing Huang, Yunan Zhou, Tsong Yueh Chen, Dave Towey, Jinfu Chen, Weiwen Zong', 'Prioritizing random combinatorial test suites', 'Optimization', 'Priority', '2017 Symposium on Applied Computing', 'SAC', '', '', '1183-1189', '', '10.1145/3019612.3019774', 'Combinatorial Testing', 'The behaviour of a system under test can be influenced by several factors, such as system configurations, user inputs, and so on. It has also been observed that many failures are caused by only a small number of factors.combinatorial testing aims at generating a small-sized test suite that can identify such failures. Random testing, on the other hand, selects test cases in a random manner, but has sometimes achieved similar failure-finding performance to combinatorial testing. Due to limited testing resources, test case prioritization is often employed, to attempt to identify failures as early as possible. Many prioritization studies, however, have only focused on test suites constructed by combinatorial testing, ignoring randomly constructed test suites. In this paper, we report on an investigation of test case prioritization for random combinatorial test suites. We conducted a series of empirical studies involving three real-world programs, each of which used twelve random combinatorial test suites, and adopted the well-known test case prioritization technique fixed-strength interaction coverage based prioritization (FICBP). Results from the studies indicate that, FICBP with high prioritization strength achieves better interaction coverage rate than with low prioritization strength. Furthermore, when the size of the random test suite is small, it would be better to assign a prioritization strength of 2; but otherwise, a strength of 3 would be more appropriate.', NULL);
INSERT INTO `list` VALUES (866, '2018-08-28', 2018, 'article', 'Axel Halin, Alexandre Nuttinck, Mathieu Acher, Xavier Devroey, Gilles Perrouin, Benoit Baudry', 'Test them all, is it worth it? Assessing configuration sampling on the JHipster Web development stack', 'Evaluation', '', '2018 Empirical Software Engineering', 'EMSE', '24', '2', '674-717', 'Springer', 'https://doi.org/10.1007/s10664-018-9635-4', 'Combinatorial Testing', 'Many approaches for testing configurable software systems start from the same assumption: it is impossible to test all configurations. This motivated the definition of variability-aware abstractions and sampling techniques to cope with large configuration spaces. Yet, there is no theoretical barrier that prevents the exhaustive testing of all configurations by simply enumerating them if the effort required to do so remains acceptable. Not only this: we believe there is a lot to be learned by systematically and exhaustively testing a configurable system. In this case study, we report on the first ever endeavour to test all possible configurations of the industry-strength, open source configurable software system JHipster, a popular code generator for web applications. We built a testing scaffold for the 26,000+ configurations of JHipster using a cluster of 80 machines during 4 nights for a total of 4,376 hours (182 days) CPU time. We find that 35.70% configurations fail and we identify the feature interactions that cause the errors. We show that sampling strategies (like dissimilarity and 2-wise): (1) are more effective to find faults than the 12 default configurations used in the JHipster continuous integration; (2) can be too costly and exceed the available testing budget. We cross this quantitative analysis with the qualitative assessment of JHipster’s lead developers.', NULL);
INSERT INTO `list` VALUES (867, '2018-08-28', 2013, 'article', 'Rodrigo Fraxino Araujo, Marcio Eduardo Delamaro, Jose Carlos Maldonado', 'Functional test data generation for Simulink-like models', 'Application', '', '2013 Journal of the Brazilian Computer Society', 'other', '19', '3', '325–339', 'Springer', 'https://doi.org/10.1007/s13173-013-0104-z', 'Combinatorial Testing', 'Embedded systems are increasingly present in many electronic devices and is often related to critical applications. Therefore, the need for a well planned and executed testing procedure is even higher. We intend to contribute in this area by presenting an experimental evaluation of the pairwise combinatorial approach as a technique for test data generation applied specifically to Simulink-like models. In particular, we have applied our strategy to the generated source code of several models. Furthermore, a testing tool was developed to assist in the test data generation process. We show that there is no statistical significant advantages of the proposed approach over random generation of test data, but when used together they yield better results. The feasibility of the experimental results indicate that efforts can be employed in order to obtain a testing strategy integrated within a testing environment.', NULL);
INSERT INTO `list` VALUES (868, '2018-08-28', 2016, 'article', 'Erik Rogstad, Lionel Briand', 'Cost-effective strategies for the regression testing of database applications: Case study and lessons learned', 'Optimization', 'Priority', '2016 Journal of Systems and Software', 'JSS', '113', '', '257–274', 'Elsevier', 'https://doi.org/10.1016/j.jss.2015.12.003', 'Combinatorial Testing', 'Testing and, more specifically, the regression testing of database applications is highly challenging and costly. One can rely on production data or generate synthetic data, for example based on combinatorial techniques or operational profiles. Both approaches have drawbacks and advantages. Automating testing with production data is impractical and combinatorial test suites might not be representative of system operations.\r\n\r\nIn this paper, based on a large scale case study in a representative development environment, we explore the cost and effectiveness of various approaches and their combination for the regression testing of database applications, based on production data and synthetic data generated through classification tree models of the input domain.\r\n\r\nThe results confirm that combinatorial test suite specifications bear little relation to test suite specifications derived from the system operational profile. Nevertheless, combinatorial testing strategies are effective, both in terms of the number of regression faults discovered but also, more surprisingly, in terms of the importance of these faults. However, our study also shows that relying solely on synthesized test data derived from test models could lead to important faults slipping to production. Thus, we recommend that testing on production data and combinatorial testing be combined to achieve optimal results.', NULL);
INSERT INTO `list` VALUES (871, '2018-08-28', 2014, 'article', 'Bestoun S. Ahmed, Mouayad A. Sahib, Moayad Y. Potrus', 'Generating combinatorial test cases using Simplified Swarm Optimization (SSO) algorithm for automated GUI functional testing', 'Generation', 'Search Based, Constraint', '2014 Engineering Science and Technology, an International Journal', 'other', '17', '4', '218-226', 'Elsevier', 'https://doi.org/10.1016/j.jestch.2014.06.001', 'Combinatorial Testing', 'Graphical User Interface (GUI) is the outer skin of programs that facilitate the interaction between the user and different type of computing devices. It is been used in different aspects ranging from normal computers, mobile device, to even very small device nowadays like watches. This interaction uses different tools and programming objects like images, text, buttons, checkboxes, etc. With this emergence of different types of GUIs, they become an essential component to be tested (if available in the software) to ensure that the software meets the required quality by the user. In contrast to non-functional testing, function testing of GUI insures a proper interaction between the user and the application interface without dealing with the coding internals. In this paper, a strategy for GUI functional testing using Simplified Swarm Optimization (SSO) is proposed. The SSO is used to generate an optimized test suite with the help of Event-Interaction Graph (EIG). The proposed strategy also manages and repairs the test suites by deleting the unnecessary event sequences that are not applicable. The proposed generation algorithm based on SSO has proved its effectiveness by evaluating it against other algorithms. In addition, the strategy is applied on a standard case study and proved its applicability in reality.', NULL);
INSERT INTO `list` VALUES (872, '2018-08-28', 2012, 'article', 'Manisha Patil, PJ Nikumbh', 'Pair-wise testing using simulated annealing', 'Generation', 'Search Based', '2012 Procedia Technology', 'other', '4', '', ' 778-782', 'Elsevier', 'https://doi.org/10.1016/j.protcy.2012.05.127', 'Combinatorial Testing', 'Pair-wise testing is a combinatorial testing technique that tests all possible pairs of input values. Although, finding a smallest set of test cases for pair-wise testing is NP-complete. In this paper we formulate the problem of finding a pair-wise test set as a search problem and apply a search technique “simulated annealing” to solve it.', NULL);
INSERT INTO `list` VALUES (873, '2018-08-28', 2018, 'article', 'Dimitris E. Simos, Josip Bozic, Bernhard Garn, Manuel Leithner, Feng Duan, Kristoffer Kleine, Yu Lei, Franz Wotawa', 'Testing TLS using planning-based combinatorial methods and execution framework', 'Application', '', '2018 Software Quality Journal', 'Softw. Qual. J', '27', '2', '703-729', 'Springer', 'https://doi.org/10.1007/s11219-018-9412-z', 'Combinatorial Testing', 'The TLS protocol is the standard for secure Internet communication between two parties. Unfortunately, there have been recently successful attacks like DROWN, ROBOT, or BREACH that indicate the necessity for thoroughly testing TLS implementations. In our research work, we focus on automated test case generation and execution for the TLS security protocol, where the aim is to combine planning with combinatorial methods for providing test cases that ideally also reveal previously unknown attacks. This is made feasible by creating appropriate input parameter models for different messages that can appear in a TLS message sequence. In this paper, we present the resulting test case generation and execution framework together with the corresponding test oracle. Furthermore, we discuss in detail empirical results obtained via testing different TLS implementations.', NULL);
INSERT INTO `list` VALUES (874, '2018-08-28', 2018, 'article', 'Sunint Kaur Khalsa, Yvan Labiche', 'Extending Category Partition\'s Base Choice criterion to better support constraints', 'Generation', 'Search Based', '2018 Journal of Software: Evolution and Process', 'JSEP', '30', '3', 'not found', 'Wiley Online Library', 'https://doi.org/10.1002/smr.1868', 'Combinatorial Testing', 'To ensure software is performing as intended, it can be black-box or white-box tested. Category partition is a black-box, specification-based testing technique that begins by identifying the parameters, categories (characteristics of parameters), and choices (acceptable values for categories). These choices are then combined to form test frames on the basis of various criteria such as Base Choice and Each Choice. To ensure that the combinations of choices are feasible, constraints on choices are introduced. Combining choices, while accounting for constraints, to form an each choice adequate test set is feasible (eg, using constrained covering arrays from combinatorial testing). However, the Base Choice criterion has not been defined to specifically account for constraints on choices, resulting in adverse consequences. In this paper, we introduce two extensions to the Base Choice criterion, namely, Constrained Base Choice and Extended Constrained Base Choice to specifically account for (complex) constraints on choices. We use a number of academic and industrial case studies to compare different adequacy criteria, including the new ones, in terms of cost and effectiveness at finding faults. Results show the performance of the new criteria equivalent to a 3-way combination criterion with a much smaller cost.', NULL);
INSERT INTO `list` VALUES (875, '2018-08-28', 2018, 'inproceedings', 'Lizhi Cai, Yang Zhang, Weijia Ji', 'Variable Strength Combinatorial Test Data Generation Using Enhanced Bird Swarm Algorithm', 'Generation', 'Search Based', '2018 International Conference on Software Engineering, Artificial Intelligence, Networking and Parallel/Distributed Computing', 'SNPD', '', '', '391-398', '', '10.1109/SNPD.2018.8441104', 'Combinatorial Testing', 'combinatorial testing is an effective black box testing technique for the system with large numbers of parameters and their values. However, for significantly complex and key systems, combinatorial testing still owns high complexity. Testing completely the core part of these systems usually is a kind of solution and Variable strength combinatorial test data generation (VS-CTDG) emerges. In this paper, enhanced bird swarm algorithm (EBSA), a variant of Bird Swarm Algorithm (BSA), is employed into the problem. Moreover, a testing requirement reduction is proposed and makes EBSA more suitable into VS-CTDG than ever. Through benchmarks, EBSA is proved an effective approach.', NULL);
INSERT INTO `list` VALUES (876, '2018-08-28', 2010, 'inproceedings', 'Bestoun S. Ahmed, Kamal Z. Zamli', 'PSTG: a t-way strategy adopting particle swarm optimization', 'Generation', 'Search Based', '2010 Asia International Conference on Mathematical/Analytical Modelling and Computer Simulation', 'other', '', '', '1-5', '', '10.1109/AMS.2010.14', 'Combinatorial Testing', 'As an activity to ensure quality and conformance, testing is one of the most important activities in any software or hardware product development cycle. Often, the challenge in testing is that the system may support a wide range of configurations. Ideally, it is desirable to test all of these configurations exhaustively. However, exhaustive testing is practically impossible due to time and resource limitations. To address this issue, there is a need for a sampling strategy that can select a subset of inputs as test data from an inherently large search space. Recent findings demonstrate that t-way interaction testing strategies based on artificial intelligence (i.e. where t indicates interaction strength) have been successful to obtain a near optimal solution resulting into smaller test set to be considered. Motivated by such findings, we have developed a new test generation strategy, called Particle Swarm Test Generator (PSTG). In this paper, we discuss the design of PSTG and demonstrate our preliminary test size reduction results against other competing t-way strategies including IPOG, WHITCH, Jenny, TConfig, and TVG.', NULL);
INSERT INTO `list` VALUES (877, '2018-08-28', 2018, 'article', 'Abdullah B. Nasser, Kamal Z. Zamli, AbdulRahman A. Alsewari, Bestoun S. Ahmed', 'An elitist-flower pollination-based strategy for constructing sequence and sequence-less t-way test suite', 'Generation', 'Search Based', '2018 International Journal of Bio-Inspired Computation', 'other', '12', '2', '1758-0366', '', '10.5555/3282619.3282622', 'Combinatorial Testing', 'In line with the upcoming of a new field called search-based software engineering SBSE, many newly developed t-way strategies adopting meta-heuristic algorithms can be seen in the literature for constructing interaction test suite such as simulated annealing SA, genetic algorithm GA, ant colony optimisation algorithm ACO, particle swarm optimisation PSO, harmony search HS and cuckoo search CS. Although useful, most of the aforementioned t-way strategies have assumed sequence-less interactions amongst input parameters. In the case of reactive system, such an assumption is invalid as some parameter operations or events occur in sequence and hence, creating a possibility of bugs triggered by the order or sequence of input parameters. If t-way strategies are to be adopted in such a system, there is also a need to support test data generation based on sequence of interactions. In line with such a need, this paper presents a unified strategy based on the new meta-heuristic algorithm, called the elitist flower pollination algorithm eFPA, for sequence and sequence-less coverage. Experimental results demonstrate the proposed strategy gives sufficiently competitive results as compared with existing works.', NULL);
INSERT INTO `list` VALUES (879, '2018-08-28', 2014, 'inproceedings', 'Ute Zeppetzauer, Peter M. Kruse', 'Automating test case design within the classification tree editor', 'Application', 'Tool', '2014 Federated Conference on Computer Science and Information Systems', 'other', '', '', '1585-1590', '', '10.15439/2014F263', 'Combinatorial Testing', 'This paper describes how the proven test design technique of the classification tree method is extended within the classification tree editor in order to contribute to current test design matters. The classification tree editor not only provides the tooling to use the method but also to apply new and helpful features in the test design process. This includes the automatic generation of test cases and test sequences according to desired test depth and focus, automated boundary value analysis, various tool couplings to integrate in each individual test process and supporting features like test evaluation or test coverage analysis amongst others.', NULL);
INSERT INTO `list` VALUES (881, '2018-08-28', 2014, 'inproceedings', 'Jenny Li, Tony Savor', 'Detecting DoS attacks on notification services', 'Application', '', '2014 International Conference on Software Security and Reliability - Companion', 'SERE', '', '', '192-198', '', '10.1109/SERE-C.2014.38', 'Combinatorial Testing', 'A notification service alerts a large number of recipients of important or emergency events in a timely manner. A Denial of Service (DoS) attack inserts unnecessary traffic to slow down or choke the notification service. A challenge of detecting DoS attacks lies in distinguishing them from temporary surges in normal traffic. This paper proposes an escalation hierarchy to detect DoS attacks by monitoring performance degradations at various levels. Our analysis shows the effectiveness of the approach. Further trials are underway.', NULL);
INSERT INTO `list` VALUES (883, '2018-08-28', 2004, 'article', 'Alan Hartman, Leonid Raskin', 'Problems and algorithms for covering arrays', 'Generation', 'Constraint', '2004 Discrete Mathematics', 'other', '284', '1-3', '149-156', 'Elsevier', 'https://doi.org/10.1016/j.disc.2003.11.029', 'Combinatorial Testing', 'Covering arrays are combinatorial structures which extend the notion of orthogonal arrays and have applications in the realm of software testing. In this paper we raise several new problems motivated by these applications and discuss algorithms for their solution.', NULL);
INSERT INTO `list` VALUES (884, '2018-12-15', 2018, 'article', 'Rekha Jayaram, R. Krishnan', 'Approaches to Fault Localization in Combinatorial Testing: A Survey', 'Diagnosis', 'Survey', '2018 Smart Computing and Informatics', 'other', '78', '', '533-540', '', '10.1007/978-981-10-5547-8_55', 'Combinatorial Testing', 'Software program debugging involves Fault Localization which is very expensive and a time consuming task. Hence, high demand for the correct fault localization approach that can help programmers in locating faults with less manual interference. This necessity has given rise to developing different fault localization techniques each of which tries to achieve the localization process in a very effective manner. This paper tries to provide an outline to some of these approaches and also mentions the key issues observed in these approaches.', NULL);
INSERT INTO `list` VALUES (885, '2018-12-15', 2018, 'article', 'Jesús Morán, Antonia Bertolino, Claudio de la Riva, Javier Tuya', 'Automatic Testing of Design Faults in MapReduce Applications', 'Application', '', '2018 IEEE Transactions on Reliability', 'Trans. Rel.', '67', '3', '717-732', '', '10.1109/TR.2018.2802047', 'Combinatorial Testing', 'New processing models are being adopted in Big Data engineering to overcome the limitations of traditional technology. Among them, MapReduce stands out by allowing for the processing of large volumes of data over a distributed infrastructure that can change during runtime. The developer only designs the functionality of the program and its execution is managed by a distributed system. As a consequence, a program can behave differently at each execution because it is automatically adapted to the resources available at each moment. Therefore, when the program has a design fault, this could be revealed in some executions and masked in others. However, during testing, these faults are usually masked because the test infrastructure is stable, and they are only revealed in production because the environment is more aggressive with infrastructure failures, among other reasons. This paper proposes new testing techniques that aimed to detect these design faults by simulating different infrastructure configurations. The testing techniques generate a representative set of infrastructure configurations that as whole are more likely to reveal failures using random testing, and partition testing together with combinatorial testing. The techniques are automated by using a test execution engine called MRTest that is able to detect these faults using only the test input data, regardless of the expected output. Our empirical evaluation shows that MRTest can automatically detect these design faults within a reasonable time.', NULL);
INSERT INTO `list` VALUES (886, '2018-12-15', 2018, 'article', 'Deepa Gupta, Ajay Rana, Sanjay Tyagi', 'Sequence Generation of Test Case Using Pairwise Approach Methodology', 'Generation', 'Sequence', '2018 Advances in Computer and Computational Sciences', 'other', '554', '', '79-85', '', '10.1007/978-981-10-3773-3_9', 'Combinatorial Testing', 'There are various instruction specifications in the software system that interacts with each other. While designing software system, software engineers have to face a tedious task of ensuring the validation of every available software use case. If the instruction specifications are huge, the required number of use cases to validate becomes unmanageable within reasonable time budget and therefore designers have to choose one of the options of either delaying the projects or delivering without validating all available test case scenarios. Even for moderately sized software systems, comprehensive testing sometimes becomes impossible due to limited time availability for validation phase. Empirical studies have indicated that most of the faults in software systems often precipitate by interaction between smaller numbers of instruction specifications. If designers can cover all available interactions between all pairs of instructions specifications (instead of comprehensive testing), it can give reasonable confidence to designers about the software attribute within the limited time. This paper presents one such approach which uses the sequence origination approach for pairwise test case origination. This approach makes certain to propagate the required intent of trial run cases which cover all available interactions between all instructions pairs at least once. Trial run selection specification is this approach based on combinatorial testing. The paper also discusses the results with this new approach on one of the candidate software system to demonstrate its efficacy over already existing validation approaches.', NULL);
INSERT INTO `list` VALUES (887, '2018-12-15', 2018, 'article', 'Kamal Z. Zamli, Fakhrud Din, Bestoun S. Ahmed, Miroslav Bures', 'A hybrid Q-learning sine-cosine-based strategy for addressing the combinatorial test suite minimization problem', 'Generation', 'Search Based', '2018 PloS one', 'PloS one', '13', '5', 'not found', '', '10.1371/journal.pone.0195675', 'Combinatorial Testing', 'The sine-cosine algorithm (SCA) is a new population-based meta-heuristic algorithm. In addition to exploiting sine and cosine functions to perform local and global searches (hence the name sine-cosine), the SCA introduces several random and adaptive parameters to facilitate the search process. Although it shows promising results, the search process of the SCA is vulnerable to local minima/maxima due to the adoption of a fixed switch probability and the bounded magnitude of the sine and cosine functions (from -1 to 1). In this paper, we propose a new hybrid Q-learning sine-cosine- based strategy, called the Q-learning sine-cosine algorithm (QLSCA). Within the QLSCA, we eliminate the switching probability. Instead, we rely on the Q-learning algorithm (based on the penalty and reward mechanism) to dynamically identify the best operation during runtime. Additionally, we integrate two new operations (Lévy flight motion and crossover) into the QLSCA to facilitate jumping out of local minima/maxima and enhance the solution diversity. To assess its performance, we adopt the QLSCA for the combinatorial test suite minimization problem. Experimental results reveal that the QLSCA is statistically superior with regard to test suite size reduction compared to recent state-of-the-art strategies, including the original SCA, the particle swarm test generator (PSTG), adaptive particle swarm optimization (APSO) and the cuckoo search strategy (CS) at the 95% confidence level. However, concerning the comparison with discrete particle swarm optimization (DPSO), there is no significant difference in performance at the 95% confidence level. On a positive note, the QLSCA statistically outperforms the DPSO in certain configurations at the 90% confidence level.', NULL);
INSERT INTO `list` VALUES (888, '2018-12-15', 2018, 'article', 'Abdullah B. Nasser, Kamal Z. Zamli, AbdulRahman A. Alsewari, Bestoun S. Ahmed', 'Hybrid flower pollination algorithm strategies for t-way test suite generation', 'Generation', 'Search Based', '2018 PloS one', 'PloS one', '13', '5', 'not found', '', '10.1371/journal.pone.0195187', 'Combinatorial Testing', 'The application of meta-heuristic algorithms for t-way testing has recently become prevalent. Consequently, many useful meta-heuristic algorithms have been developed on the basis of the implementation of t-way strategies (where t indicates the interaction strength). Mixed results have been reported in the literature to highlight the fact that no single strategy appears to be superior compared with other configurations. The hybridization of two or more algorithms can enhance the overall search capabilities, that is, by compensating the limitation of one algorithm with the strength of others. Thus, hybrid variants of the flower pollination algorithm (FPA) are proposed in the current work. Four hybrid variants of FPA are considered by combining FPA with other algorithmic components. The experimental results demonstrate that FPA hybrids overcome the problems of slow convergence in the original FPA and offers statistically superior performance compared with existing t-way strategies in terms of test suite size.', NULL);
INSERT INTO `list` VALUES (889, '2018-12-15', 2018, 'article', 'Rubing Huang, Quanjun Zhang, Tsong Yueh Chen, James Hamlyn-Harris, Dave Towey, Jinfu Chen', 'An Empirical Comparison of Fixed-Strength and Mixed-Strength for Interaction Coverage Based Prioritization', 'Optimization', 'Priority', '2018 IEEE Access', 'Access', '6', '', '68350-68372', '', '10.1109/ACCESS.2018.2879638', 'Combinatorial Testing', 'Test case prioritization (TCP) plays an important role in identifying, characterizing, diagnosing, and correcting faults quickly. The TCP has been widely used to order test cases of different types, including model inputs (also called abstract test cases). Model inputs are constructed by modeling the program according to its input parameters, values, and constraints, and has been used in different testing methods, such as combinatorial interaction testing and software product line testing. The Interaction coverage-based TCP (ICTCP) uses interaction coverage information derived from the model input to order inputs. Previous studies have focused generally on the fixed-strength ICTCP, which adopts a fixed strength (i.e., the level of parameter interactions) to support the ICTCP process. It is generally accepted that using more strengths for ICTCP, i.e., mixed-strength ICTCP, may give better ordering than fixed-strength. To confirm whether mixed-strength is better than fixed-strength, in this paper, we report on an extensive empirical study using five real-world programs (written in C), each of which has six versions. The results of the empirical studies show that mixed-strength has better rates of interaction coverage overall than fixed-strength, but they have very similar rates of fault detection. Our results also show that fixed-strength should be used instead of the mixed-strength at the later stage of software testing. Finally, we offer some practical guidelines for testers when using interaction coverage information to prioritize model inputs, under different testing scenarios and resources.', NULL);
INSERT INTO `list` VALUES (890, '2018-12-15', 2018, 'inproceedings', 'Ammar K Alazzawi, Helmi Md Rais, Shuib Basri', 'Artificial Bee Colony Algorithm for t-Way Test Suite Generation', 'Generation', 'Search Based', '2018 International Conference on Computer and Information Sciences ', 'ICCIS', '', '', '1--6', '', '10.1109/ICCOINS.2018.8510601', 'Combinatorial Testing', 'Exhaustive testing is a very strenuous undertaking due to its numerous combinations. Consequently, searching for and sampling an optimal test suite from viable groups of test cases (TC) has turned out to be a central concern. To tackle this matter, the use of t-way testing (Where t represents the strength of the interaction) has become well known. In order to facilitate future development and summarize the realization so far, the major objective of this paper is to portray an important comparison of the introduced optimization algorithms (OA) as a base of the t-way test suite generation strategy, and to suggest a new strategy focusing on the Artificial Bee Colony (ABC) Algorithm, known as Artificial Bee Colony Strategy (ABCS). The experimental results showed that ABCS can compete against the existing (both AI-based and computational-based) strategies in terms of generating the optimum test case.', NULL);
INSERT INTO `list` VALUES (891, '2018-12-15', 2018, 'inproceedings', 'Rachel Tzoref-Brill, Shahar Maoz', 'Modify, enhance, select: co-evolution of combinatorial models and test plans', 'Model', '', '2018 International Symposium on Foundations of Software Engineering', 'FSE', '', '', '235-245', '', '10.1145/3236024.3236067', 'Combinatorial Testing', 'The evolution of software introduces many challenges to its testing. Considerable test maintenance efforts are dedicated to the adaptation of the tests to the changing software. As a result, over time, the test repository may inflate and drift away from an optimal test plan for the software version at hand. Combinatorial Testing (CT) is a well-known test design technique to achieve a small and effective test plan. It requires a manual definition of the test space in the form of a combinatorial model, and then automatically generates a test plan design, which maximizes the added value of each of the tests. CT is considered a best practice, however its applicability to evolving software is hardly explored.\r\n\r\nIn this work, we introduce a first co-evolution approach for combinatorial models and test plans. By combining three building blocks, to minimally modify existing tests, to enhance them, and to select from them, we provide five alternatives for co-evolving the test plan with the combinatorial model, considering tradeoffs between maximizing fine-grained reuse and minimizing total test plan size, all while meeting the required combinatorial coverage.\r\n\r\nWe use our solution to co-evolve test plans of 48 real-world industrial models with 68 version commits. The results demonstrate the need for co-evolution as well as the efficiency and effectiveness of our approach and its implementation. We further report on an industrial project that found our co-evolution solution necessary to enable adoption of CT with an agile development process.', NULL);
INSERT INTO `list` VALUES (892, '2018-12-15', 2018, 'article', 'Charles J. Colbourn, Violet R. Syrotiuk', 'On a combinatorial framework for fault characterization', 'Diagnosis', '', '2018 Mathematics in Computer Science', 'other', '12', '4', '429–451', '', '10.1007/s11786-018-0385-x', 'Combinatorial Testing', 'Covering arrays have been widely used to detect the presence of faults in large software and hardware systems. Indeed, finding failures that result from faulty interactions requires that all interactions that may cause faults be covered by a test case. However, finding the actual faults requires more, because the failures resulting from two potential sets of faults must not be the same. The combinatorial requirements on test suites to enable a tester to locate the faults are developed, and set in the context of similar combinatorial search questions. Test suites known as locating and detecting arrays to locate faults both in principle and in practice generalize covering arrays, thereby addressing combinatorial fault characterization. In common with covering arrays, these locating and detecting arrays scale logarithmically in size with the number of factors, but unlike covering arrays they support complete characterization of the interactions that underlie faults.', NULL);
INSERT INTO `list` VALUES (893, '2018-12-15', 2018, 'article', 'Xintao Niu, Nie Changhai, Hareton Leung, Yu Lei, Xiaoyin Wang, Jiaxi Xu, Yan Wang', 'An interleaving approach to combinatorial testing and failure-inducing interaction identification', 'Generation', '', '2018 IEEE Transactions on Software Engineering', 'TSE', '', '', 'early access', 'IEEE', '10.1109/TSE.2018.2865772', 'Combinatorial Testing', 'Combinatorial testing (CT) seeks to detect potential faults caused by various interactions of factors that can influence the software systems. When applying CT, it is a common practice to first generate a set of test cases to cover each possible interaction and then to identify the failure-inducing interaction after a failure is detected. Although this conventional procedure is simple and forthright, we conjecture that it is not the ideal choice in practice. This is because 1) testers desire to identify the root cause of failures before all the needed test cases are generated and executed 2) the early identified failure-inducing interactions can guide the remaining test case generation so that many unnecessary and invalid test cases can be avoided. For these reasons, we propose a novel CT framework that allows both generation and identification process to interact with each other. As a result, both generation and identification stages will be done more effectively and efficiently. We conducted a series of empirical studies on several open-source software, the results of which show that our framework can identify the failure-inducing interactions more quickly than traditional approaches while requiring fewer test cases.', NULL);
INSERT INTO `list` VALUES (894, '2018-12-15', 2018, 'article', 'Xintao Niu, Nie Changhai, Yu Lei, Hareton Leung, Xiaoyin Wang', 'Identifying failure-causing schemas in the presence of multiple faults', 'Diagnosis', '', '2018 IEEE Transactions on Software Engineering', 'TSE', '', '', 'early access', 'IEEE', '10.1109/TSE.2018.2844259', 'Combinatorial Testing', 'Combinatorial testing (CT) has been proven effective in revealing the failures caused by the interaction of factors that affect the behavior of a system. The theory of Minimal Failure-Causing Schema (MFS) has been proposed to isolate the cause of a failure after CT. Most algorithms that aim to identify MFS focus on handling a single fault in the System Under Test (SUT). However, we argue that multiple faults are more common in practice, under which masking effects may be triggered so that some failures cannot be observed. The traditional MFS theory lacks a mechanism to handle such effects; hence, they may incorrectly isolate the MFS. To address this problem, we propose a new MFS model that takes into account multiple faults. We first formally analyze the impact of the multiple faults on existing MFS identifying algorithms, especially in situations where masking effects are triggered by multiple faults. We then develop an approach that can assist traditional algorithms to better handle multiple faults. Empirical studies were conducted using several kinds of open-source software, which showed that multiple faults with masking effects do negatively affect traditional MFS identifying approaches and that our approach can help to alleviate these effects', NULL);
INSERT INTO `list` VALUES (895, '2018-12-15', 2018, 'article', 'Huayao Wu, Changhai Nie, Petke Justyna, Yue Jia, Mark Harman', 'An Empirical Comparison of Combinatorial Testing, Random Testing and Adaptive Random Testing', 'Evaluation', '', '2018 IEEE Transactions on Software Engineering', 'TSE', '', '', 'early access', 'IEEE', '10.1109/TSE.2018.2852744', 'Combinatorial Testing', 'We present an empirical comparison of three test generation techniques, namely, Combinatorial Testing (CT), Random Testing (RT) and Adaptive Random Testing (ART), under different test scenarios. This is the first study in the literature to account for the (more realistic) testing setting in which the tester may not have complete information about the parameters and constraints that pertain to the system, and to account for the challenge posed by faults (in terms of failure rate). Our study was conducted on nine real-world programs under a total of 1683 test scenarios (combinations of available parameter and constraint information and failure rate). The results show significant differences in the techniques\' fault detection ability when faults are hard to detect (failure rates are relatively low). CT performs best overall; no worse than any other in 98 percent of scenarios studied. ART enhances RT, and is comparable to CT in 96 percent of scenarios, but its computational cost can be up to 3.5 times higher than CT when the program is highly constrained. Additionally, when constraint information is unavailable for a highly-constrained program, a large random test suite is as effective as CT or ART, yet its computational cost of test generation is significantly lower than that of other techniques.', NULL);
INSERT INTO `list` VALUES (896, '2018-12-15', 2018, 'article', 'Hanefi Mercan, Cemal Yilmaz, Kamer Kaya', 'CHiP: A Configurable Hybrid Parallel Covering Array Constructor', 'Generation', '', '2018 IEEE Transactions on Software Engineering', 'TSE', '', '', 'early access', 'IEEE', '10.1109/TSE.2018.2837759', 'Combinatorial Testing', 'We present a configurable, hybrid, and parallel covering array constructor, called CHiP. CHiP is parallel in that it utilizes vast amount of parallelism provided by graphics processing units (GPUs). CHiP is hybrid in that it bundles the bests of two construction approaches for computing covering arrays; a metaheuristic search-based approach for efficiently covering a large portion of the required combinations and a constraint satisfaction-based approach for effectively covering the remaining hard-to-cover-by-chance combinations. CHiP is configurable in that a trade-off between covering array sizes and construction times can be made. We have conducted a series of experiments, in which we compared the efficiency and effectiveness of CHiP to those of a number of existing constructors by using both full factorial designs and well-known benchmarks. In these experiments, we report new upper bounds on covering array sizes, demonstrating the effectiveness of CHiP, and the first results for a higher coverage strength, demonstrating the scalability of CHiP.', NULL);
INSERT INTO `list` VALUES (897, '2020-01-20', 2018, 'inproceedings', 'Hao Jin, Tatsuhiro Tsuchiya', 'Deriving Fault Locating Test Cases from Constrained Covering Arrays', 'Diagnosis', 'Constraint', '2018 Pacific Rim International Symposium on Dependable Computing', 'PRDC', '', '', '233--240', '', '10.1109/PRDC.2018.00044', 'Combinatorial Testing', 'Combinatorial Interaction Testing (CIT) is a well practiced strategy for testing of software systems. Ordinary CIT detects faults caused by interactions of parameters but cannot locate faulty interactions. This paper addresses the problem of adding fault localization capability to CIT. This is done by means of fault locating suites of test cases, which are named constrained locating arrays. An algorithm that derives a constrained locating array from a test suite for ordinary CIT is proposed. Experimental results show that the new algorithm can construct constrained locating arrays for fairly large sized problem instances in reasonable time.', NULL);
INSERT INTO `list` VALUES (898, '2020-01-20', 2019, 'article', 'P. Ramgouda, V. Chandraprakash', 'Constraints handling in combinatorial interaction testing using multi-objective crow search and fruitfly optimization', 'Generation', 'Search Based, Constraint', '2019 Soft Computing', 'Soft Computing', '23', '8', '2713--2726', '', '10.1007/s00500-019-03795-w', 'Combinatorial Testing', 'Combinatorial testing strategies are the recent interest of the researchers because of their wide variety of applications. The combinatorial testing strategy posses a great deal of minimizing the count of the input parameters of a system such that a small set of parameters is obtained depending on their interaction. Practically, the input models of the software system are subjected to the constraints mainly in highly configurable systems. There exist a number of issues while integrating the constraint in the testing strategy that is overcome using the proposed method. The proposed method aims at developing the combinatorial interaction test suites in the presence of constraints. The proposed strategy is multi-objective crow search and fruitfly optimization that is developed by the integration of the crow search algorithm and the chaotic fruitfly optimization algorithm. The proposed algorithm offers an optimal selection of the test suites at the better convergence. The experimentation based on the constraints and the analysis are carried out in terms of average size and average time with their values as 10 and 30 s, respectively.', NULL);
INSERT INTO `list` VALUES (899, '2020-01-20', 2019, 'inproceedings', 'Ammar K. Alazzawi, Helmi Md Rais, Shuib Basri', 'Hybrid Artificial Bee Colony Algorithm for t-Way Interaction Test Suite Generation', 'Generation', 'Search Based', '2019 Computer Science On-line Conference', 'other', '', '', '192--199', '', '10.1007/978-3-030-19807-7\\_19', 'Combinatorial Testing', 'The very large number of test cases and time consumption for a test, it is becoming hard to perform exhaustive testing for any software fault detection. For this reason, combinatorial testing (CT) also known as t-way testing, is one of the well-known methods that are used for fault detections to many software systems. Various existing research works are available in the literature to minimize the number of test cases, and the time to obtain an optimal test suite or competitive test suite. However, the interaction strength of the existing research works are supports up to t = 2 or t = 3, where t is the strength of parameter’s interaction. The major purpose of this research is to suggest a new t-way strategy to minimize the test cases. This is called hybrid artificial bee colony (HABC) strategy, which is based on hybridize of an artificial bee colony (ABC) algorithm with a particle swarm optimization (PSO) algorithm. This is to provide a high-interaction strength combinatorial test suite up to t = 6. From experimental results, HABC strategy performed best when compared with existing methods in terms of generating the optimum test case.', NULL);
INSERT INTO `list` VALUES (900, '2020-01-20', 2019, 'article', 'Yunlong Sheng, Shouda Jiang, Chang\'an Wei', 'Constructing Test Suites for Real-Time Embedded Systems Under Input Timing Constraints', 'Application', '', '2019 IEEE Access', 'Access', '7', '', '20920--20937', '', '10.1109/ACCESS.2019.2898009', 'Combinatorial Testing', 'Testing of real-time embedded systems (RTESs) under input timing constraints is a critical issue. Models which can specify timing constraints have respective merits and demerits and test suites which can cover more input possibilities and detect more faults under input timing constraints are worthy of study. In this paper, clocked computation tree logic which is used to specify input timing constraints is presented. Neighbor covering arrays and parallel input time correlation test suites are introduced to test RTESs under serial and parallel input timing constraints. Three algorithms are described in generating test suites, respectively, and corresponding random testing-based algorithms which are used as baselines for comparison are introduced. Benchmarks with different configurations are conducted to evaluate the algorithms\' performance. Three real-world RTESs are tested with the test suites described in this paper, respectively. The test results show that random testing may omit some neighbor input time point combinations as the randomness and increase test suite scales. This fact may lead to the omission of some faults and heavy costs. Therefore, the proposed test suites are more effective and efficient for testing RTESs under input timing constraints.', NULL);
INSERT INTO `list` VALUES (901, '2020-01-20', 2019, 'inproceedings', 'Salim Ali Khan Mohammad, Sathvik Vamshi Valepe, Subhrakanta Panda, S.A.S. Rajita Bommakanti', 'A Comparative Study of the Effectiveness of Meta-Heuristic Techniques in Pairwise Testing', 'Generation', '', '2019 Annual Computer Software and Applications Conference', 'COMPSAC', '', '', '91--96', '', '10.1109/COMPSAC.2019.00022', 'Combinatorial Testing', 'In this paper, three meta-heuristic techniques are studied and their results are compared for pairwise testing by generating the test cases. The aim of this paper is to minimize the number of test cases that are needed to be checked for pairwise testing. The techniques studied are Genetic Algorithm (GA), Particle Swarm Optimization (PSO), and Elephant Herding Optimization (EHO). The test cases thus generated check the software for each pair of input parameters. The results generated using pairwise testing show that PSO and EHO perform slightly better than GA for most of the input configurations.', NULL);
INSERT INTO `list` VALUES (902, '2020-01-20', 2019, 'article', 'Bestoun S. Ahmed, Angelo Gargantini, Kamal Z. Zamli, Cemal Yilmaz, Miroslav Bures, Marek Szeles', 'Code-aware combinatorial interaction testing', 'Application', '', '2019 IET Software', 'IET Softw', '13', '6', '600--609', '', '10.1049/iet-sen.2018.5315', 'Combinatorial Testing', 'Combinatorial interaction testing (CIT) is a useful testing technique to address the interaction of input parameters in software systems. CIT has been used as a systematic technique to sample the enormous test possibilities. Most of the research activities focused on the generation of CIT test suites as a computationally complex problem. Less effort has been paid for the application of CIT. To apply CIT, practitioners must identify the input parameters for the Software-under-test (SUT), feed these parameters to the CIT test generation tool, and then run those tests on the application with some pass and fail criteria for verification. Using this approach, CIT is used as a black-box testing technique without knowing the effect of the internal code. Although useful, practically, not all the parameters having the same impact on the SUT. This paper introduces a different approach to use the CIT as a gray-box testing technique by considering the internal code structure of the SUT to know the impact of each input parameter and thus use this impact in the test generation stage. The case studies results showed that this approach would help to detect new faults as compared to the equal impact parameter approach.', NULL);
INSERT INTO `list` VALUES (903, '2020-01-20', 2019, 'inproceedings', 'Christian Eitner, Franz Wotawa', 'Crucial Tool Features for Successful Combinatorial Input Parameter Testing in an Industrial Application', 'Application', '', '2019 International Workshop on Combinatorial Testing', 'IWCT', '', '', '188--189', '', '10.1109/ICSTW.2019.00050', 'Combinatorial Testing', 'In this paper, we report on the use of available combinatorial testing tools on a large industrial object-oriented .N E T application to find out whether combinatorial testing methods are readily usable to perform combinatorial input parameter testing in an industrial setup. In particular, we applied CAmetrics and CCM to compute the combinatorial coverage of existing tests, and CAgen and ACTS to generate test suites from scratch. We identified shortcomings in some of the tools that may prevent them from being used in practice.', NULL);
INSERT INTO `list` VALUES (904, '2020-01-20', 2019, 'inproceedings', 'Riley Smith, Darryl C. Jarman, Raghu N. Kacker, D. Richard Kuhn, Dimitris E. Simos, Ludwig Kampel, Manuel Leithner, Gabe Gosney', 'Applying Combinatorial Testing to Large-Scale Data Processing at Adobe', 'Application', '', '2019 International Workshop on Combinatorial Testing', 'IWCT', '', '', '190--193', '', '10.1109/ICSTW.2019.00051', 'Combinatorial Testing', 'Adobe offers an analytics product as part of the Marketing Cloud software with which customers can track many details about users across various digital platforms. For the most part, customers define the amount and type of data to track. This high dimensionality makes validation difficult or intractable. Due to increasing attention from both industry and academia, combinatorial testing was investigated and applied to improve existing validation. In this paper, we report the practical application of combinatorial testing to the data collection, compression and processing components of the Adobe analytics product. Consequently, the effectiveness of combinatorial testing for this application is measured in terms of new defects found rather than detecting known defects from previous versions. The results of the application show that combinatorial testing is an effective way to improve validation for these components of Adobe Analytics. In addition, we report the details of the input parameter modeling process and test value selection to provide more context for the problem and how combinatorial testing provides the structure to improve validation for Adobe Analytics.', NULL);
INSERT INTO `list` VALUES (905, '2020-01-20', 2019, 'inproceedings', 'Riley Smith, Darryl C. Jarman, Jared Bellows, D. Richard Kuhn, Raghu N. Kacker, Dimitris E. Simos', 'Measuring Combinatorial Coverage at Adobe', 'Application', '', '2019 International Workshop on Combinatorial Testing', 'IWCT', '', '', '194--197', '', '10.1109/ICSTW.2019.00052', 'Combinatorial Testing', 'Adobe offers an analytics product as part of the Marketing Cloud software with which customers can track many details about users across various digital platforms. For the most part, customers define the amount and type of data to track. In addition, customers can specify many feature combinations when reporting on this data. These features create high dimensionality that makes validation challenging for some of the most critical components of the Adobe Analytics product. One of these critical components is the reporting engine. This component has a validation framework often qualitatively considered within the engineering organization as highly effective. However, the effectiveness of this framework has never been quantitatively measured. Due to recent applications of combinatorial testing, the Analytics Tools team determined to use combinatorial coverage measurements (CCM) to evaluate the effectiveness of the Replay validation framework. In this paper, we therefore report the practical application of combinatorial coverage measurements to evaluate the effectiveness of the validation framework for the Adobe Analytics reporting engine. The results of this evaluation show that combinatorial coverage measurements are an effective way to supplement existing validation for several purposes. In addition, we report details of the approach used to parse moderately nested data for use with the combinatorial coverage measurement tools.', NULL);
INSERT INTO `list` VALUES (906, '2020-01-20', 2019, 'inproceedings', 'Akihisa Yamada, Clovis Eberhart, Fuyuki Ishikawa, Nian-Ze Lee', 'Scenario Sampling for Cyber Physical Systems using Combinatorial Testing', 'Application', '', '2019 International Workshop on Combinatorial Testing', 'IWCT', '', '', '198--199', '', '10.1109/ICSTW.2019.00053', 'Combinatorial Testing', 'Physical and continuous aspects are inevitable in cyber physical systems like automated driving systems. Despite the success of combinatorial testing on discrete systems, there is a fundamental challenge in applying combinatorial testing techniques when continuous parameters are involved. This extended abstract presents an initial step towards applying combinatorial testing to systems in which discrete and continuous parameters are mixed. We define a generic XML-based language for describing the test space of such systems and provide a prototype implementation to generate test cases, using externally the combinatorial test tool PICT.', NULL);
INSERT INTO `list` VALUES (907, '2020-01-20', 2019, 'inproceedings', 'Paolo Arcaini, Angelo Gargantini, Marco Radavelli', 'Efficient and Guaranteed Detection of t-Way Failure-Inducing Combinations', 'Diagnosis', '', '2019 International Workshop on Combinatorial Testing', 'IWCT', '', '', '200--209', '', '10.1109/ICSTW.2019.00054', 'Combinatorial Testing', 'Combinatorial testing is a widely applied black-box testing technique, which is used to detect failures caused by parameter interactions (we call them failure-inducing combinations). Traditional combinatorial testing techniques provide fault detection, but most of them have weak fault diagnosis. In this paper, we propose a new fault characterization method called MixTgTe to locate all the failure-inducing combinations in a system under test, up to an interaction size decided by the user. Our method is based on adaptive black-box testing, in which test cases are generated based on outcomes of previous tests. We show that our method performs better than existing strategies that explore all the faults first, and then obtain the failure-inducing combination(s) for each failure.', NULL);
INSERT INTO `list` VALUES (908, '2020-01-20', 2019, 'inproceedings', 'Murat Ozcan', 'An Industrial Study on Applications of Combinatorial Testing in Modern Web Development', 'Application', '', '2019 International Workshop on Combinatorial Testing', 'IWCT', '', '', '210--213', '', '10.1109/ICSTW.2019.00055', 'Combinatorial Testing', 'The purpose of this study is to describe the new paradigms in front-end web application testing and how combinatorial testing (CT) fits in this modern development environment to create cost effective, highly fault-detecting automated tests. The system under test (SUT) is a cloud based application for monitoring and controlling building operations from Siemens Building Technologies, currently under development. Three examples for the applications of combinatorial testing in the front-end are analyzed, incorporating the CT model into automation using Protractor test framework\'s end-to-end (e2e) UI tests in behavioral driven development (BDD) style. The manner in which the CT model translates automation code is studied. A scenario where a sequence of actions are incorporated into a CT model is illustrated; with a focus on veri?cation of these sequences, compositions of the actions and streamlining the expected assertions per the test oracle.', NULL);
INSERT INTO `list` VALUES (909, '2020-01-20', 2019, 'inproceedings', 'Erin Lanus, Charles J. Colbourn, Douglas C. Montgomery', 'Partitioned Search with Column Resampling for Locating Array Construction', 'Generation', '', '2019 International Workshop on Combinatorial Testing', 'IWCT', '', '', '214--223', '', '10.1109/ICSTW.2019.00056', 'Combinatorial Testing', 'Locating arrays are designs used in combinatorial testing with the property that every set of d t-way interactions appears in a unique set of tests. Using a locating array to conduct fault testing ensures that faulty interactions can be located when there are d or fewer faults. Locating arrays are fairly new and few techniques have been explored for their construction. Most of the available work is limited to finding only one fault. Known general methods require a covering array of strength t+d and produce many more tests than are needed. We present Partitioned Search with Column Resampling (PSCR), a randomized computational search algorithmic framework to verify if an array is (d, t)-locating by partitioning the search space to decrease the number of comparisons. If a candidate array is not locating, random resampling is performed until a locating array is constructed or an iteration limit is reached. Results are compared against known locating array constructions from covering arrays of higher strength and against published results of mixed level locating arrays for parameters of real-world systems. The use of PSCR to build larger locating arrays from a variety of ingredient arrays is explored.', NULL);
INSERT INTO `list` VALUES (910, '2020-01-20', 2019, 'inproceedings', 'Joshua Bonn, Konrad F\\\"ogen, Horst Lichter', 'A Framework for Automated Combinatorial Test Generation, Execution, and Fault Characterization', 'Application', '', '2019 International Workshop on Combinatorial Testing', 'IWCT', '', '', '224--233', '', '10.1109/ICSTW.2019.00057', 'Combinatorial Testing', 'Fault characterization is an important part of combinatorial testing, enabling it to automatically narrow down failed test inputs to specific failure-inducing combinations. As most current fault characterization algorithms adaptively generate more test inputs based on previous test execution results, a framework that integrates modelling, generation, execution, and fault characterization is necessary. Until now, no such framework exists, resulting in much manual work needed to identify failureinducing combinations.We therefore introduce COFFEe, which is a framework for completely automatic combinatorial testing and fault characterization. In this paper, we derive an architecture for the framework and present coffee4j, a Java implementation of COFFEe that integrates the JUnit5 test framework.', NULL);
INSERT INTO `list` VALUES (911, '2020-01-20', 2019, 'inproceedings', 'Jianbo Tao, Yihao Li, Franz Wotawa, Hermann Felbinger, Mihai Nica', 'On the Industrial Application of Combinatorial Testing for Autonomous Driving Functions', 'Application', '', '2019 International Workshop on Combinatorial Testing', 'IWCT', '', '', '234--240', '', '10.1109/ICSTW.2019.00058', 'Combinatorial Testing', 'The growing importance of automated and autonomous driving systems becomes more and more visible in the industrial domain as well as in research. Validation and verification of autonomous driving functions is one of the grand challenges in autonomous vehicle development. Virtual validation using simulation has been widely discussed and proposed as a method to solve the challenge. Furthermore, scenario-based approaches have been considered as proper methods combined with virtual validation in order to identify critical scenarios. In this paper, we discuss a method for testing automated and autonomous driving functions using ontologies and combinatorial testing that is able to automate test case generation. Moreover, we report on the application of the method at the industrial level. There we depict the comprehensive application process from the construction of the ontology to test suite execution in detail. This case study shows that the proposed approach can be used for testing and validation of autonomous driving functions in practice.', NULL);
INSERT INTO `list` VALUES (912, '2020-01-20', 2019, 'inproceedings', 'Feng Duan, Yu Lei, Raghu N. Kacker, D. Richard Kuhn', 'An Approach to T-Way Test Sequence Generation With Constraints', 'Generation', 'Sequence CA', '2019 International Workshop on Combinatorial Testing', 'IWCT', '', '', '241--250', '', '10.1109/ICSTW.2019.00059', 'Combinatorial Testing', 'In this paper we address the problem of constraint handling in t-way test sequence generation. We develop a notation for specifying sequencing constraints and present a t-way test sequence generation that handles the constraints specified in this notation. We report a case study in which we applied our notation and test generation algorithm to a real-life communication protocol. Our experience indicates that our notation is intuitive to use and allows us to express important sequencing constraints for the protocol. However, the test generation algorithm takes a significant amount of time. This work is part of our larger effort to make t-way sequence testing practically useful.', NULL);
INSERT INTO `list` VALUES (913, '2020-01-20', 2019, 'inproceedings', 'Chang Rao, Nan Li, Yu Lei, Raghu N. Kacker, D. Richard Kuhn, Jin Guo', 'Using Parameter Mapping to Avoid Forbidden Tuples in a Covering Array', 'Generation', 'Constraint', '2019 International Workshop on Combinatorial Testing', 'IWCT', '', '', '251--259', '', '10.1109/ICSTW.2019.00060', 'Combinatorial Testing', 'This paper addresses an optimization problem that occurs when we try to remove from a covering array (CA) the rows that do not satisfy a given set of constraints. That is, how to minimize the number of rows to be removed? The key observation is that the columns of a CA can be swapped without affecting coverage. This makes it possible to explore different ways to map the parameters involved in the constraints to the columns in the CA, which further allows us to reduce the number of rows that must be removed. In order to find an optimal mapping, our approach maps one parameter at a time and employs a greedy algorithm that tries to minimize the number of rows to be removed at each step. We report several experiments in which we compared our approach to two other approaches, i.e., the identity-based approach, and the random approach. The results show that our approach can remove fewer rows than the other two approaches.', NULL);
INSERT INTO `list` VALUES (914, '2020-01-20', 2019, 'inproceedings', 'Hiroshi Ukai, Xiao Qu, Hironori Washizaki, Yoshiaki Fukazawa', 'Reduce Test Cost by Reusing Test Oracles through Combinatorial Join', 'Generation', 'Oracle', '2019 International Workshop on Combinatorial Testing', 'IWCT', '', '', '260--263', '', '10.1109/ICSTW.2019.00061', 'Combinatorial Testing', 'Methods to generate combinatorial test suites have been extensively studied in the combinatorial interaction testing (CIT) community, but the creation of test oracles for the test cases remains a challenging and expensive task because they are created manually. In this paper, we propose a novel technique to \"join\" multiple test suites into one while satisfying the required combinatorial coverage of the system under test. This technique allows test oracles designed and created in earlier testing phases to be reused in later ones. Our study results indicate that the technique can reduce the total test cost to design and execute a test suite by more than 55% compared to the conventional testing approach.', NULL);
INSERT INTO `list` VALUES (915, '2020-01-20', 2019, 'inproceedings', 'Miraldi Fifo, Eduard Enoiu, Wasif Afzal', 'On Measuring Combinatorial Coverage of Manually Created Test Cases for Industrial Software', 'Evaluation', '', '2019 International Workshop on Combinatorial Testing', 'IWCT', '', '', '264--267', '', '10.1109/ICSTW.2019.00062', 'Combinatorial Testing', 'Combinatorial coverage has been proposed as a way to measure the quality of test cases by using the input interaction characteristics. This paper describes the results of empirically measuring combinatorial coverage of manually created test cases by experienced industrial engineers working with embedded software development. We found that manual test cases achieve on average 78% 2-way combinatorial coverage, 57% 3-way coverage, 40% 4-way coverage, 20% 5-way combinatorial coverage and 13% for 6-way combinatorial coverage. These manual test cases can be augmented to achieve 100% combinatorial coverage for 2-way and 3-way interactions by adding eight and 66 missing test cases on average, respectively. For 4-way interactions, full combinatorial coverage can achieved by adding 658 missing test cases. For 5-way and 6-way interactions, full combinatorial coverage can be achieved by adding 5163 and 6170 missing test cases on average, respectively. The results of this paper suggest that manual test cases created by industrial engineers do not achieve a high combinatorial coverage and can be improved by adding more test cases to cover t-wise interactions at the expense of more test cases to execute.', NULL);
INSERT INTO `list` VALUES (916, '2020-01-20', 2019, 'inproceedings', 'Dale Blue, Andrew Hicks, Ryan Rawlins, Rachel Tzoref-Brill', 'Practical Fault Localization with Combinatorial Test Design', 'Diagnosis', '', '2019 International Workshop on Combinatorial Testing', 'IWCT', '', '', '268--271', '', '10.1109/ICSTW.2019.00063', 'Combinatorial Testing', 'Combinatorial test design is a well-known effective technique for test planning. However, in order to fully realize its potential in industrial settings, it needs to be considered as an integral part of the end to end testing flow rather than as an isolated component. In this work, we present an automated end to end solution for CTD-based test optimization, generation, execution and fault localization, implemented in an industrial framework. We further report on our initial promising experience in applying it to an industrial product.', NULL);
INSERT INTO `list` VALUES (917, '2020-01-20', 2019, 'inproceedings', 'Yanshan Chen, Ziyuan Wang, Dong Wang, Chunrong Fang, Zhenyu Chen', 'Variable Strength Combinatorial Testing for Deep Neural Networks', 'Application', '', '2019 International Conference on Software Testing, Verification and Validation Workshops', 'ICSTW', '', '', '281--284', '', '10.1109/ICSTW.2019.00066', 'Combinatorial Testing', 'In deep neural networks (DNNs), each neuron in the post-layer receives the influence of all the neurons in the pre-layer. As we known, different connections in a DNN model have different weights. It means that, different combinations of pre-layer neurons have different effects on the post-layer neurons. Therefore, the variable strength combinatorial testing can reflect the effect of combination interaction of neurons in the pre-layer on the neurons in the post-layer. In this paper, we propose to adopt variable strength combinatorial testing technique on DNNs testing. In order to modeling the effect of combinatorial interaction of pre-layer neurons on the post-layer neurons, we propose three methods to construct variable strength combinatorial interaction relationship for DNNs. The experimental results show that, 1) variable strength combinatorial coverage criteria are discriminating to measure the adequacy of DNNs testing, and 2) there is correlation between variable strength combinatorial coverage and adversarial detection.', NULL);
INSERT INTO `list` VALUES (918, '2020-01-20', 2019, 'inproceedings', 'Konrad F\\\"ogen, Horst Lichter', 'Combinatorial Robustness Testing with Negative Test Cases', 'Generation', '', '2019 International Conference on Software Quality, Reliability and Security', 'QRS', '', '', '34--45', '', '10.1109/QRS.2019.00018', 'Combinatorial Testing', 'Error-handling is an important means to improve the robustness of a system and testing error-handling is crucial to ensure its correctness. In this paper, we argue that error-handling leads to input masking which requires special treatment in for combinatorial testing. Therefore, we propose an extension to combinatorial testing including a robustness fault model and robustness combination strategy. We also provide an evaluation which compares its efficiency to normal combinatorial testing.', NULL);
INSERT INTO `list` VALUES (919, '2020-01-20', 2019, 'inproceedings', 'Zachary B. Ratliff, D. Richard Kuhn, Daniel J. Ragsdale', 'Detecting Vulnerabilities in Android Applications using Event Sequences', 'Application', 'Sequence CA', '2019 International Conference on Software Quality, Reliability and Security', 'QRS', '', '', '159--166', '', '10.1109/QRS.2019.00032', 'Combinatorial Testing', 'Sequence covering arrays have demonstrated their usefulness for finding software bugs that propagate via some sequence of events. However, the distribution of t-way event sequence failures has never been reported, and as a result, the practicality of using these methods is not fully known. In this paper, our analysis of the distribution of t-way interactions between events in event sequence bugs provides insight into the practicality and usefulness of this combinatorial testing method. From a developer\'s perspective, these methods can contribute to finding this particular class of bugs early in the software development process, saving the developers time and money without sacrificing effectiveness. However, an attacker may also leverage these techniques to discover previously undetected vulnerabilities as a means to exploit the system. This work involved analyzing hundreds of vulnerability reports, performing event sequence testing on two different closed source Android applications, as well as developing a combinatorial coverage measurement tool.', NULL);
INSERT INTO `list` VALUES (920, '2020-01-20', 2019, 'inproceedings', 'Caleb King, Joseph Morgan, Ryan Lekivetz', 'Design Fractals: A Graphical Method for Evaluating Binary Covering Arrays', 'Evaluation', '', '2019 International Conference on Software Quality, Reliability and Security Companion', 'QRS-C', '', '', '185--190', '', '10.1109/QRS-C.2019.00046', 'Combinatorial Testing', 'Test engineers are often faced with the challenge of selecting test cases that maximize the chance of discovering faults while working within a limited budget. Combinatorial testing is an effective test case selection strategy to address this challenge. The basic idea is to select test cases that ensure that all possible combinations of settings from two (or more) inputs are accounted for, regardless of which subset of inputs are selected. This is accomplished by using a covering array as the test case selection mechanism. However, for any given testing scenario, there are usually several alternative covering arrays that may satisfy budgetary and coverage requirements. Unfortunately, it is often unclear how to choose from these alternatives. Practitioners often want a way to explore how the input space is being covered to decide which alternative is best suited for the testing scenario. In this paper we propose a graphical method that may be used to evaluate binary covering arrays. The method allows practitioners to visualize input space coverage for inputs of interest. We illustrate the method with several examples.', NULL);
INSERT INTO `list` VALUES (921, '2020-01-20', 2019, 'inproceedings', 'Konrad F\\\"ogen, Horst Lichter', 'Repairing Over-Constrained Models for Combinatorial Robustness Testing', 'Model', '', '2019 International Conference on Software Quality, Reliability and Security Companion', 'QRS-C', '', '', '177--184', '', '10.1109/QRS-C.2019.00045', 'Combinatorial Testing', 'Testing negative scenarios is important to evaluate robustness of software systems. Error-handling can terminate the system before all values are evaluated and faults can remain undetected. Therefore, extensions for combinatorial testing separate generation of positive and negative scenarios. Unfortunately, it is easy to create over-constrained models. Certain values or value combinations are prevented from appearing in the test suite and remain untested. In this paper, we define over-constrained models and present a technique to identify and repair them.', NULL);
INSERT INTO `list` VALUES (922, '2020-01-20', 2019, 'inproceedings', 'Yifei Lu, Minxue Pan, Juan Zhai, Tian Zhang, Xuandong Li', 'Preference-wise testing for Android applications', 'Application', '', '2019 ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering', 'ESEC/FSE', '', '', '268--278', '', '10.1145/3338906.3338980', 'Combinatorial Testing', 'Preferences, the setting options provided by Android, are an essential part of Android apps. Preferences allow users to change app features and behaviors dynamically, and therefore, need to be thoroughly tested. Unfortunately, the specific preferences used in test cases are typically not explicitly specified, forcing testers to manually set options or blindly try different option combinations. To effectively test the impacts of different preference options, this paper presents PREFEST, as a preference-wise enhanced automatic testing approach, for Android apps. Given a set of test cases, PREFEST can locate the preferences that may affect the test cases with a static and dynamic combined analysis on the app under test, and execute these test cases only under necessary option combinations. The evaluation shows that PREFEST can improve 6.8% code coverage and 12.3% branch coverage and find five more real bugs compared to testing with the original test cases. The test cost is reduced by 99% for both the number of test cases and the testing time, compared to testing under pairwise combination of options', NULL);
INSERT INTO `list` VALUES (923, '2020-01-20', 2019, 'inproceedings', 'Jinkun Lin, Shaowei Cai, Chuan Luo, Qingwei Lin, Hongyu Zhang', 'Towards more efficient meta-heuristic algorithms for combinatorial test generation', 'Generation', 'Search Based', '2019 ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering', 'ESEC/FSE', '', '', '212--222', '', '10.1145/3338906.3338914', 'Combinatorial Testing', 'Combinatorial interaction testing (CIT) is a popular approach to detecting faults in highly configurable software systems. The core task of CIT is to generate a small test suite called a t-way covering array (CA), where t is the covering strength. Many meta-heuristic algorithms have been proposed to solve the constrained covering array generating (CCAG) problem. A major drawback of existing algorithms is that they usually need considerable time to obtain a good-quality solution, which hinders the wider applications of such algorithms. We observe that the high time consumption of existing meta-heuristic algorithms for CCAG is mainly due to the procedure of score computation. In this work, we propose a much more efficient method for score computation. The score computation method is applied to a state-of-the-art algorithm TCA, showing significant improvements. The new score computation method opens a way to utilize algorithmic ideas relying on scores which were not affordable previously. We integrate a gradient descent search step to further improve the algorithm, leading to a new algorithm called FastCA. Experiments on a broad range of real-world benchmarks and synthetic benchmarks show that, FastCA significantly outperforms state-of-the-art algorithms for CCAG algorithms, in terms of both the size of obtained covering array and the run time.', NULL);
INSERT INTO `list` VALUES (924, '2020-01-20', 2019, 'article', 'Jose Torres-Jimenez, Idelfonso Izquierdo-Marquez, Himer Avila-George', 'Methods to Construct Uniform Covering Arrays', 'Generation', 'Survey', '2019 IEEE Access', 'Access', '7', '', '42774--42797', '', '10.1109/ACCESS.2019.2907057', 'Combinatorial Testing', 'Uniform covering arrays are covering arrays in which every column has the same alphabet. In recent years, a number of methods to construct such arrays have been developed. Here, we review several of these methods organizing them into six classes: algebraic, recursive, exact, greedy, metaheuristic, and transformations. The objective of this paper is to highlight the strategy of some representative algorithms of each class. Most of the reviewed methods are accompanied by examples and/or pseudocodes. This paper ends with a discussion about the general strengths and weaknesses of each class of methods.', NULL);
INSERT INTO `list` VALUES (925, '2020-01-20', 2019, 'inproceedings', 'Dimitris E. Simos, Bernhard Garn, Ludwig Kampel, D. Richard Kuhn, Raghu N. Kacker', 'Knowledge Extraction for Cryptographic Algorithm Validation Test Vectors by Means of Combinatorial Coverage Measurement', 'Application', '', '2019 International Cross-Domain Conference on Machine Learning and Knowledge Extraction', 'other', '', '', '195--208', '', '10.1007/978-3-030-29726-8\\_13', 'Combinatorial Testing', 'Home  Machine Learning and Knowledge Extraction  Conference paper\r\nKnowledge Extraction for Cryptographic Algorithm Validation Test Vectors by Means of Combinatorial Coverage Measurement\r\nDownload book PDF\r\nDownload book EPUB\r\nKnowledge Extraction for Cryptographic Algorithm Validation Test Vectors by Means of Combinatorial Coverage Measurement\r\nDimitris E. Simos, Bernhard Garn, Ludwig Kampel, D. Richard Kuhn & Raghu N. Kacker \r\nConference paper\r\nFirst Online: 23 August 2019\r\n1126 Accesses\r\n\r\n1 Citations\r\n\r\nPart of the Lecture Notes in Computer Science book series (LNISA,volume 11713)\r\n\r\nAbstract\r\nWe present a combinatorial coverage measurement analysis for test vectors provided by the NIST Cryptographic Algorithm Validation Program (CAVP), and in particular for test vectors targeting the AES block ciphers for different key sizes and cryptographic modes of operation. These test vectors are measured and analyzed using a combinatorial approach, which was made feasible via developing the necessary input models. The extracted model from the test data in combination with combinatorial coverage measurements allows to extract information about the structure of the test vectors. Our analysis shows that some test sets do not achieve full combinatorial coverage. It is further discussed, how this retrieved knowledge could be used as a means of test quality analysis, by incorporating residual risk estimation techniques based on combinatorial methods, in order to assist the overall validation testing procedure.', NULL);
INSERT INTO `list` VALUES (926, '2020-01-20', 2019, 'inproceedings', 'Lei Ma, Felix Juefei Xu, Minhui Xue, Bo Li, Li Li, Yang Liu, Jianjun Zhao', 'DeepCT: Tomographic Combinatorial Testing for Deep Learning Systems', 'Application', '', '2019 International Conference on Software Analysis, Evolution and Reengineering', 'SANER', '', '', '614--618', '', '10.1109/SANER.2019.8668044', 'Combinatorial Testing', 'Deep learning (DL) has achieved remarkable progress over the past decade and has been widely applied to many industry domains. However, the robustness of DL systems recently becomes great concerns, where minor perturbation on the input might cause the DL malfunction. These robustness issues could potentially result in severe consequences when a DL system is deployed to safety-critical applications and hinder the real-world deployment of DL systems. Testing techniques enable the robustness evaluation and vulnerable issue detection of a DL system at an early stage. The main challenge of testing a DL system attributes to the high dimensionality of its inputs and large internal latent feature space, which makes testing each state almost impossible. For traditional software, combinatorial testing (CT) is an effective testing technique to balance the testing exploration effort and defect detection capabilities. In this paper, we perform an exploratory study of CT on DL systems. We propose a set of combinatorial testing criteria specialized for DL systems, as well as a CT coverage guided test generation technique. Our evaluation demonstrates that CT provides a promising avenue for testing DL systems.', NULL);
INSERT INTO `list` VALUES (927, '2020-01-20', 2019, 'article', 'Jihyun Lee, Sunmyung Hwang', 'Combinatorial Test Design Using Design-Time Decisions for Variability', 'Model', '', '2019 International Journal of Software Engineering and Knowledge Engineering', 'IJSEKE', '29', '8', '1141--1158', '', '10.1142/S0218194019400138', 'Combinatorial Testing', 'Design-time artifacts such as module structures from the module view, component diagrams from the component-and-connector view, sequence diagrams, communication diagrams, activity diagrams, or state-machine diagrams from the behavioral view of software architecture can be used to generate effective test cases for fault detection at integration testing level. Various combinatorial test design (CTD) methods have been developed for generating valid and representative product configurations for a software product line, but these methods assume that all bindings for variabilities are performed at run time. Thus, these methods have a limitation in that they do not consider design decisions for variability represented in design-time artifacts. This paper aims to propose a CTD method that uses design-time variability, called the DesignTimeCTD method, considering variability-related decisions at design stage and investigating the effectiveness of reducing the number of tests. The DesignTimeCTD uses variability model, variation points in design-time artifacts, and variability implementation mechanisms used for implementation together in order to reduce the number of tests. As a result, the CTD method, which uses design-time decisions for variability, contributes to reducing the test case by approximately 14% by allowing test engineers to consider design-time variability-related decisions together.', NULL);
INSERT INTO `list` VALUES (928, '2020-01-20', 2019, 'article', 'Ludwig Kampel, Dimitris E. Simos', 'A survey on the state of the art of complexity problems for covering arrays', 'Generation', 'Survey', '2019 Theoretical Computer Science', 'Theor Comput Sci', '800', '', '107--124', '', '10.1016/j.tcs.2019.10.019', 'Combinatorial Testing', 'In this paper, a first systematic review and analysis of the current state of the art pertaining to complexity problems for a heavily researched class of designs, namely covering arrays, is presented.', NULL);
INSERT INTO `list` VALUES (929, '2020-01-20', 2019, 'article', 'Ludwig Kampel, Manuel Leithner, Bernhard Garn, Dimitris E. Simos', 'Problems and algorithms for covering arrays via set covers', 'Generation', '', '2019 Theoretical Computer Science', 'Theor Comput Sci', '800', '', '90--106', '', '10.1016/j.tcs.2019.10.018', 'Combinatorial Testing', 'In this paper, we explore some connections between covering arrays (CAs) and set covers (SCs) that already existed in the literature, and in some cases we provide new mappings between these structures. In particular, the devised mappings make feasible an interpretation of weighted budgeted CAs (WBCAs) as weighted budgeted SCs. These connections in turn make it possible to reformulate known greedy heuristics for computing mixed-level CAs and evolve new algorithms for WBCA generation. This also enables importing an upper bound on the size or a lower bound on the covered weight of the generated arrays. We further carry out a comparison of a CA generation strategy that has an analogue in the SC world with one developed specifically for CAs.\r\n\r\nMoreover, we experiment with several problem instances for CA and WBCA generation, and compare CA solvers versus SC solvers, both in quality of their output size and covered weights, as well as computation time. Our experiments underpin the hypothesis that CA solvers provide solutions of comparable quality to the ones returned by the considered SC solvers, although the latter solvers generally provide solutions of better quality. Nevertheless, CA solvers provide solutions to the respective problem instances much faster.', NULL);
INSERT INTO `list` VALUES (930, '2020-01-20', 2019, 'inproceedings', 'Michael Wagner, Ludwig Kampel, Dimitris E. Simos', 'Quantum-Inspired Evolutionary Algorithms for Covering Arrays of Arbitrary Strength', 'Generation', 'Search Based', '2019 Analysis of Experimental Algorithms', 'other', '', '', '300--316', '', '10.1007/978-3-030-34029-2\\_20', 'Combinatorial Testing', 'The construction of covering arrays, the combinatorial structures underlying combinatorial test suites, is a highly researched topic. In previous works, various metaheuristic algorithms, such as Simulated Annealing and Tabu Search, were used to successfully construct covering arrays with a small number of rows. In this paper, we propose for the first time a quantum-inspired evolutionary algorithm for covering array generation. For this purpose, we introduce a simpler and more natural qubit representation as well as new rotation and mutation operators. We implemented different versions of our algorithm employing the different operators. We evaluate the different implementations against selected (optimal) covering array instances.', NULL);
INSERT INTO `list` VALUES (931, '2020-01-20', 2019, 'inproceedings', 'Hirofumi Akimoto, Yuto Isogami, Takashi Kitamura, Natsuko Noda, Tomoji Kishi', 'A Prioritization Method for SPL Pairwise Testing Based on User Profiles', 'Optimization', 'Priority', '2019 Asia-Pacific Software Engineering Conference', 'APSEC', '', '', '118--125', '', '10.1109/APSEC48747.2019.00025', 'Combinatorial Testing', 'In Software Product Line (SPL) development, one of promising techniques for core asset testing is to test a subset of SPL as representative products. SPL pairwise testing is a such technique in which each product corresponds to a possible feature configuration in the feature model (FM) and representative products are selected so as to all possible feature pairs are included. It is also important to prioritize representative products, because it could improve the effectiveness of core asset testing especially when the testing resource is limited. In this paper, we propose a prioritization method for SPL pairwise testing based on user profiles. A user profile is a set of user groups and their occurrence probabilities such as the percentages of user groups in a market that use specific devices, applications or services. These profiles are used as the probabilities of feature choices at decision points such as optional features and alternative features in a FM. Based on that, we calculate the probability for obtaining a feature pairs (PFP for short), and generate representative products with priority. Most researches relate to the probabilities about FM handle the probability for obtaining a single feature (PSF for short). Based on PSF, we could estimate PFP. However, this estimation is not appropriate for the prioritization especially when conditional probabilities appear in user profiles. In our method, we directly calculate PFP and determine the priorities. We evaluate the method to show advantages of prioritizations using PFP over those using PSF, and also analyze the characteristics of the method.', NULL);
INSERT INTO `list` VALUES (932, '2020-01-20', 2020, 'article', 'D. Richard Kuhn, Raghu N. Kacker, Yu Lei, Dimitris E. Simos', 'Input Space Coverage Matters', 'Model', '', '2020 IEEE Computer', 'Computer', '53', '1', '37--44', 'IEEE', '10.1109/MC.2019.2951980', 'Combinatorial Testing', 'Testing is the most commonly used approach for software assurance, yet it remains as much judgment and art as science. We suggest that structural coverage measures must be supplemented with measures of input space coverage, providing a means of verifying that an adequate input model has been defined.', NULL);
INSERT INTO `list` VALUES (933, '2020-01-20', 2019, 'article', 'Rachel Tzoref-Brill', 'Chapter Two: Advances in Combinatorial Testing', 'Other', 'Survey', '2019 Advances in Computers', 'Adv. Comput.', '112', '', '79--134', '', '10.1016/bs.adcom.2017.12.002', 'Combinatorial Testing', 'Since their introduction into software testing in the mid-1980s, combinatorial methods for test design gathered popularity as a testing best practice and as a prominent software testing research area. This chapter reviews recent advances in combinatorial testing, with special focus on the research since 2011. It provides a brief background on the theory behind combinatorial testing and on its use in practice. Requirements from industry usage have led to advances in various areas examined in this chapter, including constraints handling in combinatorial algorithms, support for the combinatorial modeling process, and studies on metrics to support the effectiveness of combinatorial testing. We also highlight recent case studies describing novel use cases for test and field quality improvement in the context of system test, and for optimization of test data. Finally, we examine recent developments in advanced topics such as utilization of existing tests, test case prioritization, fault localization, and evolution of combinatorial models.', NULL);
INSERT INTO `list` VALUES (934, '2020-01-20', 2019, 'article', 'Preeti Satish, Krishnan Rangarajan', 'A hybrid test prioritisation technique for combinatorial testing', 'Optimization', 'Priority', '2019 International Journal of Intelligent Systems Technologies and Applications', 'other', '18', '1/2', '84--100', '', '10.1504/IJISTA.2019.097749', 'Combinatorial Testing', 'Internet of things IoT systems comprise of multiple devices connected together, to perform an intelligent task in real time. Such systems have to be meticulously tested in order to avoid hazards situations. Combinatorial testing technique can effectively test such complex IoT systems with reduced effort as it generates fewer test cases with adequate coverage. Prioritisation of combinatorial tests deals with finding an ideal order of the test cases so that faults are detected early. Recent approaches to prioritization problem are either coverage based or parameter-value weight based for twoway or three-way interaction strengths separately. In this paper, we present a hybrid prioritisation technique for combinatorial testing that combines both weight based and interaction coverage based approaches. To demonstrate the effectiveness of our algorithm, we have conducted initial synthetic experiments on various covering arrays, and measured the effectiveness with t-Rate of fault of detection metric. The results are promising in covering the combinations early.', NULL);
INSERT INTO `list` VALUES (935, '2020-01-20', 2019, 'article', 'P. Ramgouda, V. Chandraprakash', 'Optimization Driven Constraints Handling in Combinatorial Interaction Testing', 'Generation', 'Constraint', '2019 International Journal of Open Source Software and Processes', 'other', '10', '3', '19--37', '', '10.4018/IJOSSP.2019070102', 'Combinatorial Testing', NULL, NULL);
INSERT INTO `list` VALUES (936, '2020-01-20', 2019, 'inproceedings', 'Konrad Fogen, Horst Lichter', 'Semi-Automatic Repair of Over-Constrained Models for Combinatorial Robustness Testing', 'Model', '', '2019 Asia-Pacific Software Engineering Conference', 'APSEC', '', '', '110--117', '', '10.1109/APSEC48747.2019.00024', 'Combinatorial Testing', NULL, NULL);
INSERT INTO `list` VALUES (937, '2020-01-20', 2019, 'inproceedings', 'Bisma Rehman, Khubaib Amjad Alam, Mubashar Rehman, Abid Jamil, Pariwish Touseef, Rimsha Asif', 'Combinatorial Testing of Web Services: A Systematic Mapping', 'Application', 'Survey', '2019 International Conference on Future Networks and Distributed Systems', 'ICFNDS', '', '', '38:1--38:7', '', '10.1145/3341325.3342009', 'Combinatorial Testing', 'Complete coverage of all possible test instances in the testing of integrated systems could achieve by using combinatorial testing (CT) strategies. Combinatorial testing has widely been studied in Web service testing research. Few studies related to testing basic web services while others focus on the composite service behavior of web services to generate minimum test cases or test data. This paper is a part of another larger paper that systematically map the available research work on combinatorial testing of web services. The paper presents a Classification scheme to structure the area and to report results based on the answers of three selected research questions. A classification scheme comprises combinatorial techniques algorithms and tools for testing and standard based SUT. This study exposes that even web service testing is getting noteworthy attention still very few approaches of CT applied to test web services.', NULL);
INSERT INTO `list` VALUES (938, '2020-01-20', 2019, 'inproceedings', 'Dimitris E. Simos, Jovan Zivanovic, Manuel Leithner', 'Automated combinatorial testing for detecting SQL vulnerabilities in web applications', 'Application', '', '2019 International Workshop on Automation of Software Test', 'IWAST', '', '', '55--61', '', '10.1109/AST.2019.00014', 'Combinatorial Testing', 'In this paper, we present a combinatorial testing methodology for testing web applications in regards to SQL injection vulnerabilities. We describe three attack grammars that were developed and used to generate concrete attack vectors. Furthermore, we present and evaluate two different oracles used to observe the application\'s behavior when subjected to such attack vectors. We also present a prototype tool called SQLInjector capable of automated SQL injection vulnerability testing for web applications. The developed methodology can be applied to any web application that uses server side scripting and HTML for handling user input and has a SQL database backend. Our approach relies on the use of a database proxy, making this a gray-box testing method. We establish the effectiveness of the proposed tool with the WAVSEP verification framework and conduct a case study on real-world web applications, where we are able to discover both known vulnerabilities and additional previously undiscovered flaws.', NULL);
INSERT INTO `list` VALUES (939, '2020-01-20', 2019, 'inproceedings', 'Zhao Li, Yuhang Chen, Guoqiang Gong, Dongcheng Li, Ke Lv, Peng Chen', 'A Survey of the Application of Combinatorial Testing', 'Application', 'Survey', '2019 International Conference on Software Quality, Reliability and Security Companion', 'QRS-C', '', '', '512--513', '', '10.1109/QRS-C.2019.00100', 'Combinatorial Testing', 'After more than 30 years of development, combinatorial testing has become an essential method in the field of software testing, which has always been an active field. Through combined coverage, combinatorial testing can detect faults caused by various parameters and their interactions in a software under test. This paper aims to review the development of combinatorial testing and briefly introduce its basic applications. We classifies today\'s combinatorial testing applications, including those of traditional industry and those of the IT industry. The research-and-application progress of combinatorial testing was investigated with respect to various fields of application, and potential application directions for the future were proposed to provide ideas its the extensive application.', NULL);
INSERT INTO `list` VALUES (940, '2020-01-20', 2019, 'inproceedings', 'Bernhard Garn, Dimitris E. Simos, Stefan Zauner, Rick Kuhn, Raghu Kacker', 'Browser fingerprinting using combinatorial sequence testing', 'Application', '', '2019 Annual Symposium on Hot Topics in the Science of Security', 'HotSoS', '', '', '7:1--7:9', '', '10.1145/3314058.3314062', 'Combinatorial Testing', 'In this paper, we propose an approach for browser fingerprinting using their behavior during the TLS 1.2 handshake with a server. Using combinatorial methods, we created test sets consisting of TLS server-side messages as sequences that are sent to the client as server responses during the TLS handshake. We created an appropriate abstract model of the TLS handshake protocol and used it to map browser behavior to a feature vector and use them to derive a distinguisher. We evaluate our approach with a case study showing that combinatorial properties have an impact on browsers\' behavior.', NULL);
INSERT INTO `list` VALUES (941, '2020-01-20', 2019, 'inproceedings', 'Said Daoudagh, Francesca Lonetti, Eda Marchetti', 'A Decentralized Solution for Combinatorial Testing of Access Control Engine', 'Application', '', '2019 International Conference on Information Systems Security and Privacy', 'ICISSP', '', '', '126--135', '', '10.5220/0007379401260135', 'Combinatorial Testing', 'In distributed environments, information security is a key factor and access control is an important means to guarantee confidentiality of sensitive and valuable data. In this paper, we introduce a new decentralized framework for testing of XACML-based access control engines. The proposed framework is composed of different web services and provides the following functionalities: i) generation of test cases based on combinatorial testing strategies; ii) decentralized oracle that associates the expected result to a given test case, i.e. an XACML request; and finally, iii) a GUI for interacting with the framework and providing some analysis about the expected results. A first validation confirms the efficiency of the proposed approach.', NULL);
INSERT INTO `list` VALUES (942, '2020-01-20', 2019, 'inproceedings', 'Peter W. V. Tran-Jorgensen, Tomas Kulik, Jalil Boudjadar, Peter Gorm Larsen', 'Security analysis of cloud-connected industrial control systems using combinatorial testing', 'Application', '', '2019 International Conference on Formal Methods and Models for System Design', 'FMICS', '', '', '13:1--13:11', '', '10.1145/3359986.3361211', 'Combinatorial Testing', 'Industrial control systems are moving from monolithic to distributed and cloud-connected architectures, which increases system complexity and vulnerability, thus complicates security analysis. When exhaustive verification accounts for this complexity the state space being sought grows drastically as the system model evolves and more details are considered. Eventually this may lead to state space explosion, which makes exhaustive verification infeasible. To address this, we use VDM-SL\'s combinatorial testing feature to generate security attacks that are executed against the model to verify whether the system has the desired security properties. We demonstrate our approach using a cloud-connected industrial control system that is responsible for performing safety-critical tasks and handling client requests sent to the control network. Although the approach is not exhaustive it enables verification of mitigation strategies for a large number of attacks and complex systems within reasonable time.', NULL);
INSERT INTO `list` VALUES (943, '2020-01-20', 2018, 'article', 'Guanqiu Qi, Wei-Tek Tsai, Charles J. Colbourn, Jie Luo, Zhiqin Zhu', 'Test-Algebra-Based Fault Location Analysis for the Concurrent Combinatorial Testing', 'Diagnosis', '', '2018 IEEE Transactions on Reliability', 'Trans. Rel.', '67', '3', '802--831', '', '10.1109/TR.2018.2833449', 'Combinatorial Testing', 'A new algebraic system, test algebra (TA), is proposed for identifying faults in combinatorial testing for software-as-a-service (SaaS) applications. In the context of cloud computing, SaaS is a new software delivery model, in which mission-critical applications are composed, deployed, and executed on cloud platforms. Testing SaaS applications is challenging because new applications need to be tested once they are composed, and prior to their deployment. A composition of components providing services yields a configuration providing an SaaS application. While individual components in the configuration may have been thoroughly tested, faults still arise due to interactions among the components composed, making the configuration faulty. When there are k components, combinatorial testing algorithms can be used to identify faulty interactions with t or fewer components, for some threshold 2 ≤ t ≤ k on the size of interactions considered. In general, these methods do not identify specific faults, but rather indicate the presence or absence of some faults. To identify specific faults, an adaptive testing regime repeatedly constructs and tests configurations in order to determine, for each interaction of interest, whether it is faulty or not. In order to perform such testing in a loosely coupled distributed environment such as the cloud, it is imperative that testing results can be combined from many different servers. The TA defines rules to permit results to be combined, and to identify the faulty interactions. Using the TA, configurations can be tested concurrently on different servers and in any order. The TA always keeps the high reduction rate of potential faulty configurations in fault location analysis.', NULL);
INSERT INTO `list` VALUES (944, '2020-01-20', 2018, 'inproceedings', 'Konrad Fogen, Horst Lichter', 'A Case Study on Robustness Fault Characteristics for Combinatorial Testing - Results and Challenges', 'Diagnosis', '', '2018 International Workshop on Quantitative Approaches to Software Quality', 'QUATIC', '', '', '22--29', '', 'not found', 'Combinatorial Testing', 'Combinatorial testing is a well-known black-box testing approach. Empirical studies suggest the effectiveness of combinatorial coverage criteria. So far, the research focuses on positive test scenarios. But, robustness is an important characteristic of software systems and testing negative scenarios is crucial. Combinatorial strategies are extended to generate invalid test inputs but the effectiveness of negative test scenarios is yet unclear. Therefore, we conduct a case study and analyze 434 failures reported as bugs of an financial enterprise application. As a result, 51 robustness failures are identified including failures triggered by invalid value combinations and failures triggered by interactions of valid and invalid values. Based on the findings, four challenges for combinatorial robustness testing are derived.', NULL);
INSERT INTO `list` VALUES (945, '2020-01-20', 2018, 'inproceedings', 'Min Yu, Ziyuan Wang, Feiyan She, Yuanchao Qi', 'A Revisit of Fault-Detecting Probability of Combinatorial Testing for Boolean-Specifications (P)', 'Diagnosis', '', '2018 International Conference on Software Engineering and Knowledge Engineering', 'SEKE', '', '', '711--710', '', '10.18293/SEKE2018-139', 'Combinatorial Testing', 'The lower bound of fault-detecting probability of τ way combinatorial test suite for Boolean-specification testing have been proposed [1]. However, the formula neglected the situation that for different minimal failure-causing schemas, the coverage of test suites may be non-independent events. Hence, multiplying directly the probabilities of non-independent events is incorrect, which causes that the result calculated by previous formula may be greater. In this paper, we give counterexamples to demonstrate the mistakes in the formula derivation. Furthermore, two experiments are designed to illustrate that the actual fault-detecting probabilities and ratios are usually less than the theoretical faultdetecting probabilities calculated from the previous formula.', NULL);
INSERT INTO `list` VALUES (946, '2020-01-20', 2018, 'inproceedings', 'Denivan Campos, Crescencio Lima, Ivan do Carmo Machado', 'MERCI: A Method to Evaluate Combinatorial Interaction Testing Tools for Software Product Lines', 'Application', '', '2018 Brazilian Symposium on Software Quality', 'SBQS', '', '', '151--159', '', '10.1145/3275245.3275261', 'Combinatorial Testing', 'Testing a system is a routine activity, and it plays an important role in the software quality assurance process. However, testing highly-configurable systems, such as Software Product Lines (SPL), is a rather complex activity, due to the presence of variability in its engineering process, which increases the number of product configurations to test. The underlying idea to make testing feasible in SPL engineering is to select a small but representative subset of products to test, by employing techniques such as combinatorial interaction testing (CIT). This paper presents Method to Evaluate Combinatorial Interaction (MERCI), a novel method to evaluate the adequacy of existing CIT tools for SPL engineering, with respect to three measures: defect detection, test coverage, and test execution length. We carried out an empirical evaluation to compare four CIT tools: ACTS, CATS, PICTMaster and VPTag. The results show that the method may serve as an affordable strategy to evaluate how the CIT tools could behave in an SPL testing scenario. CCS CONCEPTS • Software and its engineering → Software product lines; Software verification and validation;', NULL);
INSERT INTO `list` VALUES (947, '2020-01-20', 2019, 'inproceedings', 'Abdullah B. Nasser, Fadhl Hujainah, AbdulRahman A. Al-Sewari, Kamal Z. Zamli', 'An Improved Jaya Algorithm-Based Strategy for T-Way Test Suite Generation', 'Generation', 'Constraint', '2019 International Conference of Reliable Information and Communication Technology', 'other', '', '', '352--361', '', '10.1007/978-3-030-33582-3\\_34', 'Combinatorial Testing', 'In the field of software testing, several meta-heuristics algorithms have been successfully used for finding an optimized t-way test suite (where t refers to covering level). T-way testing strategies adopt the meta-heuristic algorithms to generate the smallest/optimal test suite. However, the existing t-way strategies’ results show that no single strategy appears to be superior in all problems. The aim of this paper to propose a new variant of Jaya algorithm for generating t-way test suite called Improved Jaya Algorithm (IJA). In fact, the performance of meta-heuristic algorithms highly depends on the intensification and diversification capabilities. IJA enhances the intensification and diversification capabilities by introducing new operators search such lévy flight and mutation operator in Jaya Algorithm. Experimental results show that the IJA variant improves the results of original Jaya algorithm, also overcomes the problems of slow convergence of Jaya algorithm.', NULL);
INSERT INTO `list` VALUES (948, '2020-01-20', 2019, 'article', 'Ludwig Kampel, Manuel Leithner, Dimitris E. Simos', 'Sliced AETG: a memory-efficient variant of the AETG covering array generation algorithm', 'Generation', '', '2019 Optimization Letters', 'other', '', '', '1--14', 'Springer', '10.1007/s11590-019-01459-0', 'Combinatorial Testing', 'The generation of covering arrays, which can be regarded as a generalization of orthogonal arrays, is an active research field. In this paper, we propose a memory efficient variant of the well-known AETG greedy algorithm for covering array generation called sliced AETG. The memory usage and runtime of sliced AETG is greatly decreased when compared to that of the original algorithm. We further show asymptotic results regarding the runtime and the number of rows of the generated arrays, which are the same as that of greedy AETG, for fixed alphabet and strength. However, as our experimental evaluation shows, the generated CAs have more rows than those produced by the original version.', NULL);
INSERT INTO `list` VALUES (949, '2020-01-20', 2019, 'inproceedings', 'Bestoun S. Ahmed, Amador Pahim, Cleber R. Rosa Junior, D. Richard Kuhn, Miroslav Bures', 'Towards an Automated Unified Framework to Run Applications for Combinatorial Interaction Testing', 'Application', '', '2019 Proceedings of the Evaluation and Assessment on Software Engineering', 'EASE', '', '', '252--258', '', '10.1145/3319008.3319348', 'Combinatorial Testing', 'Combinatorial interaction testing (CIT) is a well-known technique, but the industrial experience is needed to determine its effectiveness in different application domains. We present a case study introducing a unified framework for generating, executing and verifying CIT test suites, based on the open-source Avocado test framework. In addition, we present a new industrial case study to demonstrate the effectiveness of the framework. This evaluation showed that the new framework can generate, execute, and verify effective combinatorial interaction test suites for detecting configuration failures (invalid configurations) in a virtualization system.', NULL);
INSERT INTO `list` VALUES (950, '2020-01-20', 2018, 'inproceedings', 'Sarfraz Khurshid, Darko Marinov', 'Reducing Combinatorial Testing Requirements Based on Equivalences with Respect to the Code Under Test', 'Generation', '', '2018 Workshop on Software Quality Analysis, Monitoring, Improvement, and Applications', 'other', '', '', '8:1--8:7', '', 'not found', 'Combinatorial Testing', 'Combinatorial testing, where different combinations of parameter values are used to create test inputs, is a well-known approach\r\nfor black-box testing of software systems. Researchers have defined several coverage criteria for combinatorial testing. Among\r\nthem, the most comprehensive criterion is all combinations coverage. While using this criterion gives the most assurance in the\r\ncorrectness of the code under test, this criterion can have too many test requirements, which can make it impractical to apply.\r\nThis paper introduces a new, simple approach that provides the same assurance as all combinations coverage but typically with\r\nfewer test inputs, thereby reducing the overall cost of combinatorial testing. Our key insight is that one test input execution can\r\ncover several test requirements for combinatorial coverage criteria. Our approach builds on the Korat test-generation technique\r\nto explore which combinations of parameter values are equivalent with respect to the code under test. An illustration on a\r\npedagogical example shows how this approach can lead to substantial reduction in the number of tests.', NULL);
INSERT INTO `list` VALUES (951, '2020-01-20', 2018, 'inproceedings', 'Franz Wotawa, Yihao Li', 'From Ontologies to Input Models for Combinatorial Testing', 'Model', '', '2018 International Conference on Testing Software and Systems', 'ICTSS', '', '', '155--170', '', '10.1007/978-3-319-99927-2\\_14', 'Combinatorial Testing', 'Ordinary tools for computing combinatorial test suites rely on simple input models comprising variables together with their domains and constraints limiting possible combinations. Modeling for combinatorial testing requires to represent the input domain of the application in a way such that it fits to the combinatorial testing input model. Depending on the application’s domain this mapping ranges from trivial to more complicated. In this paper, we focus on modeling for combinatorial testing in cases the application’s domain can be represented in form of an ontology, i.e., concepts and their relationships. We formally introduce the notation of ontology we rely on in this paper, and show how such ontologies can be automatically mapped to a combinatorial testing input model. We discuss the algorithm and show its properties.', NULL);
INSERT INTO `list` VALUES (952, '2020-01-20', 2018, 'inproceedings', 'Dimitris E. Simos, Ludwig Kampel, Murat Ozcan', 'Combinatorial Methods for Testing Communication Protocols in Smart Cities', 'Application', '', '2018 International Conference on Learning and Intelligent Optimization', 'LION', '', '', '437--440', '', '10.1007/978-3-030-05348-2\\_37', 'Combinatorial Testing', 'In this paper, we conduct a feasibility study for combinatorial methods applied to widely used communication protocols in smart city environments. Even though, our initial results reveal no failures in the involved products, the approach looks promising in terms of software reuse and test efficiency.', NULL);
INSERT INTO `list` VALUES (953, '2020-01-20', 2017, 'inproceedings', 'Ingo Pill, Franz Wotawa', 'Model-Based Diagnosis Meets Combinatorial Testing For Generating an Abductive Diagnosis Model', 'Diagnosis', '', '2017 International Workshop on Principles of Diagnosis', 'other', '', '', '248--263', '', '10.29007/svc7', 'Combinatorial Testing', 'The diagnostic model is certainly a key element for any model-based diagnosis process. Experience shows though that in practice we often have no such model available for one or the other reason. The consequence for many projects is thus that we cannot draw on diagnosis processes when tackling problems. In this paper, we show how to improve available automated processes for deriving a diagnostic model from the standard simulation models that we usually create during development. We delve in particular into the question how research in the context of combinatorial testing and fault injection can help to improve the process, and consider several questions that arise.', NULL);
INSERT INTO `list` VALUES (954, '2021-01-10', 2020, 'inproceedings', 'Kohei Nishino, Takashi Kitamura, Tomoji Kishi, Cyrille Artho', 'Toward an Encoding Approach to Interaction-based Test Suite Minimization', 'Optimization', '', '2020 International Workshop on Combinatorial Testing', 'IWCT', '', '', '211-212', '', '10.1109/ICSTW50294.2020.00043', 'Combinatorial Testing', 'Interaction-based test suite minimization (ITSM) is a test minimization technique that finds a smaller test suite based on combinatorial interaction coverage criteria. In this paper, we explore a new encoding approach to ITSM, which solves this problem by encoding it into a set cover problem, a classical combinatorial optimization problem.', NULL);
INSERT INTO `list` VALUES (955, '2021-01-10', 2020, 'inproceedings', 'Andrea Bombarda, Angelo Gargantini', 'An Automata-Based Generation Method for Combinatorial Sequence Testing of Finite State Machines', 'Generation', '', '2020 International Workshop on Combinatorial Testing', 'IWCT', '', '', '157-166', '', '10.1109/ICSTW50294.2020.00036', 'Combinatorial Testing', 'Combinatorial Interaction Testing has been applied to event-driven software systems by using as test suite a set of sequences of inputs in desired combinations. This is generally called combinatorial sequence testing (CST). CST requires possibly new system models from which tests are generated and new test generation methods (or an adaptation of the classical ones). Finite State Machines (FSMs) can easily represent event-based systems where certain inputs are valid only in some states and such constraints can be represented by the incompleteness of the FSM. In this paper, we propose an approach to CST where tests are generated from FSMs which are represented by automata together with test requirements. First, automata can be used to check if test sequences contain invalid inputs. We propose three methods to repair tests with invalid inputs. Moreover, we can directly embed into automata the system constraints over the inputs during generations, to generate only valid test sequences. We compare our automata-based method with the standard approach of Sequences Covering Arrays (SCAs) that produces a set of sequences, all with the same length, composed by the permutation of all the events supported by the system. We found that generating only valid tests from automata provides several advantages iv.r.t. repairing tests and SCAs.', NULL);
INSERT INTO `list` VALUES (956, '2021-01-10', 2020, 'inproceedings', 'D. Richard Kuhn, Raghu N. Kacker, Yu Lei, Dimitris E. Simos', 'Combinatorial Methods for Explainable AI.', 'Application', '', '2020 International Workshop on Combinatorial Testing', 'IWCT', '', '', '167-170', '', '10.1109/ICSTW50294.2020.00037', 'Combinatorial Testing', 'This short paper introduces an approach to producing explanations or justifications of decisions made by artificial intelligence and machine learning (AI/ML) systems, using methods derived from fault location in combinatorial testing. We use a conceptually simple scheme to make it easy to justify classification decisions: identifying combinations of features that are present in members of the identified class and absent or rare in non-members. The method has been implemented in a prototype tool, and examples of its application are given.', NULL);
INSERT INTO `list` VALUES (957, '2021-01-10', 2020, 'inproceedings', 'Konrad Fogen, Horst Lichter', 'Generation of Invalid Test Inputs from Over-Constrained Test Models for Combinatorial Robustness Testing', 'Modelling', '', '2020 International Workshop on Combinatorial Testing', 'IWCT', '', '', '171-180', '', '10.1109/ICSTW50294.2020.00038', 'Combinatorial Testing', 'Testing with invalid test inputs is important to evaluate the robustness of a system. Combinatorial robustness testing is an approach to generate valid and invalid test inputs separately. Unfortunately, it is easy to create over-constrained test models. As a result, not all specified invalid values or invalid value combinations appear in the test suite. Previous work proposed to repair the test model manually or semi-automatically based on conflict detection and diagnosis techniques. In this paper, we extend that work and present a fully-automatic approach that allows to generate invalid test inputs from over-constrained test models based on alternative constraint handling strategies.', NULL);
INSERT INTO `list` VALUES (958, '2021-01-10', 2020, 'inproceedings', 'Yihao Li, Franz Wotawa', 'On Using Ontologies for Testing Compilers.', 'Application', '', '2020 International Workshop on Combinatorial Testing', 'IWCT', '', '', '181-184', '', '10.1109/ICSTW50294.2020.00039', 'Combinatorial Testing', 'Testing compilers requires coming up with textual input that can be parsed. Depending on the input the compiler may indicate an error, e.g., a lexical or a syntactical error, or may proceed converting the input to the output format. In this paper, we focus on the parsing functionality of a compiler and discuss an approach that is based on combinatorial testing for generating textual inputs. In particular, we make use of ontology-based testing, where we come up with an ontology describing potential inputs. Originally, ontology-based testing has been developed for testing safety-critical systems where the underlying idea was to use ontologies to describe the concepts of an environment of the system under test, and to use combinatorial testing for extracting critical scenarios based on these concepts. Making use of ontology-based testing for compilers extends the applicability of this testing method to the domain of compiler testing. Besides discussing the foundations behind the approach, we make use of a case study to illustrate the applicability of the proposed method. ', NULL);
INSERT INTO `list` VALUES (959, '2021-01-10', 2020, 'inproceedings', 'Torben Friedrichs, Konrad Fogen, Horst Lichter', 'A Comparison Infrastructure for Fault Characterization Algorithms', 'Diagnosis', '', '2020 ICST Workshops', 'ICSTW', '', '', '201-210', '', '10.1109/ICSTW50294.2020.00042', 'Combinatorial Testing', 'Fault characterization is an important part of combinatorial testing which enables the automatic identification of failure-inducing combinations. Up until now, many different algorithms are proposed to compute failure-inducing combinations. However, the only comparisons between different algorithms are done by the algorithms authors themselves who only evaluate few algorithms at a time which complicates comparisons. Therefore, we present a concept and a reference implementation of a comparison infrastructure that allows to evaluate fault characterization algorithms in a comparable manner. In addition, we report on the results of a preliminary comparison using the comparison infrastructure.', NULL);
INSERT INTO `list` VALUES (960, '2021-01-10', 2020, 'inproceedings', 'Jan Richter, Bestoun S. Ahmed, Miroslav Bures, Cleber R. Rosa Junior', 'Avocado: Open-Source Flexible Constrained Interaction Testing for Practical Application', 'Application', '', '2020 International Workshop on Combinatorial Testing', 'IWCT', '', '', '185-190', '', '10.1109/ICSTW50294.2020.00040', 'Combinatorial Testing', 'This paper presents the outcome of a research collaboration between academia and industry to implement and utilize the capabilities of constrained interaction testing for an open-source tool for industrial-scale application. The project helps promote flexibility in generating constrained interaction test suites, executing them, and setting up a test oracle to report them-all within the same tool called Avocado. Avocado employs a constraint solver with computational algorithms to generate constrained interaction test suites. The environment of the application under test can be set up to execute the generated test suite with minimum effort. A test oracle can be set up by the tool to report the status and the results of the executed test cases. Avocado represents a comprehensive and flexible solution for conducting combinatorial interaction testing (CIT) and constrained CIT on an industrial application. In this paper, we present the structure of the tool and our method of implementing the algorithms in detail.', NULL);
INSERT INTO `list` VALUES (961, '2021-01-10', 2020, 'inproceedings', 'Michael Wagner, Kristoffer Kleine, Dimitris E. Simos, D. Richard Kuhn, Raghu N. Kacker', 'CAGEN: A fast combinatorial test generation tool with support for constraints and higher-index arrays', 'Generation', '', '2020 International Workshop on Combinatorial Testing', 'IWCT', '', '', '191-200', '', '10.1109/ICSTW50294.2020.00041', 'Combinatorial Testing', 'In recent years, combinatorial testing methods have been successfully applied to test systems with a larger number of input parameters. Generating combinatorial test sets for such complex systems is a challenging task as it requires a lot of time and computing power. To tackle that issue, high performance tools are required. In this work, we present the combinatorial test set generation tool CAgen. It is capable of generating combinatorial test sets significantly faster than other state-of-the-art tools, such as ACTS, and contains various features such as constraint handling and higher-index arrays. It is highly compatible with other combinatorial testing tools and is available as CLI and Web-GUI. CAgen aims to make combinatorial testing more efficient and more accessible and user-friendly.', NULL);
INSERT INTO `list` VALUES (962, '2021-01-10', 2020, 'inproceedings', 'Christoph Gladisch, Christian Heinzemann, Martin Herrmann, Matthias Woehrle', 'Leveraging combinatorial testing for safety-critical computer vision datasets', 'Application', '', '2020 CVPR Workshops', 'CVPR', '', '', '1314-1321', '', '10.1109/CVPRW50498.2020.00170', 'Combinatorial Testing', 'Deep learning-based approaches have gained popularity for environment perception tasks such as semantic segmentation and object detection from images. However, the\r\ndifferent nature of a data-driven deep neural nets (DNN) to\r\nconventional software is a challenge for practical software\r\nverification. In this work, we show how existing methods\r\nfrom software engineering provide benefits for the development of a DNN and in particular for dataset design and\r\nanalysis. We show how combinatorial testing based on a\r\ndomain model can be leveraged for generating test sets providing coverage guarantees with respect to important environmental features and their interaction. Additionally, we\r\nshow how our approach can be used for growing a dataset,\r\ni.e. to identify where data is missing and should be collected\r\nnext. We evaluate our approach on an internal use case and\r\ntwo public datasets.\r', NULL);
INSERT INTO `list` VALUES (963, '2021-01-10', 2020, 'article', 'Linghuan Hu, W. Eric Wong, D. Richard Kuhn, Raghu N. Kacker', 'How does combinatorial testing perform in the real world: an empirical study', 'Application', '', '2020 Empirical Software Engineering', 'EMSE', '25', '4', '2661-2693', '', '10.1007/S10664-019-09799-2', 'Combinatorial Testing', 'Studies have shown that combinatorial testing (CT) can be effective for detecting faults in software systems. By focusing on the interactions between different factors of a system, CT shows its potential for detecting faults, especially those that can be revealed only by the specific combinations of values of multiple factors (multi-factor faults). However, is CT practical enough to be applied in the industry? Can it be more effective than other industry-favored techniques? Are there any challenges when applying CT in practice? These research questions remain in the context of industrial settings. In this paper, we present an empirical study of CT on five industrial systems with real faults. The details of the input space model (ISM) construction, such as factor identification and value assignment, are included. We compared the faults detected by CT with those detected by the in-house testing teams using other methods, and the results suggest that despite some challenges, CT is an effective technique to detect real faults, especially multi-factor faults, of software systems in industrial settings. Observations and lessons learned are provided to further improve the fault detection effectiveness and overcome various challenges.', NULL);
INSERT INTO `list` VALUES (964, '2021-01-10', 2020, 'article', 'Rachel Tzoref-Brill', 'Comprehension and Evolution of Combinatorial Models and Test Plans', 'Evaluation', '', '2020 ACM SIGSOFT Softw. Eng. Notes', 'SIGSOFT ', '45', '3', '23-24', '', '10.1145/3402127.3402137', 'Combinatorial Testing', 'Combinatorial test design (CTD) [1] is an effective test design technique, considered to be a testing best practice. CTD provides automatic test plan generation, but it requires a manual definition of the test space in the form of a combinatorial model, consisting of parameters, their respective values, and constraints on the value combinations. A valid test in the test space is defined to be an assignment of one value to each parameter that satisfies the constraints. A CTD algorithm automatically constructs a subset of the set of valid tests, termed a test plan, which covers all valid value combinations of every t parameters, where t is usually a user input. Such a test plan is said to achieve 100% t-way interaction coverage. A significant combinatorial reduction is achieved in the size of the resulting test plan (compared to manually designed test plans for example) because the tests generated by the CTD algorithm are very different from one another, maximizing their added value -- each of them covers as many unique t-way value tuples as possible. Note that tests produced by the algorithm are parameter-value assignments. Generating executable tests from them is often a separate, manual effort.', NULL);
INSERT INTO `list` VALUES (965, '2021-01-10', 2020, 'article', 'Xi Deng, Zhiqiang Zhang, Rundong Li, Jun Yan, Jian Zhang', 'Combinatorial Testing of Browsers&apos; Support for Multimedia', 'Application', '', '2020 IEEE Transactions on Reliability', 'Trans. Rel.', '69', '4', '1323-1340', '', '10.1109/TR.2020.2975150', 'Combinatorial Testing', 'The fifth version of the Hypertext Markup Language (HTML) standard is widely adopted in the diverse landscape of browser vendors and their continuously upgrading releases. One primary feature of HTML5 is native multimedia playback. The browsers’ native implementations of multimedia support bring lots of benefits such as improved security but require thorough testing, especially on the web page of complex factor combinations according to our manual checking of publicly visible existing tests. This article employs the combinatorial testing technique to trigger failure-inducing factor combinations effectively and to locate them, guided by some extracted properties that cover browsers’ major workflow of processing multimedia. Results are analyzed to give objective suggestions for browser developers to cast light on the places that implementation enhancement could be made, and for web developers to avoid undesirable effects.', NULL);
INSERT INTO `list` VALUES (966, '2021-01-10', 2020, 'article', 'Bestoun S. Ahmed, Eduard Enoiu, Wasif Afzal, Kamal Z. Zamli', 'An evaluation of Monte Carlo-based hyper-heuristic for interaction testing of industrial embedded software applications', 'Generation', '', '2020 Soft Computing', 'Soft Computing', '24', '18', '13929-13954', '', '10.1007/S00500-020-04769-Z', 'Combinatorial Testing', 'Hyper-heuristic is a new methodology for the adaptive hybridization of meta-heuristic algorithms to derive a general algorithm for solving optimization problems. This work focuses on the selection type of hyper-heuristic, called the exponential Monte Carlo with counter (EMCQ). Current implementations rely on the memory-less selection that can be counterproductive as the selected search operator may not (historically) be the best performing operator for the current search instance. Addressing this issue, we propose to integrate the memory into EMCQ for combinatorial t-wise test suite generation using reinforcement learning based on the Q-learning mechanism, called Q-EMCQ. The limited application of combinatorial test generation on industrial programs can impact the use of such techniques as Q-EMCQ. Thus, there is a need to evaluate this kind of approach against relevant industrial software, with a purpose to show the degree of interaction required to cover the code as well as finding faults. We applied Q-EMCQ on 37 real-world industrial programs written in Function Block Diagram (FBD) language, which is used for developing a train control management system at Bombardier Transportation Sweden AB. The results show that Q-EMCQ is an efficient technique for test case generation. Addition- ally, unlike the t-wise test suite generation, which deals with the minimization problem, we have also subjected Q-EMCQ to a maximization problem involving the general module clustering to demonstrate the effectiveness of our approach. The results show the Q-EMCQ is also capable of outperforming the original EMCQ as well as several recent meta/hyper-heuristic including modified choice function, Tabu high-level hyper-heuristic, teaching learning-based optimization, sine cosine algorithm, and symbiotic optimization search in clustering quality within comparable execution time.', NULL);
INSERT INTO `list` VALUES (967, '2021-01-10', 2020, 'inproceedings', 'Erin Lanus, Charles J. Colbourn', 'Algorithms for Constructing Anonymizing Arrays', 'Generation', '', '2020 IWOCA', 'IWOCA', '', '', '382-394', '', '10.1007/978-3-030-48966-3_29', 'Combinatorial Testing', 'Attribute-based methods are inherently identity-less as authorization decisions are made in terms of attributes possessed by the subject rather than identity. However, anonymity against the system is not guaranteed when attribute distribution allows for the composition of a policy that few subjects can satisfy. An anonymizing array ensures that any assignment of values to t attributes that appears in the array appears at least r times. When an anonymizing array is used for subjects registered to a system and policies contain conjunctions of at most t attributes, the system cannot identify the subject using the policy to to gain authorization with greater than 1r\r\n probability. Anonymizing arrays are similar to covering arrays with higher coverage and constraints, but have an additional desired property, homogeneity, due to their application domain. In this paper, we develop constructions for anonymizing arrays and propose a post-optimization mechanism to reduce homogeneity.', NULL);
INSERT INTO `list` VALUES (968, '2021-01-10', 2020, 'inproceedings', 'Hao Jin, Takashi Kitamura, Eun-Hye Choi, Tatsuhiro Tsuchiya', 'A Comparative Study on Combinatorial and Random Testing for Highly Configurable Systems', 'Evaluation', '', '2020 ICTSS', 'ICTSS', '', '', '302-309', '', '10.1007/978-3-030-64881-7_20', 'Combinatorial Testing', 'Highly configurable systems (HCSs), such as software product lines, have complex configuration spaces. Combinatorial Testing and Random Testing are the main approaches to testing of HCSs. In this paper, we empirically compare their strengths with respect to scalability and diversity of sampled configurations (i.e., tests). We choose ICPL and QUICKSAMPLER to respectively represent Combinatorial Testing and Random Testing. Experiments are conducted to evaluate the t-way coverage criterion of generated test suites for HCS benchmarks.', NULL);
INSERT INTO `list` VALUES (969, '2021-01-10', 2020, 'article', 'Ali Hassan, Salwani Abdullah, Kamal Z. Zamli, Rozilawati Razali', 'Combinatorial Test Suites Generation Strategy Utilizing the Whale Optimization Algorithm', 'Generation', '', '2020 IEEE Access', 'Access', '8', '', '192288-192303', '', '10.1109/ACCESS.2020.3032851', 'Combinatorial Testing', 'The potentially many software system input combinations make exhaustive testing practically impossible. To address this issue, combinatorial t-way testing (where t indicates the interaction strength, i.e. the number of interacting parameters (input)) was adopted to minimize the number of cases for testing. Complimentary to existing testing techniques (e.g. boundary value, equivalence partitioning, cause and effect graphing), combinatorial testing helps to detect faults caused by the faulty interaction between input parameters. In the last 15 years, applications of meta-heuristics as the backbone of t-way test suite generation have shown promising results (e.g. Particle Swarm Optimization, Cuckoo Search, Flower Pollination Algorithm, and Hyper-Heuristics (HHH), to name a few). Supporting the No Free Lunch theorem, as well as potentially offering new insights into the whole process of t-way generation, this article proposes a new strategy with constraint support based on the Whale Optimization Algorithm (WOA). Our work is the first attempt to adopt the WOA as part of a search-based software engineering (SBSE) initiative for t-way test suite generation with constraint support. The experimental results of the test-suite generation indicate that WOA produces competitive outcomes compared to some selected single-based and population-based meta-heuristic algorithms.', NULL);
INSERT INTO `list` VALUES (970, '2021-01-10', 2020, 'inproceedings', 'Eduard Baranov, Axel Legay, Kuldeep S. Meel', 'Baital: an adaptive weighted sampling approach for improved t-wise coverage', 'Generation', '', '2020 Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering', 'FSE', '', '', '1114-1126', '', '10.1145/3368089.3409744', 'Combinatorial Testing', 'In this work, we propose a novel approach Baital, based on adaptive weighted sampling using literal weighted functions, to generate test sets with high t-wise coverage. We demonstrate that our approach reaches significantly higher t-wise coverage than uniform sampling.', NULL);
INSERT INTO `list` VALUES (971, '2021-01-10', 2020, 'inproceedings', 'Hao Jin, Ce Shi, Tatsuhiro Tsuchiya', 'Constrained detecting arrays for fault localization in combinatorial testing', 'Diagnosis', '', '2020 SAC', 'SAC', '', '', '1971-1978', '', '10.1145/3341105.3373952', 'Combinatorial Testing', 'Detecting Arrays (DAs) are mathematical objects that enable fault localization in combinatorial interaction testing. Each row of a DA serves as a test case, whereas a whole DA is treated as a test suite. In real-world testing problems, it is often the case that some constraints exist among test parameters. In this paper, we show that it may be impossible to construct a DA using only constraint-satisfying test cases. The reason for this is that a set of some faulty interactions may always mask the effect of other faulty interactions in the presence of constraints. Based on this observation, we propose the notion of Constrained Detecting Arrays (CDAs) to adapt DAs to practical situations. The definition of CDAs requires that all rows of a CDA must satisfy the constraints and the same fault localization capability as the DA must hold except for such inherently undetectable faults. We then propose a computational method for constructing CDAs. Experimental results obtained by using a program that implements the method show that the method was able to produce CDAs within a reasonable time for practical problem instances.', NULL);
INSERT INTO `list` VALUES (972, '2021-01-10', 2020, 'article', 'Hamsa Naji Nsaif Al-Sammarraie, Dayang N. A. Jawawi', 'Multiple Black Hole Inspired Meta-Heuristic Searching Optimization for Combinatorial Testing', 'Generation', '', '2020 IEEE Access', 'Access', '8', '', '33406-33418', '', '10.1109/ACCESS.2020.2973696', 'Combinatorial Testing', 'Combinatorial searching-based software testing (CSST) is a challenging optimization procedure. The achievement of optimal solutions involves a careful formulation of the optimization problem and the selection of an appropriate approach. Meta-heuristic searching procedures have proven to be effective for solving CSST issues. Black hole (BH) optimization is among the more recently developed meta-heuristic searching algorithms. While this approach has been observed to be an effective alternative to particle swarm optimization, its operation is based on only one swarm. To date, no efforts have been made to modify this approach to accommodate multiple swarms. This study proposes a new variant of BH that involves a combination of multiple swarms. The BH optimizer is modified from continuous searching to binary searching and subsequently applied for solving CSST. The evaluation is based on a modified-benchmarking mathematical function and well-known CSST problems. This modified BH method is superior to the original BH and the established particle swarm optimization (PSO) approach. In terms of CSST problems, binary multiple black hole (BMBH) optimizations generate reduction rates between 50% and more than 60% for t = 4 according to the problem.', NULL);
INSERT INTO `list` VALUES (10000, '1', 2021, 'article', '	Carlos Ansótegui, Felip Manyà, Jesus Ojeda, Josep M. Salvia, Eduard Torres', 'Incomplete MaxSAT Approaches for Combinatorial Testing', NULL, NULL, '2021 Journal of Heuristics', 'JOH', '28', '4', '377–431', NULL, 'https://doi.org/10.1007/s10732-022-09495-3', 'Combinatorial Testing', 'We present a Satisfiability (SAT)-based approach for building Mixed Covering Arrays with Constraints of minimum length, referred to as the Covering Array Number problem. This problem is central in Combinatorial Testing for the detection of system failures. In particular, we show how to apply Maximum Satisfiability (MaxSAT) technology by describing efficient encodings for different classes of complete and incomplete MaxSAT solvers to compute optimal and suboptimal solutions, respectively. Similarly, we show how to solve through MaxSAT technology a closely related problem, the Tuple Number problem, which we extend to incorporate constraints. For this problem, we additionally provide a new MaxSAT-based incomplete algorithm. The extensive experimental evaluation we carry out on the available Mixed Covering Arrays with Constraints benchmarks and the comparison with state-of-the-art tools confirm the good performance of our approaches.', NULL);
INSERT INTO `list` VALUES (10001, '1', 2021, 'inproceedings', '	Xinyi Wang, Paolo Arcaini, Tao Yue, Shaukat Ali', 'Application of Combinatorial Testing to Quantum Programs', NULL, NULL, '2021 IEEE 21st International Conference on Software Quality, Reliability and Security (QRS)', 'QRS', NULL, NULL, '179-188', NULL, '10.1109/QRS54544.2021.00029}', 'Combinatorial Testing', 'The capability of Quantum Computing (QC) in solving complex problems has been increasingly recognized. However, similar to classical computing, to fully exploit QC\'s potential, it is important to ensure the correctness of quantum programs. Doing so via software testing is, however, very challenging because of QC\'s inherent properties: superposition and entanglement. Towards the direction of ensuring the correctness of quantum programs, we propose an approach called QuCAT (QUantum CombinAtorial Testing) for systematic and automated testing of quantum programs by benefiting from combinatorial testing, which has been proven to be cost-effective in testing classical programs. QuCAT supports two combinatorial test suite generation scenarios, i.e., generating combinatorial test suites of a given strength, and incrementally generating and executing combinatorial test suites of increasing strength until a fault is found. The approach employs two types of test oracles to assess test results. We performed an empirical study with 18 faulty versions of quantum programs to evaluate QuCAT with strengths of two, three, and four in the two test generation scenarios. We compare the cost-effectiveness of combinatorial testing of various strengths and random testing (taken as baseline approach). Results show that combinatorial testing always performs better than random testing with the same cost and finds faults more quickly (in terms of required number of test cases). In addition, in most cases, combinatorial testing with a higher strength outperforms the lower strength in terms of effectiveness.', NULL);
INSERT INTO `list` VALUES (10003, '0000-00-00', 2021, 'inproceedings', 'Said Daoudagh,Eda Marchetti', 'GROOT: A GDPR-Based Combinatorial Testing Approach', NULL, NULL, '2021 Testing Software and Systems: 33rd IFIP WG 6.1 International Conference, ICTSS 2021, London, UK, November 10–12, 2021, Proceedings', 'ICTSS ', NULL, NULL, '210–217', NULL, 'https://link.springer.com/chapter/10.1007/978-3-031-04673-5_17', 'Combinatorial Testing', 'For replying to the strict exigencies and rules imposed by the GDPR, ICT systems are currently adopting different means for managing personal data. However, due to their critical and crucial role, effective and efficient validation methods should be applied, taking into account the peculiarity of the reference legal framework (i.e., the GDPR). In this paper, we present GROOT, a generic combinatorial testing methodology specifically conceived for assessing the GDPR compliance and its contextualization in the context of access control domain.', NULL);
INSERT INTO `list` VALUES (10004, '0000-00-00', 2021, 'inproceedings', 'Jinfu Chen, Jingyi Chen, Saihua Cai, Haibo Chen, Chi Zhang, Chuangfei Huang', 'A Test Case Generation Method of Combinatorial Testing based on τ-way Testing with Adaptive Random Testing', NULL, NULL, '2021 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)', 'ISSREW', NULL, NULL, '25-28', NULL, 'https://ieeexplore.ieee.org/document/9700207/', 'Combinatorial Testing', 'Combinatorial testing is an effective software testing technique, which has gained wide attention on industry and academic. It detects faults triggered by the interactions among parameters relevant to software through selection of a reasonably sized set, which consists of the combination of the values of these parameters. However, as the complexity of software system increases, the time cost increases greatly, which leads how to efficiently generate the smallest coverage array under the given input parameter model to become the major sticking points in some scenarios. In order to address this issue, by analyzing existing generation algorithms, it is found that these algorithms are based on the complete input parameter model constructed in the first step of combinatorial testing. This paper proposes a test case generation method of combinatorial testing based on τ -way testing and adaptive random testing which test cases can be generated partially using τ -way strategy and partially using adaptive random testing by splitting the input parameter model, so as to achieve a balance between effectiveness and efficiency in a specific scenario. To this end, experimental results show that the proposed method has better faults detection ability and the computational overhead of test case generation on subject Tcas program.', NULL);
INSERT INTO `list` VALUES (10005, '0000-00-00', 2021, 'inproceedings', 'Hanefi Mercan, Cemal Yilmaz', 'Computing Sequence Covering Arrays using Unified Combinatorial Interaction Testing', NULL, NULL, '2021 IEEE International Conference on Software Testing, Verification and Validation Workshops (ICSTW)', 'ICSTW', NULL, NULL, '77-80', NULL, 'https://ieeexplore.ieee.org/document/9440178', 'Combinatorial Testing', 'Unified Combinatorial Interaction Testing (U-CIT) aims to reduce the barriers to applying combinatorial interaction testing (CIT) approaches to different testing scenarios by generalizing the construction of the CIT objects, so that the necessity of developing a specialized constructor for each distinct scenario, is avoided. In this work, to demonstrate the flexibility provided by U-CIT, we apply it to compute a well-known combinatorial object for testing, namely sequence covering arrays, together with some practical extensions.', NULL);
INSERT INTO `list` VALUES (10006, '0000-00-00', 2021, 'inproceedings', 'Harrison Goldstein, John Hughes, Leonidas Lampropoulos, Benjamin C. Pierce', 'Do Judge a Test by its Cover - Combining Combinatorial and Property-Based Testing', NULL, NULL, '2021 Programming Languages and Systems. ESOP 2021. Lecture Notes in Computer Science(), vol 12648. Springer, Cham.', 'ESOP ', '12648', NULL, '264–291', NULL, 'https://doi.org/10.1007/978-3-030-72019-3_10', 'Combinatorial Testing', 'Property-based testing uses randomly generated inputs to validate high-level program specifications. It can be shockingly effective at finding bugs, but it often requires generating a very large number of inputs to do so. In this paper, we apply ideas from combinatorial testing, a powerful and widely studied testing methodology, to modify the distributions of our random generators so as to find bugs with fewer tests. The key concept is combinatorial coverage, which measures the degree to which a given set of tests exercises every possible choice of values for every small combination of input features.\r\n\r\nIn its “classical” form, combinatorial coverage only applies to programs whose inputs have a very particular shape—essentially, a Cartesian product of finite sets. We generalize combinatorial coverage to the richer world of algebraic data types by formalizing a class of sparse test descriptions based on regular tree expressions. This new definition of coverage inspires a novel combinatorial thinning algorithm for improving the coverage of random test generators, requiring many fewer tests to catch bugs. We evaluate this algorithm on two case studies, a typed evaluator for System F terms and a Haskell compiler, showing significant improvements in both.', NULL);
INSERT INTO `list` VALUES (10007, '0000-00-00', 2021, 'article', 'Huayao Wu, Changhai Nie, Justyna Petke, Yue Jia, Mark Harman', 'Comparative Analysis of Constraint Handling Techniques for Constrained Combinatorial Testing', NULL, NULL, '2021 IEEE Transactions on Software Engineering', 'TSE', '47', '11', '2549-2562', NULL, 'https://doi.org/10.1109/TSE.2019.2955687', 'Combinatorial Testing', 'Constraints depict the dependency relationships between parameters in a software system under test. Because almost all systems are constrained in some way, techniques that adequately cater for constraints have become a crucial factor for adoption, deployment and exploitation of Combinatorial Testing (CT). Currently, despite a variety of different constraint handling techniques available, the relationship between these techniques and the generation algorithms that use them remains unknown, yielding an important gap and pressing concern in the literature of constrained combination testing. In this article, we present a comparative empirical study to investigate the impact of four common constraint handling techniques on the efficiency of six representative (greedy and search-based) test suite generation algorithms. The results reveal that the Verify technique implemented with the Minimal Forbidden Tuple (MFT) approach is the fastest, while the Replace technique is promising for producing the smallest constrained covering arrays, especially for algorithms that construct test cases one-at-a-time. The results also show that there is an interplay between efficiency of the constraint handler and the test suite generation algorithm into which it is developed.', NULL);
INSERT INTO `list` VALUES (10008, '0000-00-00', 2021, 'article', 'Raghu N. Kacker, D. Richard Kuhn, Yu Lei, Dimitris E. Simos', 'Factorials Experiments, Covering Arrays, and Combinatorial Testing', NULL, NULL, '2021 Mathematics in Computer Science', 'MCS', '15', '4', '715–739', NULL, 'https://doi.org/10.1007/s11786-021-00502-7', 'Combinatorial Testing', 'In the twenty-first century, our life will increasingly depend on software-based products and complex interconnected systems. Thus, the quality and security of software-based systems is a world-wide concern. Combinatorial testing is a versatile methodology for finding errors (bugs) and vulnerabilities in software-based systems. This paper offers a review of combinatorial testing. Combinatorial testing (CT) methods evolved from investigations which looked like factorial experiments (FE) with pass/fail outcomes. We will discuss the similarities and differences between FE and CT. Use of CT for detecting errors (bugs) in software-based systems has gained significant interest from the international software testing community. Many successful results have been reported from the use of CT to detect software errors in aerospace, automotive, defense, cybersecurity, electronic medical systems, and financial service industries. Now, combinatorial testing methods are being increasingly used to investigate vulnerabilities in software-based systems. Combinatorial testing could be useful in detecting errors and security vulnerabilities in Internet of Things, Autonomous Systems, and Artificially Intelligent Software.', NULL);
INSERT INTO `list` VALUES (10009, '0000-00-00', 2021, 'article', 'Ziyuan Wang, Yanliang Zhang, Peng Gao, Shiyong Shuang', 'Comparing Fault Detection Efficiencies of Adaptive Random Testing and Greedy Combinatorial Testing for Boolean-Specifications', NULL, NULL, '2021 January 2021International Journal of Performability Engineering 17(1):114', 'IJPE', '17', '1', '14-122', NULL, 'https://doi.org/10.23940/ijpe.21.01.p11.114122', 'Combinatorial Testing', 'Both random testing and combinatorial testing are input-domain testing techniques. Adaptive random testing, which is an improved version of random testing, selects a test case with more differences from all the existing test cases in each step. Greedy combinatorial testing generates test cases using greedy algorithms to cover more uncovered tuple-combinations of parametric values in each step. To compare fault detection efficiencies of the adaptive random testing technique and greedy combinatorial testing technique, we design an experiment on Boolean specifications that were extracted from the TCAS system. By analyzing fault detection ratios, f-measure values, and APFD values of the two testing techniques, experimental results show that: (1) if the number of test cases is relatively small, fault detection efficiencies of the two techniques are very close though adaptive random testing has a little advantage; (2) for an increase in the number of test cases, the fault detection efficiency of greedy combinatorial testing becomes gradually better.', NULL);
INSERT INTO `list` VALUES (10010, '0000-00-00', 2021, 'article', 'Cheng Zong, Yanliang Zhang, Yongming Yao, Shiyong Shuang, Ziyuan Wang', 'A Comparison of Fault Detection Efficiency Between Adaptive Random Testing and Greedy Combinatorial Testing for Control Logics in Nuclear Industrial Distributed Control Systems', NULL, NULL, '2021 IEEE Access', 'Access', '9', NULL, '84021 - 84033', NULL, 'https://doi.org/10.1109/ACCESS.2021.3087165', 'Combinatorial Testing', 'Due to the complexity of the nuclear industrial distributed control system (DCS), input-domain testing techniques, including random testing and combinatorial testing, are usually utilized to test the control logics in nuclear industrial DCS. To improve the fault detection efficiency of random testing, the adaptive random testing technique selects a test case that significantly differs from all existing test cases. Similarly, to improve the fault detection efficiency of combinatorial testing, the greedy combinatorial testing technique adopts a greedy strategy to generate test cases that cover more uncovered tuple-combinations of parametric values. In this paper, we designed an experiment to compare the fault detection efficiency between adaptive random testing technique and greedy combinatorial testing technique for control logics of nuclear industrial DCS. Through the analysis of the fault detection ratios, the f-measure values, and the values of average percent of faults detected (APFD) on two experimental subjects, including the commonly used benchmarks in the field of Boolean-specification testing as well as a group of Boolean expressions extracted from the control logics in nuclear industrial DCS, the experimental results give us the following conclusions: (1) If the test suites\' sizes are relatively small, the fault detection efficiencies of the two techniques are very close though there is a slight advantage in adaptive random testing; (2) With the gradual increase of test suites\' sizes, the fault detection efficiency of greedy combinatorial testing is beyond adaptive random testing gradually. Such a result can help us select the appropriate testing techniques in the testing of the control logics in nuclear industry DCS.', NULL);
INSERT INTO `list` VALUES (10011, '0000-00-00', 2021, 'article', 'Frano Skopljanac-Macina, Ivona Zakarija, Bruno Blaskovic', 'Towards Automated Assessment Generation in e-Learning Systems Using Combinatorial Testing and Formal Concept Analysis', NULL, NULL, '2021 IEEE Access', 'Access', 'PP', NULL, '1-1', NULL, 'https://doi.org/10.1109/ACCESS.2021.3070510', 'Combinatorial Testing', 'In this paper, we research the use of software combinatorial testing techniques and the Formal Concept Analysis method for preparing sets of questions for student assessment in e-learning systems. Utilizing these techniques and methods, we ensure that the selected questions optimally cover the course material and that each question combines multiple topics. Therefore, in this paper we introduce our method for preparing student assessments that performs automated combinatorial testing and selection of questions, as well as automated generation of appropriate sequences of questions. The input for our method is a set of questions labelled with attributes or features. This set of questions is pre-processed using the Formal Concept Analysis method, and then the combinatorial testing of question features is performed, which generates a concise list of test-cases covering all pairs or triples of question features. Correspondingly, our method helps in identifying and selecting a subset of questions that covers all generated test-cases. Afterwards, the Formal Concept Analysis method automatically generates suitable sequences of selected questions for formative student assessments in e-learning systems. In this paper we implemented the proposed combinatorial testing method, and also demonstrated the feasibility of the proposed method on a use-case from an actual e-learning system.', NULL);
INSERT INTO `list` VALUES (10012, '0000-00-00', 2022, 'article', 'Tyler Cody, Erin Lanus, Daniel D. Doyle, Laura J. Freeman', 'Systematic Training and Testing for Machine Learning Using Combinatorial Interaction Testing', NULL, NULL, '2022 IEEE International Conference on Software Testing, Verification and Validation Workshops (ICSTW)', 'ICSTW', NULL, NULL, '102-109', NULL, 'https://arxiv.org/abs/2201.12428', 'Combinatorial Testing', 'This paper demonstrates the systematic use of combinatorial coverage for selecting and characterizing test and training sets for machine learning models. The presented work adapts combinatorial interaction testing, which has been successfully leveraged in identifying faults in software testing, to characterize data used in machine learning. The MNIST hand-written digits data is used to demonstrate that combinatorial coverage can be used to select test sets that stress machine learning model performance, to select training sets that lead to robust model performance, and to select data for fine-tuning models to new domains. Thus, the results posit combinatorial coverage as a holistic approach to training and testing for machine learning. In contrast to prior work which has focused on the use of coverage in regard to the internal of neural networks, this paper considers coverage over simple features derived from inputs and outputs. Thus, this paper addresses the case where the supplier of test and training sets for machine learning models does not have intellectual property rights to the models themselves. Finally, the paper addresses prior criticism of combinatorial coverage and provides a rebuttal which advocates the use of coverage metrics in machine learning applications.', NULL);
INSERT INTO `list` VALUES (10013, '0000-00-00', 2022, 'inproceedings', 'Naoko Okubo, Shoma Takatsuki, Yasushi Ueda', 'Experience of Combinatorial Testing toward Fault Detection, Isolation and Recovery Functionality', NULL, NULL, '2022 IEEE International Conference on Software Testing, Verification and Validation Workshops (ICSTW)', 'ICSTW', NULL, NULL, '68-71', NULL, 'https://doi.org/10.1109/ICSTW55395.2022.00025', 'Combinatorial Testing', 'The functionality of Fault Detection, Isolation, and Recovery (FDIR) is a key factor in achieving the high reliability of space systems. The test suites for the FDIR functionality in JAXA’s space systems are manually designed by expert engineers with decades of experience to achieve as high combination coverage with a small test suite as possible. However, there are only a few engineers who can perform such ad-hoc test suite design. Therefore, FDIR functionality testing requires a supportive method to generate a test suite with the high combination coverage with the smallest size that can be executed in the development timescale. In this paper, we describe our experience in applying popular combinatorial testing techniques to generate the real-world earth-observation satellite’s FDIR functionality test suites and comparing them with conventional human-derived test suite. The purpose of this comparison is to check the capability of the existing combinatorial testing methods toward FDIR functionality testing. Here, the FDIR functionality testing were treated as combinatorial configuration testing. As a result, we found that the 2-way coverage rate by the human, PICT, ACTS and the HAYST method were 72.7%, 66.3%, 68.8% and 72.2% with 16, 10, 10 and 14 test cases, respectively.', NULL);
INSERT INTO `list` VALUES (10014, '0000-00-00', 2022, 'inproceedings', 'Xiao-Nan Lu, Masakazu Jimbo', 'Error-Correcting Locating Arrays for Interaction Fault Location in Combinatorial Testing', NULL, NULL, '2022 IEEE International Symposium on Information Theory (ISIT)', 'ISIT', NULL, NULL, '1094-1099', NULL, 'https://doi.org/10.1109/ISIT50566.2022.9834368', 'Combinatorial Testing', 'A new notion, error-correcting locating arrays (ECLAs), is presented for locating interaction faults in component-based systems using combinatorial testing. Error tolerances of commonly used combinatorial arrays for testing such as covering arrays and locating arrays are discussed. Moreover, coding-theoretic characterization and constructions for ECLAs are proposed. Lastly, it is shown that multi-value Paley matrices can be used as ECLAs with high error tolerances for which the proof is based on character sums in finite fields.', NULL);
INSERT INTO `list` VALUES (10015, '0000-00-00', 2022, 'inproceedings', 'Marcel Maehren, Philipp Nieting, Sven Hebrok, Robert Merget, Juraj Somorovsky, Jörg Schwenk', 'TLS-Anvil: Adapting Combinatorial Testing for TLS Librarie', NULL, NULL, '2022 USENIX Security Symposium', 'USENIX Security', NULL, NULL, 'not found', NULL, 'https://www.usenix.org/conference/usenixsecurity22/presentation/maehren', 'Combinatorial Testing', 'Although the newest versions of TLS are considered secure, flawed implementations may undermine the promised security properties. Such implementation flaws result from the TLS specifications\' complexity, with exponentially many possible parameter combinations. Combinatorial Testing (CT) is a technique to tame this complexity, but it is hard to apply to TLS due to semantic dependencies between the parameters and thus leaves the developers with a major challenge referred to as the test oracle problem: Determining if the observed behavior of software is correct for a given test input.\r\n\r\nIn this work, we present TLS-Anvil, a test suite based on CT that can efficiently and systematically test parameter value combinations and overcome the oracle problem by dynamically extracting an implementation-specific input parameter model (IPM) that we constrained based on TLS specific parameter value interactions. Our approach thus carefully restricts the available input space, which in return allows us to reliably solve the oracle problem for any combination of values generated by the CT algorithm.\r\n\r\nWe evaluated TLS-Anvil with 13 well known TLS implementations, including OpenSSL, BoringSSL, and NSS. Our evaluation revealed two new exploits in MatrixSSL, five issues directly influencing the cryptographic operations of a session, as well as 15 interoperability issues, 116 problems related to incorrect alert handling, and 100 other issues across all tested libraries.', NULL);
INSERT INTO `list` VALUES (10016, '0000-00-00', 2022, 'inproceedings', 'Rui Huang, Chang Rao, Yu Lei, Jin Guo, Yadong Zhang', 'Applying Combinatorial Testing to High-Speed Railway Automatic Train Protection System', NULL, NULL, '2022 IEEE International Conference on Software Testing, Verification and Validation Workshops (ICSTW)', 'ICSTW', NULL, NULL, '49-56', NULL, 'https://doi.org/10.1109/ICSTW55395.2022.00022', 'Combinatorial Testing', 'The onboard Automatic Train Protection System (ATP) is one of the key components of the Chinese high-speed railway train control system. ATP is a safety-critical system since a failure of ATP could result in serious accidents. This paper reports a combinatorial testing practice performed in testing one of the major ATP functions, i.e. Balise Information Processing (BIP). We created one input model for each of the total 7 application scenarios of BIP. We generated a total of 178 pair-wise tests using the ACTS tool. We executed all these 178 tests, among which 172 tests passed and 6 tests failed. We found a total of 5 new faults, including 2 critical faults, and 3 major faults. We believe that combinatorial testing can be a very effective approach to testing large and complex real-world systems such as ATP.', NULL);
INSERT INTO `list` VALUES (10017, '0000-00-00', 2022, 'inproceedings', 'Giray Coskun, Cankut Coskun, Hanefi Mercan, Cemal Yilmaz', 'Using Unified Combinatorial Interaction Testing for MC/DC Coverage', NULL, NULL, '2022 IEEE International Conference on Software Testing, Verification and Validation Workshops (ICSTW)', 'ICSTW', NULL, NULL, '57-62', NULL, 'https://doi.org/10.1109/ICSTW55395.2022.00023', 'Combinatorial Testing', 'In this work, we express the masking and unique-cause MC/DC coverage criteria in Unified Combinatorial Interaction Testing (U-CIT) to test the interactions between the compile-time configuration options in highly configurable software systems. Our goal is not to propose yet another approach for achieving MC/DC coverage, but to further demonstrate the flexibility of U-CIT by applying it to a coverage criterion, which is quite different than the ones addressed by U-CIT so far. As the MC/DC criterion requires two test cases to show the independence of each condition, the test cases included in a U-CIT object cannot be generated independently from each other, which was the case for the coverage criteria addressed by U-CIT so far. Our empirical evaluations conducted on a dozen of highly configurable software systems demonstrate that U-CIT can flexibly address the aforementioned coverage criteria.', NULL);
INSERT INTO `list` VALUES (10018, '0000-00-00', 2022, 'inproceedings', 'Huayao Wu, Lixin Xu, Xintao Niu, Changhai Nie', 'Combinatorial Testing of RESTful APIs', NULL, NULL, '2022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)', 'ICSE', NULL, NULL, '426-437', NULL, 'https://doi.org/10.1145/3510003.3510151', 'Combinatorial Testing', 'This paper presents RestCT, a systematic and fully automatic approach that adopts Combinatorial Testing (CT) to test RESTful APIs. RestCT is systematic in that it covers and tests not only the interactions of a certain number of operations in RESTful APIs, but also the interactions of particular input-parameters in every single operation. This is realised by a novel two-phase test case generation approach, which first generates a constrained sequence covering array to determine the execution orders of available operations, and then applies an adaptive strategy to generate and refine several constrained covering arrays to concretise input-parameters of each operation. RestCT is also automatic in that its application relies on only a given Swagger specification of RESTful APIs. The creation of CT test models (especially, the inferring of dependency relationships in both operations and input-parameters), and the generation and execution of test cases are performed without any human intervention. Experimental results on 11 real-world RESTful APIs demonstrate the effectiveness and efficiency of RestCT. In particular, RestCT can find eight new bugs, where only one of them can be triggered by the state-of-the-art testing tool of RESTful APIs.', NULL);
INSERT INTO `list` VALUES (10019, '0000-00-00', 2022, 'inproceedings', 'Muhammad Nouman Zafar, Wasif Afzal, Eduard Enoiu', 'Evaluating system-level test generation for industrial software: a comparison between manual, combinatorial and model-based testing', NULL, NULL, '2022 IEEE/ACM International Conference on Automation of Software Test (AST)', 'AST', NULL, NULL, '148-159', NULL, 'https://doi.org/10.1145/3524481.3527235', 'Combinatorial Testing', 'Adequate testing of safety-critical systems is vital to ensure correct functional and non-functional operations. Previous research has shown that testing such systems requires a lot of effort, thus automated testing techniques have found a certain degree of success. However, automated testing has not replaced the need for manual testing, rather a common industrial practice exhibits a balance between automated and manual testing. In this respect, comparing manual testing with automated testing techniques continues to be an interesting topic to investigate. The need for this investigation is most apparent at system-level testing of industrial systems, where there is a lack of results on how different testing techniques perform concerning both structural and system-level metrics such as Modified Condition/Decision Coverage (MC/DC) and requirement coverage. In addition to the coverage, the cost of these techniques will also determine their efficiency and thus practical viability. In this paper, we have developed cost models for efficiency measurement and performed an experimental evaluation of manual testing, model-based testing (MBT), and combinatorial testing (CT) in terms of MC/DC and requirement coverage. The evaluation is done in an industrial context of a safety-critical system that controls several functions on-board the passenger trains. We have reported the dominant conditions of MC/DC affected by each technique while generating MC/DC adequate test suites. Moreover, we investigated differences and overlaps of test cases generated by each of the three techniques. The results showed that all test suites achieved 100% requirement coverage except the test suite generated by the pairwise testing strategy. However, MBT-generated test suites were more MC/DC adequate and provided a higher number of both similar and unique test cases. Moreover, unique test cases generated by MBT had an observable effect on MC/DC, which will complement manual testing to increase MC/DC coverage. The least dominant MC/DC condition fulfilled by the generated test cases by all three techniques is the ‘independent effect of a condition on the outcomes of a decision’. Lastly, the evaluation also showed CT as the most efficient testing technique amongst the three in terms of time required for test generation and execution, but with an added cost parameter of manual identification of expected outcomes. CCS CONCEPTS •Computer systems organization →Embedded software; • Software and its engineering →Software verification and validation.', NULL);
INSERT INTO `list` VALUES (10020, '0000-00-00', 2022, 'article', 'Xintao Niu, Huayao Wu, Changhai Nie, Yu Lei, Xiaoyin Wang', 'A Theory of Pending Schemas in Combinatorial Testing', NULL, NULL, '2022 IEEE Transactions on Software Engineering', 'TSE', '48', '10', '4119-4151', NULL, 'https://doi.org/10.1109/TSE.2021.3113920', 'Combinatorial Testing', 'Combinatorial Testing (CT) is an effective testing technique for detecting failures which are triggered by the interactions of various factors that influence the behaviour of a system. Although many studies in CT have designed elaborate test suites (called covering arrays) to systemically check each possible factor interaction, they provide weak support to locate the concrete failure-inducing interactions, i.e., the Minimal Failure-causing Schemas (MFS). To this end, a variety of MFS identification approaches have been proposed. However, as this study reveals, these approaches suffer from various issues such as cannot identify multiple overlapping MFSs, cannot handle MFSs with high degrees, cannot be applied to systems with large number of parameters, etc. These issues are essentially caused by the exponential computing complexity of checking every interaction in the test cases. Therefore, they can only focus on a subset of all the possible interactions, resulting in many interactions unnoticed. Ignoring these unnoticed interactions could potentially cause failures that have never been systematically checked. Hence, it is beneficial for MFS identification approaches to identify these interactions. In order to account for these unnoticed interactions in CT, this study introduces the notion of pending schema, based on which a theoretical framework of CT schemas is established. In particular, we formally define the determinability of a schema in CT with respect to given information; as such, the yet-to-be determined schemas are exactly the pending schemas. The relationships between the different schemas (faulty, healthy, and pending) and test cases are also theoretically analyzed. Based on which, we further propose three formulas, along with three corresponding algorithms, for the identification of the pending schemas in failing test cases, and formally prove their correctness. As a result, we reduce the complexity of obtaining pending schemas with respect to the number of factors that may have influences on the software.', NULL);
INSERT INTO `list` VALUES (10021, '0000-00-00', 2022, 'article', 'Hanefi Mercan, Arsalan Javeed, Cemal Yilmaz', 'Flexible Combinatorial Interaction Testing', NULL, NULL, '2022 IEEE Transactions on Software Engineering', 'TSE', '48', '3', '1030-1066', NULL, 'https://doi.org/10.1109/TSE.2020.3010317', 'Combinatorial Testing', 'We present Flexible Combinatorial Interaction Testing (F-CIT), which aims to improve the flexibility of combinatorial interaction testing (CIT) by eliminating the necessity of developing specialized constructors for CIT problems that cannot be efficiently and effectively addressed by the existing CIT constructors. F-CIT expresses the entities to be covered and the space of valid test cases, from which the samples are drawn to obtain full coverage, as constraints. Computing an F-CIT object (i.e., a set of test cases obtaining full coverage under a given coverage criterion) then turns into an interesting constraint solving problem, which we call cov-CSP . cov-CSP aims to divide the constraints, each representing an entity to be covered, into a minimum number of satisfiable clusters, such that a solution for a cluster represents a test case and the collection of all the test cases generated (one per cluster) constitutes an F-CIT object, covering each required entity at least once. To solve the cov-CSP problem, thus to compute F-CIT objects, we first present two constructors. One of these constructors attempts to cover as many entities as possible in a cluster before generating a test case, whereas the other constructor generates a test case first and then marks all the entities accommodated by this test case as covered. We then use these constructors to evaluate F-CIT in three studies, each of which addresses a different CIT problem. In the first study, we develop structure-based F-CIT objects to obtain decision coverage-adequate test suites. In the second study, we develop order-based F-CIT objects, which enhance a number of existing order-based coverage criteria by taking the reachability constraints imposed by graph-based models directly into account when computing interaction test suites. In the third study, we develop usage-based F-CIT objects to address the scenarios, in which standard covering arrays are not desirable due to their sizes, by choosing the entities to be covered based on their usage statistics collected from the field. We also carry out user studies to further evaluate F-CIT. The results of these studies suggest that F-CIT is more flexible than the existing CIT approaches.', NULL);
INSERT INTO `list` VALUES (10022, '0000-00-00', 2022, 'article', 'Yves Le Traon, Tao Xie', 'Combinatorial testing and model checking', NULL, NULL, '2022 Software Testing, Verification and Reliability', 'STVR ', '32', '6', 'not found', NULL, 'https://doi.org/10.1002/stvr.1832', 'Combinatorial Testing', 'This issue contains two papers. The first paper focuses on combinatorial testing, and the second one focuses on model checking.\r\n\r\nThe first paper, ‘Combinatorial methods for dynamic grey-box SQL injection testing’ by Bernhard Garn, Jovan Zivanovic, Manuel Leithner and Dimitris E. Simos, concerns combinatorial testing for SQL injection. Code injections attacks, and in particular SQL injection (SQLi) attacks, are still among the most critical threats for web applications. These attacks rely on exploiting vulnerabilities, which must be actively chased to deploy a secure system. Leveraging combinatorial testing, the authors propose novel attack grammars to generate SQLi attacks against MySQL-compatible databases. One originality of this contribution resides in dynamically optimizing and improving the attack grammars to the context. This context-sensitive adaptation technique is supported by a prototype tool named SQLInjector+ and is validated and benchmarked on a representative set of web applications under test. The contribution is accompanied by a nice addition to the field: a simple framework called WAFTF for testing the filtering techniques of web application firewalls such as ModSecurity. (Recommended by Yves Le Traon)\r\n\r\nThe second paper, ‘Comprehensive evaluation of file systems robustness with SPIN model checking’ by Jingcheng Yuan, Toshiaki Aoki and Xiaoyun Guo, presents a study that comprehensively evaluates the robustness of file systems using a model checking approach, covering the majority of the mainstream file system types and both single-thread and multi-thread modes. In particular, to abstract real file systems, the authors developed Promela models optimized to avoid state explosion during model checking and used an SPIN model checker to check these models for detecting corner-case errors during an unexpected power outage. The authors analysed counterexamples generated by model checking to determine an improved file system model that is capable of preventing errors in most mainstream file system types and then rechecked the improved file system model and verified the absence of all critical errors. (Recommended by Moonzoo Kim)', NULL);
INSERT INTO `list` VALUES (10023, '0000-00-00', 2022, 'article', 'Robert M. Hierons, Tao Xie', 'Combinatorial testing and model-based testing', NULL, NULL, '2022 Software Testing, Verification and Reliability', 'STVR ', '32', '2', 'not found', NULL, 'https://doi.org/10.1002/stvr.1810', 'Combinatorial Testing', 'Software Testing, Verification and Reliability', NULL);
INSERT INTO `list` VALUES (10024, '0000-00-00', 2022, 'article', 'Bernhard Garn, Jovan Zivanovic, Manuel Leithner, Dimitris E. Simos', 'Combinatorial methods for dynamic gray-box SQL injection testing', NULL, NULL, '2022 Software Testing, Verification and Reliability', 'STVR ', '32', '6', 'not found', NULL, 'https://doi.org/10.1002/stvr.1826', 'Combinatorial Testing', 'This work presents an extended and enhanced gray-box combinatorial security testing methodology for SQL injection vulnerabilities in web applications. We propose multiple new attack grammars modelling SQLi attacks against MySQL-compatible databases, each one targeting a different injection context. Additionally, these grammars are also dynamically refined at the beginning of each attack against an endpoint of a web application, as a further optimization of the used attack model by taking into account the specifics of the generated query of that endpoint. Our goal is to enhance existing combinatorial approaches for detecting SQL injection vulnerabilities. The newly developed methodology is implemented in a prototype security testing tool called SQLInjector+, which is an extension of an earlier prototype developed by us in prior work. This improved tool can attack (i.e. test) any web application that uses a MySQL-compatible database management system. We evaluate our revised approach and improved prototype tool in a case study comprising of different kinds of web applications to which SQLi is a potential security threat. The case study contains the well-known verification framework WAVSEP among other five real-world web applications and one web application firewall. Our generated attack vectors, constructed via combinatorial methods applied to our improved and dynamically optimized attack grammars, are capable of injecting every known vulnerable endpoint in WAVSEP and also of finding new vulnerable parameters in some of the real-world applications investigated in this paper. Our approach performs equally well or better when compared with existing state-of-art of SQL injection security testing tools (sqlmap, w3af, wapiti and fuzzdb) across all tested web applications in the case study.', NULL);
INSERT INTO `list` VALUES (10025, '0000-00-00', 2022, 'article', 'Bernhard Garn, Dominik-Philip Schreiber, Dimitris E. Simos, Rick Kuhn, Jeffrey M. Voas, Raghu Kacker', 'Combinatorial methods for testing Internet of Things smart home systems', NULL, NULL, '2022 Software Testing, Verification and Reliability', 'STVR ', '32', '2', 'not found', NULL, 'https://doi.org/10.1002/stvr.1805', 'Combinatorial Testing', 'In this paper, we report on applying combinatorial testing to Internet of Things (IoT) home automation hub systems. We detail how to create a dedicated input parameter model of an IoT home automation hub system for use with combinatorial test case generation strategies. Further, we developed an automated test execution framework and two test oracles for evaluation purposes. We applied and evaluated our proposed methodological approach to a real-world IoT system and analysed the obtained results of various combinatorial test sets with different properties generated based on the derived input model. Additionally, we compare these results to a random testing approach. Our empirical testing evaluations revealed multiple errors in the tested devices and also showed that all considered approaches performed nearly equally well.', NULL);
INSERT INTO `list` VALUES (10026, '0000-00-00', 2022, 'article', 'Hiroshi Ukai, Xiao Qu, Hironori Washizaki, Yoshiaki Fukazawa', 'Accelerating covering array generation by combinatorial join for industry scale software testing', NULL, NULL, '2022 PeerJ Computer Science', 'PeerJ Comput Sci', NULL, NULL, 'not found', NULL, 'https://doi.org/10.7717/peerj-cs.720', 'Combinatorial Testing', '\r\nCombinatorial interaction testing, which is a technique to verify a system with numerous input parameters, employs a mathematical object called a covering array as a test input. This technique generates a limited number of test cases while guaranteeing a given combinatorial coverage. Although this area has been studied extensively, handling constraints among input parameters remains a major challenge, which may significantly increase the cost to generate covering arrays. In this work, we propose a mathematical operation, called “weaken-product based combinatorial join”, which constructs a new covering array from two existing covering arrays. The operation reuses existing covering arrays to save computational resource by increasing parallelism during generation without losing combinatorial coverage of the original arrays. Our proposed method significantly reduce the covering array generation time by 13–96% depending on use case scenarios.', NULL);
INSERT INTO `list` VALUES (10027, '0000-00-00', 2022, 'article', 'Hanefi Mercan, Atakan Aytar, Giray Coskun, Dilara Müstecep, Gülsüm Uzer, Cemal Yilmaz', 'CIT-daily: A combinatorial interaction testing-based daily build process', NULL, NULL, '2022 Journal of Systems and Software', 'JSS', '190', NULL, '111353', NULL, 'https://doi.org/10.1016/j.jss.2022.111353', 'Combinatorial Testing', 'In this work, we introduce an approach, called CIT-daily, which integrates combinatorial interaction testing (CIT) with the daily build processes to systematically test the interactions between the factors/parameters affecting the system’s behaviors, on a daily basis. We also develop a number of CIT-daily strategies and empirically evaluate them on highly-configurable systems. The first strategy tests the same \r\n-way covering array every day throughout the process, achieving a \r\n-way coverage on a daily basis by covering each possible combination of option settings for every combination of \r\n options. The other strategies, on the other hand, while guaranteeing a \r\n-way coverage on a daily basis, aim to cover higher order interactions between the configuration options over time by varying the \r\n-way covering arrays tested. In the experiments, we observed that the proposed approach significantly improved the effectiveness (i.e., fault revealing abilities) of the daily build processes; randomizing the coverage of higher order interactions between the configuration options while guaranteeing a base \r\n-way coverage every day, further improved the effectiveness; and the more the higher order interactions covered during the process, the higher the fault revealing abilities tended to be.', NULL);
INSERT INTO `list` VALUES (10028, '0000-00-00', 2022, 'article', 'Qianqian Yang, Xiao-Nan Lu', 'An Improved Adaptive Algorithm for Locating Faulty Interactions in Combinatorial Testing', NULL, NULL, '2022 IEICE TRANSACTIONS on Fundamentals of Electronics, Communications and Computer', 'IEICE ', 'E105.A', NULL, 'not found', NULL, 'https://doi.org/10.1587/transfun.2021eap1071', 'Combinatorial Testing', 'Combinatorial testing is an effective testing technique for detecting faults in a software or hardware system with multiple factors using combinatorial methods. By performing a test, which is an assignment of possible values to all the factors, and verifying whether the system functions as expected (pass) or not (fail), the presence of faults can be detected. The failures of the tests are possibly caused by combinations of multiple factors assigned with specific values, called faulty interactions. Martínez et al. [1] proposed the first deterministic adaptive algorithm for discovering faulty interactions involving at most two factors where each factor has two values, for which graph representations are adopted. In this paper, we improve Martínez et al.\'s algorithm by an adaptive algorithmic approach for discovering faulty interactions in the so-called “non-2-locatable” graphs. We show that, for any system where each “non-2-locatable factor-component” involves two faulty interactions (for example, a system having at most two faulty interactions), our improved algorithm efficiently discovers all the faulty interactions with an extremely low mistaken probability caused by the random selection process in Martínez et al.\'s algorithm. The effectiveness of our improved algorithm are revealed by both theoretical discussions and experimental evaluations.', NULL);
INSERT INTO `list` VALUES (10029, '0000-00-00', 2022, 'article', 'Carlos Ansótegui, Felip Manyà, Jesus Ojeda, Josep M. Salvia, Eduard Torres', 'Incomplete MaxSAT approaches for combinatorial testing', NULL, NULL, '2022 Journal of Heuristics', 'JOH', '28', '4', '377–431', NULL, '10.1007/s10732-022-09495-3', 'Combinatorial Testing', 'We present a Satisfiability (SAT)-based approach for building Mixed Covering Arrays with Constraints of minimum length, referred to as the Covering Array Number problem. This problem is central in Combinatorial Testing for the detection of system failures. In particular, we show how to apply Maximum Satisfiability (MaxSAT) technology by describing efficient encodings for different classes of complete and incomplete MaxSAT solvers to compute optimal and suboptimal solutions, respectively. Similarly, we show how to solve through MaxSAT technology a closely related problem, the Tuple Number problem, which we extend to incorporate constraints. For this problem, we additionally provide a new MaxSAT-based incomplete algorithm. The extensive experimental evaluation we carry out on the available Mixed Covering Arrays with Constraints benchmarks and the comparison with state-of-the-art tools confirm the good performance of our approaches', NULL);
INSERT INTO `list` VALUES (10030, '0000-00-00', 2022, 'article', 'Linghuan Hu, W. Eric Wong, D. Richard Kuhn, Raghu N. Kacker, Shuo Li', 'CT-IoT: a combinatorial testing-based path selection framework for effective IoT testing', NULL, NULL, '2022 Empirical Software Engineering', 'Empir Softw Eng.', '27', '2', 'not found', NULL, 'https://doi.org/10.1007/s10664-021-10017-1', 'Combinatorial Testing', 'Testing Internet of Things (IoT) systems is challenging. This is not only because of the various aspects of IoT systems, such as software, hardware, and network that need to be tested, but also because of the unexpected issues caused by a large number of heterogeneous devices brought together by IoT systems. When an IoT system has hundreds, or even thousands, of heterogeneous devices, which devices should be tested to detect more faults? How can we systematically test an IoT system and its numerous devices in a cost-effective way? Are there any coverage criteria for testers to evaluate the thoroughness of the testing against IoT systems? In this paper, we present a combinatorial testing path selection framework for IoT systems, called CT-IoT, that systematically identifies and recommends testing paths in IoT systems for effective testing. We also propose four coverage criteria that can help testers evaluate the testing thoroughness for IoT systems. We conducted an empirical study of CT-IoT on two real-world IoT systems and evaluated the effectiveness of CT-IoT in terms of coverage achievements. The results show the superiority of CT-IoT over a random approach.', NULL);
INSERT INTO `list` VALUES (10031, '0000-00-00', 2022, 'article', 'Ludwig Kampel, Dimitris E. Simos, D. Richard Kuhn, Raghu N. Kacker', 'An exploration of combinatorial testing-based approaches to fault localization for explainable AI', NULL, NULL, '2022 Annals of Mathematics and Artificial Intelligence', 'Ann Math Artif Intell.', '90', NULL, '951–964', NULL, 'https://doi.org/10.1007/s10472-021-09772-0', 'Combinatorial Testing', 'We briefly review properties of explainable AI proposed by various researchers. We take a structural approach to the problem of explainable AI, examine the feasibility of these aspects and extend them where appropriate. Afterwards, we review combinatorial methods for explainable AI which are based on combinatorial testing-based approaches to fault localization. Last, we view the combinatorial methods for explainable AI through the lens provided by the properties of explainable AI that are elaborated in this work. We pose resulting research questions that need to be answered and point towards possible solutions, which involve a hypothesis about a potential parallel between software testing, human cognition and brain capacity.', NULL);
INSERT INTO `list` VALUES (10032, '0000-00-00', 2022, 'article', 'Yasmeen Akhtar', 'A hyperedge coloring and application in combinatorial testing', NULL, NULL, '2022 AKCE International Journal of Graphs and Combinatorics', 'AKCE ', '19', NULL, '1-8', NULL, 'https://doi.org/10.1080/09728600.2022.2081523', 'Combinatorial Testing', 'For a hypergraph H, a uniform k-coloring of hyperedges always has the same (to within 1) number of hyperedges of each color, whereas an equitable k-coloring of hyperedges has the property that at every vertex all the colors incident the same number of times (to within 1). For every \r\n�\r\n≥\r\n2\r\n,\r\n the r-uniform complete r-partite hypergraph \r\n�\r\n�\r\n1\r\n,\r\n�\r\n2\r\n,\r\n…\r\n,\r\n�\r\n�\r\n�\r\n always admits an equitable k-coloring of hyperedges that is also uniform. This paper establishes the existence of an equitable and uniform coloring of hyperedges in a 3-uniform complete tripartite (multi)hypergraph such that the hyperedges of the same color form a connected partial hypergraph with the property that subhypergraph induced by a pair of parts of its vertex set is a complete bipartite graph. Further, we use this coloring for introducing a new hyperedge-hooking operation to construct optimal size mixed covering arrays on hypergraphs.', NULL);
INSERT INTO `list` VALUES (10033, '0000-00-00', 2022, 'article', 'Aminu Aminu Muazu, Ahmad Sobri Hashim, Aliza Sarlan', 'Review of Nature Inspired Metaheuristic Algorithm Selection for Combinatorial t-Way Testing', NULL, NULL, '2022 IEEE Access', 'Access', NULL, NULL, '27404-27431', NULL, 'https://doi.org/10.1109/ACCESS.2022.3157400', 'Combinatorial Testing', 'The metaheuristic algorithm is a very important area of research that continuously improves in solving optimization problems. Nature-inspired is one of the metaheuristic algorithm classifications that has grown in popularity among researchers over the last few decades. Nature-inspired metaheuristic algorithms contribute significantly to tackling many standing complex problems (such as the combinatorial t-way testing problem) and achieving optimal results. One challenge in this area is the combinatorial explosion problem, which is always intended to find the most optimal final test suite that will cover all combinations of a given interaction strength. As such, test case generation has been selected as the most active research area in combinatorial t-way testing as Non-deterministic Polynomial-Time Hardness (NP-hard). However, not all metaheuristics are effectively adopted in combinatorial t-way testing, some proved to be effective and thus have been popular tools selected for optimization, whilst others were not. This research paper outlines a hundred and ten (110) outstanding nature-inspired metaheuristic algorithms for the last decades (2001 and 2021), such as the Coronavirus Optimization Algorithm, Ebola Optimization Algorithm, Harmony Search, Tiki-Taka Algorithm, and so on. The purpose of this review is to revisit and carry out an up-to-date review of these distinguished algorithms with their respective current states of use. This is to inspire future research in the field of combinatorial t-way testing for better optimization. Thus, we found that all metaheuristics have a simple structure that can be adopted in different areas to become more efficient in optimization. Finally, we suggested some future paths of investigation for researchers who are interested in the combinatorial t-way testing field to employ more of these algorithms by tuning their parameters settings to achieve an optimal solution.', NULL);
INSERT INTO `list` VALUES (10034, '0000-00-00', 2022, 'article', 'Ludwig Kampel, Paris Kitsos, Dimitris E. Simos', 'Locating Hardware Trojans Using Combinatorial Testing for Cryptographic Circuits', NULL, NULL, '2022 IEEE Access', 'Access', '10', NULL, '18787-18806', NULL, 'https://doi.org/10.1109/ACCESS.2022.3151378', 'Combinatorial Testing', 'This paper presents a novel method for locating combinational hardware Trojans (HT) based on fault location approaches used in combinatorial testing. This method relies exclusively on the combinatorial properties of the executed test vectors and the results of test execution. Under specific assumptions, the method is guaranteed to locate all combinational HTs with trigger patterns of length ℓ or less, with the location process itself consuming negligible time. We give a description of our method by devising suitable algorithms and provide the links to combinatorial fault location. Furthermore, we demonstrate our approach in a concrete case study where we locate HTs embedded in a circuit that implements the AES symmetric-key encryption algorithm with 128 bits key length. In these experiments, we demonstrate how any HT that is activated by a trigger pattern of length ℓ≤8 can be located in an effective way. Our method compares particularly well against randomized approaches. Although instantiated for a specific circuit in our case study, the proposed approach is generic, due to its algorithmic description, and can be applied for testing other (cryptographic) circuits. We believe that our work presents an important first step in the development of more general logic testing methodologies for HT location using combinatorial testing methods.', NULL);
INSERT INTO `list` VALUES (10035, '0000-00-00', 2023, 'inproceedings', 'Hao Jin, Ce Shi, Tatsuhiro Tsuchiya', 'Constrained detecting arrays: Mathematical structures for fault identification in combinatorial interaction testing', NULL, NULL, '2023 Information and Software Technology', 'IST', '153', NULL, '107045', NULL, 'https://doi.org/10.1016/j.infsof.2022.107045', 'Combinatorial Testing', 'Context:\r\nDetecting arrays are mathematical structures aimed at fault identification in combinatorial interaction testing. However, they cannot be directly applied to systems that have constraints on the test parameters. These constraints are prevalent in real-world systems.\r\n\r\nObjective:\r\nThis paper proposes constrained detecting arrays (CDAs), an extension of detecting arrays, which can be used for systems with constraints.\r\n\r\nMethods:\r\nThe properties and capabilities of CDAs are examined with rigorous arguments. Moreover, two algorithms are proposed for constructing CDAs: one is aimed at generating minimum CDAs, and the other is a heuristic algorithm aimed at fast generation of CDAs. The algorithms were experimentally evaluated using a benchmark dataset.\r\n\r\nResults:\r\nExperimental results show that the first algorithm can generate minimum CDAs if a sufficiently long generation time is allowed, and the second algorithm can generate minimum or near-minimum CDAs in a reasonable time.\r\n\r\nConclusion:\r\nCDAs extend the range of application of detecting arrays to systems with constraints. The two proposed algorithms have different advantages with respect to array size and generation time.\r\n\r\n', NULL);
INSERT INTO `list` VALUES (10036, '0000-00-00', 2020, 'article', 'Jose Torres-Jimenez, Idelfonso Izquierdo-Marquez', 'Improved covering arrays using covering perfect hash families with groups of restricted entries', NULL, NULL, '2020 Appl. Math. Comput', 'Appl. Math. Comput', '369', '0', 'not found', NULL, 'https://doi.org/10.1016/j.amc.2019.124826', 'Combinatorial Testing', 'Covering perfect hash families (CPHFs) are used to represent compactly some covering arrays. For CPHFs there is an efficient way to determine if the covering arrays derived from them are or not complete covering arrays; and this characteristic eases the construction of large covering arrays by greedy and metaheuristic methods working over the CPHF representation. CPHFs has been constructed in other works by backtracking, tabu search, simulated annealing, and greedy methods. The present work introduces a new simulated annealing algorithm that is able to construct CPHFs with groups of rows with restricted entries. In a CPHF of this kind the entries have some dependencies among them, that is, the values in some rows restrict the values that can appear in other rows. Restricted CPHFs produce covering arrays smaller than the ones derived from CPHFs without restricted entries. By using the new simulated annealing algorithm, we construct 135 new CPHFs whose derived covering arrays improve the upper bound of 19,669 covering array numbers.', NULL);
INSERT INTO `list` VALUES (10037, '0000-00-00', 2021, 'article', 'Michael Wagner, Ludwig Kampel, Dimitris E. Simos', 'Heuristically Enhanced IPO Algorithms for Covering Array Generation', NULL, NULL, '2021 International Workshop on Combinatorial Algorithms', 'IWCA', NULL, NULL, '571–586', NULL, 'https://doi.org/10.1007/978-3-030-79987-8_40', 'Combinatorial Testing', 'The construction of covering arrays (CAs) with a small number of rows is a difficult optimization problem. CAs generated by greedy methods are often far from optimal, while many metaheuristics and search techniques become inefficient once larger instances are concerned. In this work, we propose to incorporate improvement heuristics directly into the constructing process of widely used in-parameter-order (IPO) algorithms for CA generation. We discuss how this approach can significantly reduce the search space of the heuristics and implement some of the discussed concepts in the SIPO algorithm, which enhances greedy IPO algorithms with Simulated Annealing. Using SIPO, we improved the best known upper bound on the number of rows of binary CAs of strength 6 for 43 different instances.', NULL);
INSERT INTO `list` VALUES (10038, '0000-00-00', 2021, 'inproceedings', 'Chuan Luo, Jinkun Lin, Shaowei Cai, Xin Chen, Bing He, Bo Qiao, Pu Zhao, Qingwei Lin, Hongyu Zhang, Wei Wu, Saravanakumar Rajmohan, Dongmei Zhang', 'AutoCCAG: An Automated Approach to Constrained Covering Array Generation', NULL, NULL, '2021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)', 'ICSE', NULL, NULL, '201-212', NULL, 'https://doi.org/10.1109/ICSE43902.2021.00030', 'Combinatorial Testing', 'Combinatorial interaction testing (CIT) is an important technique for testing highly configurable software systems with demonstrated effectiveness in practice. The goal of CIT is to generate test cases covering the interactions of configuration options, under certain hard constraints. In this context, constrained covering arrays (CCAs) are frequently used as test cases in CIT. Constrained Covering Array Generation (CCAG) is an NP-hard combinatorial optimization problem, solving which requires an effective method for generating small CCAs. In particular, effectively solving t-way CCAG with t>=4 is even more challenging. Inspired by the success of automated algorithm configuration and automated algorithm selection in solving combinatorial optimization problems, in this paper, we investigate the efficacy of automated algorithm configuration and automated algorithm selection for the CCAG problem, and propose a novel, automated CCAG approach called AutoCCAG. Extensive experiments on public benchmarks show that AutoCCAG can find much smaller-sized CCAs than current state-of-the-art approaches, indicating the effectiveness of AutoCCAG. More encouragingly, to our best knowledge, our paper reports the first results for CCAG with a high coverage strength (i.e., 5-way CCAG) on public benchmarks. Our results demonstrate that AutoCCAG can bring considerable benefits in testing highly configurable software systems.', NULL);
INSERT INTO `list` VALUES (10039, '0000-00-00', 2021, 'inproceedings', 'Jinkun Lin, Shaowei Cai, Bing He, Yingjie Fu, Chuan Luo, Qingwei Lin', 'FastCA: An Effective and Efficient Tool for Combinatorial Covering Array Generation', NULL, NULL, '2021 ICSE \'21: Proceedings of the 43rd International Conference on Software Engineering: Companion ProceedingsMay 2021 ', 'ICSE', NULL, NULL, '77–80', NULL, 'https://doi.org/10.1109/ICSE-Companion52605.2021.00040', 'Combinatorial Testing', 'Combinatorial interaction testing (CIT) is a popular approach to detecting faults in highly configurable software systems. The core task of CIT is to generate a small test suite called a t-way covering array (CA), where t is the covering strength. A major drawback of existing solvers for CA generation is that they usually need considerable time to obtain a high-quality solution, which hinders its wider applications. In this paper, we describe FastCA, an effective and efficient tool for generating constrained CAs. We observe that the high time consumption of existing meta-heuristic algorithms is mainly due to the procedure of score computation. To this end, we present a much more efficient method for score computation. Thanks to this new lightweight score computation method, FastCA can work in the gradient mode to effectively explore the search space. Experiments on a broad range of real-world benchmarks and synthetic benchmarks show that FastCA significantly outperforms state-of-the-art solvers, in terms of both the size of obtained covering array and the run time.\r\n\r\nVideo: https://youtu.be/-6CuojQIt-k\r\n\r\nRepository: https://github.com/jkunlin/FastCATool.git', NULL);
INSERT INTO `list` VALUES (10040, '0000-00-00', 2021, 'inproceedings', 'Carlos Ansótegui, Jesus Ojeda, Eduard Torres', 'Building High Strength Mixed Covering Arrays with Constraints', NULL, NULL, '2021 International Conference on Principles and Practice of Constraint Programming', 'CP', NULL, NULL, 'not found', NULL, 'https://doi.org/10.4230/LIPIcs.CP.2021.12', 'Combinatorial Testing', 'Covering arrays have become a key piece in Combinatorial Testing. In particular, we focus on the efficient construction of Covering Arrays with Constraints of high strength. SAT solving technology has been proven to be well suited when solving Covering Arrays with Constraints. However, the size of the SAT reformulations rapidly grows up with higher strengths. To this end, we present a new incomplete algorithm that mitigates substantially memory blow-ups. The experimental results confirm the goodness of the approach, opening avenues for new practical applications. 2012 ACM Subject Classification Theory of computation → Constraint and logic programming ', NULL);
INSERT INTO `list` VALUES (10041, '0000-00-00', 2021, 'article', 'Sajad Esfandyari, Vahid Rafe', 'GALP: a hybrid artificial intelligence algorithm for generating covering array', NULL, NULL, '2021 Soft Computing', 'Soft Comput', '25', NULL, '7673–7689', NULL, 'https://doi.org/10.1007/s00500-021-05788-0', 'Combinatorial Testing', 'Today, there are a lot of useful algorithms for covering array (CA) generation, one of the branches of combinatorial testing. The major CA challenge is the generation of an array with the minimum number of test cases (efficiency) in an appropriate run-time (performance), for large systems. CA generation strategies are classified into several categories: computational and meta-heuristic, to name the most important ones. Generally, computational strategies have high performance and yield poor results in terms of efficiency, in contrast, meta-heuristic strategies have good efficiency and lower performance. Among the strategies available, some are efficient strategies but suffer from low performance; conversely, some others have good performance, but is not such efficient. In general, there is not a strategy that enjoys both above-mentioned metrics. In this paper, it is tried to combine the genetic algorithm and the Augmented Lagrangian Particle Swarm Optimization with Fractional Order Velocity to produce the appropriate test suite in terms of efficiency and performance. Also, a simple and effective minimizing function is employed to increase efficiency. The evaluation results show that the proposed strategy outperforms the existing approaches in terms of both efficiency and performance.', NULL);
INSERT INTO `list` VALUES (10042, '0000-00-00', 2021, 'article', 'Jose Torres-Jimenez, Brenda Acevedo-Juárez, Himer Avila-George', 'Covering array EXtender', NULL, NULL, '2021 Applied Mathematics and Computation', 'Appl. Math. Comput', '402', NULL, '126122', NULL, 'https://doi.org/10.1016/j.amc.2021.126122', 'Combinatorial Testing', 'The combinatorial design, known as covering array, has been used mainly to exercise tests for software and hardware components. It has also been used in machine learning applications and the design of experiments for various applications. In this paper, a new approach to construct covering arrays is defined; it is called CAEX (stands for Covering Array EXtender). CAEX approach was tested in the construction of covering arrays of order three and strength two. The CAEX approach’s performance was evident by the definition of new upper-bounds in the size of some covering arrays; 34 new upper bounds for covering arrays were defined, remarkably a covering array with 112,770 parameters only requires 50 rows. One important goodness of the CAEX approach is that it can provide the genealogy of each covering array (how each covering arrays was constructed).', NULL);
INSERT INTO `list` VALUES (10043, '0000-00-00', 2022, 'inproceedings', 'Irene Hiess, Ludwig Kampel, Michael Wagner, Dimitris E. Simos', 'IPO-MAXSAT: Combining the In-Parameter-Order Strategy for Covering Array Generation with MaxSAT Solving (Extended Abstract)', NULL, NULL, '2022 Fifteenth International Symposium on Combinatorial Search ', 'SoCS', '15', '1', 'not found', NULL, 'https://ojs.aaai.org/index.php/SOCS/article/view/21788', 'Combinatorial Testing', 'Covering arrays (CAs) are discrete objects appearing in combinatorial design theory that find practical applications, most prominently in software testing. The generation of optimized CAs is a difficult combinatorial optimization problem being subject to ongoing research. Previous studies have shown that many different algorithmic approaches are best suited for different instances of CAs. In this extended abstract we describe the IPO-MAXSAT algorithm, which adopts the prominent IPO strategy for CA generation and uses MaxSAT solving to optimize the occurring sub-problems.', NULL);
INSERT INTO `list` VALUES (10044, '0000-00-00', 2022, 'inproceedings', 'Silvia P. Boumova, Peter G. Boyvalenkov, Maya Stoyanova', 'Bounds for the Minimum Distance and Covering Radius of Orthogonal Arrays Via Their Distance Distributions', NULL, NULL, '2022 10th International Workshop on Signal Design and Its Applications in Communications (IWSDA)', 'IWSDA', NULL, NULL, '1-5', NULL, 'https://doi.org/10.1109/IWSDA50346.2022.9870612', 'Combinatorial Testing', 'We study the packing and covering properties of orthogonal arrays (OAs) as we propose new approaches for obtaining estimations on the minimum distance and covering radius of orthogonal arrays (designs) via examination of their distance distributions. First, we use some special representation of a linear system of equations which allows us to analyse extreme solutions (distance distributions). Second, we show how databases with (feasible) distance distributions can be used for obtaining sharp bounds for the minimum distance and covering radius of OAs. Correspondingly, new bounds are presented either in analytic form and as products of an ongoing project for computation and investigation of the possible distance distributions of OAs.', NULL);
INSERT INTO `list` VALUES (10045, '0000-00-00', 2022, 'inproceedings', 'Yan Wang, Huayao Wu, Xintao Niu, Changhai Nie, Jiaxi Xu', 'A Constrained Covering Array Generator using Adaptive Penalty based Parallel Tabu Search', NULL, NULL, '2022 IEEE International Conference on Software Testing, Verification and Validation Workshops (ICSTW)', 'ICSTW', NULL, NULL, '82-86', NULL, 'https://doi.org/10.1109/ICSTW55395.2022.00028', 'Combinatorial Testing', 'Since Combinatorial Testing (CT) was first proposed in 1980s, there have been more than 50 algorithms or tools published for Covering Array Generation (CAG). This paper introduces the APPTS tool, which uses an Adaptive Penalty based Parallel Tabu Search (APPTS) algorithm to generate as small-sized Constrained Covering Arrays (CCA) as possible. Instead of simply reusing constraint solvers or forbidden tuple-based techniques to handle constraints, APPTS incorporates a penalty term into the fitness function to handle the constrained search space, and employs an adaptive penalty mechanism to dynamically adjust the penalty weight in different search phases. Our experiments on benchmarks of CT-competition demonstrate the effectiveness of the APPTS tool in covering array sizes. The APPTS tool executable is available at https://github.com/GIST-NJU/apptstool.', NULL);
INSERT INTO `list` VALUES (10046, '0000-00-00', 2022, 'inproceedings', 'Manuel Leithner, Dimitris E. Simos', 'CA2: Practical Archival and Compression of Covering Arrays', NULL, NULL, '2022 IEEE International Conference on Software Testing, Verification and Validation Workshops (ICSTW)', 'ICSTW', NULL, NULL, '63-67', NULL, 'https://doi.org/10.1109/ICSTW55395.2022.00024', 'Combinatorial Testing', 'Covering arrays (CAs) are combinatorial structures that play a significant role in software testing. While a sizable body of research has been dedicated to the generation of CAs, virtually no attention has been directed to their efficient storage, archival, and retrieval. Considering the potential economic advantages offered by the use of these structures, this is surprising: While the algorithmic complexity of most known methods used in their construction tends to be high, leading to expensive computations, the cost of storage has decreased in recent years. It thus seems prudent to identify and tackle the practical issues of large-scale and long-term archival and compression of such objects. This paper introduces CA 2 , the Compressed Covering Array Archive format, which offers competitive compression combined with CA-specific metadata that allows for targeted retrieval based on input specifications given in one of a variety of popular formats. An open source prototype implementation is provided as a utility for practitioners and building block for future research.', NULL);
INSERT INTO `list` VALUES (10047, '0000-00-00', 2022, 'article', 'Zhao Li, Yuhang Chen, Yi Song, Kangjie Lu, Jinwei Shen', 'Effective Covering Array Generation Using an Improved Particle Swarm Optimization', NULL, NULL, '2022 IEEE Transactions on Reliability', 'Trans. Rel.', '71', '1', '284-294', NULL, 'https://doi.org/10.1109/TR.2021.3132147', 'Combinatorial Testing', 'In the test case generation process of combinatorial testing, particle swarm optimization (PSO) is widely concerned for its simple implementation and fast convergence rate; however, it often falls into local optimum due to premature convergence. To attack this problem, a novel adaptive value measurement strategy is adopted by weighing the relationship between current test cases and historical test cases. The test case with the minimum average hamming distance is selected as the optimal test case, and the inertial weight linear differential decrease strategy is developed to ensure better inertial weight in different search stages, further to improve the capability of generating smaller covering arrays. In addition, we integrate the simulated annealing strategy into the improved PSO to improve the ability of particles jumping out of the local optimum, and an innovative approach for generating a better covering array is proposed. Experiments on 16 classical random strength covering arrays suggest that our approach outperforms six other techniques in terms of effectiveness.', NULL);
INSERT INTO `list` VALUES (10048, '0000-00-00', 2022, 'article', 'Yan Wang, Huayao Wu, Xintao Niu, Changhai Nie, Jiaxi Xu', 'An Adaptive Penalty based Parallel Tabu Search for Constrained Covering Array Generation', NULL, NULL, '2022 Information and Software Technology', 'IST', '143', NULL, '106768', NULL, 'https://doi.org/10.1016/j.infsof.2021.106768', 'Combinatorial Testing', 'Context:\r\nThe generation of the optimal constrained covering arrays is a key challenge in the research field of combinatorial testing, where a variety of Constrained Covering Array Generation (CCAG) algorithms have been developed. However, existing algorithms typically reuse constraint solver or forbidden tuple-based techniques to handle constraints, which might restrict their potentials on finding smaller arrays.\r\n\r\nObjective:\r\nThis work dedicates to exploring more effective constraint handling techniques for CCAG, so that the sizes of constrained covering arrays can be further minimized.\r\n\r\nMethods:\r\nWe propose a novel Adaptive Penalty based Parallel Tabu Search (APPTS) algorithm to address the CCAG problem. APPTS incorporates a penalty term into the fitness function to handle the constrained search space, and employs an adaptive penalty mechanism to dynamically adjust the penalty weight in different search phases. Moreover, APPTS adopts Java Parallel Stream to compute the fitness values of candidate solutions to speed up the generation process.\r\n\r\nResults:\r\nThe performance of APPTS is evaluated against three alternative tabu search-based algorithms (with different penalty and parallelization mechanisms), and seven state-of-the-art algorithms for CCAG. The results demonstrate the superiority of APPTS over these existing algorithms. In particular, APPTS finds 22 new upper bounds on the sizes of 2-way and 3-way constrained covering arrays.\r\n\r\nConclusion:\r\nThe adaptive penalty mechanism provides an effective choice for handling constraints in CCAG, and the parallelization can help APPTS reduce the generation cost.', NULL);
INSERT INTO `list` VALUES (10049, '0000-00-00', 2022, 'article', 'Soumen Maity, Charles J. Colbourn', 'Mixed covering arrays on graphs of small treewidth', NULL, NULL, '2022 Soumen Maity, Charles J. Colbourn\r\n\r\nComputing and Augmented Intelligence, School of (IAFSE-SCAI)', 'IAFSE-SCAI', NULL, NULL, 'In press', NULL, 'https://doi.org/10.1142/S1793830921500853', 'Combinatorial Testing', 'Covering arrays are combinatorial objects that have been successfully applied in design of test suites for testing systems such as software, hardware, and networks where failures can be caused by the interaction between their parameters. Let n and k be positive integers with k ≥ 3. Two vectors x ∈ Zng1 and y ∈ Zng2 are qualitatively independent if for any ordered pair (a,b) ∈ Zg1 × Zg2, there exists an index j ∈ {0, 1,.,n-1} such that (x(j),y(j)) = (a,b). Let G be a graph with k vertices v1,v2,.,vk with respective vertex weights g1,g2,.,gk. A mixed covering array onG, denoted by CA(n,G, Πki=1kg i), is a k × n array such that row i corresponds to vertex vi, entries in row i are from Zgi; and if {vx,vy} is an edge in G, then the rows x,y are qualitatively independent. The parameter n is the size of the array. Given a weighted graph G, a mixed covering array on G with minimum size is optimal. In this paper, we introduce some basic graph operations to provide constructions for optimal mixed covering arrays on the family of graphs with treewidth at most three.', NULL);
INSERT INTO `list` VALUES (10050, '0000-00-00', 2022, 'article', 'Jose Torres-Jimenez, Daniel Osvaldo Ramirez-Acuna, Brenda Acevedo-Juárez, Himer Avila-George', 'New upper bounds for sequence Covering Arrays using a 3-stage approach', NULL, NULL, '2022 Expert Systems with Applications', 'Expert Syst. Appl.', '207', NULL, '118022', NULL, 'https://doi.org/10.1016/j.eswa.2022.118022', 'Combinatorial Testing', 'Nowadays, it is mandatory to test the functionality of any software component. In this sense, Covering Arrays (CAs) have been used as test-suites to exercise combinations of parameters’ values. However, in some software components, the functionality depends not only on the combination of parameters’ values but also on how the parameters’ values are fed to a software component. Therefore, the need to use sequence coverage arrays (SCAs) to test the order in which the input parameters are defined in a software component naturally arises. The combined use of CAs and SCAs allows the creation of test-suites that exercise the functionality of software components, taking into account the combination of parameters’ values and the order in which these combinations are used. In this paper, three applications of SCAs will be presented. The first application is related to testing the functionality of a water filtering process and only one SCA is required. The second application combines an SCA with a CA to test a user interface of a software component. The third application refers to the construction of wetlands for water bioremediation using a mixed covering array (MCA) and a sequence covering array. The coverage of an SCA is determined by its strength (i.e., the size of the subsequences of variables covered at least once). We present a 3-stage approach to construct SCAs for strengths t∈{3,4,5,6,7,8}. The stages of our approach are a greedy stage that builds an initial SCA one row at-a-time; a post-optimization stage that involves an algorithm for the detection of redundant elements and an algorithm that aims to reduce the cardinality of an SCA, and a metaheuristic stage that is implemented using a simulated annealing algorithm. Relevant computational results are 502 new upper bounds (178 cases for t=3, 177 cases for t=4, 88 cases for t=5, 43 cases for t=6, 12 cases for t=7, and 4 cases for t=8). Also we have compared the performance of our approach with 12 algorithms using a known benchmark consisting of 101 cases, our approach wins in 69 cases (18 cases for t=3, 24 cases for t=4, 24 cases for t=5, and 3 cases for t=6)', NULL);
INSERT INTO `list` VALUES (10051, '0000-00-00', 2022, 'article', 'André Guerino Castoldi, Emerson Luiz do Monte Carmelo, Lucia Moura, Daniel Panario, Brett Stevens', 'Bounds on Covering Codes in RT spaces using Ordered Covering Arrays', NULL, NULL, '2022 ArXiv', 'ArXiv', '11545', NULL, '100–111', NULL, 'https://doi.org/10.48550/arXiv.2208.01412', 'Combinatorial Testing', 'In this work, constructions of ordered covering arrays are discussed and applied to obtain new upper bounds on covering codes in Rosenbloom-Tsfasman spaces (RT spaces), improving or extending some previous results.', NULL);
INSERT INTO `list` VALUES (10052, '0000-00-00', 2022, 'article', 'André Guerino Castoldi, Emerson L. Monte Carmelo, Lucia Moura, Daniel Panario, Brett Stevens', 'Ordered Covering Arrays and Upper Bounds on Covering Codes in NRT spaces', NULL, NULL, '2022 ArXiv', 'ArXiv', 'abs/2208.01410', NULL, 'not found', NULL, 'https://doi.org/10.48550/arXiv.2208.01410', 'Combinatorial Testing', 'This work shows several direct and recursive constructions of ordered covering arrays using projection, fusion, column augmentation, derivation, concatenation and cartesian product. Upper bounds on covering codes in NRT spaces are also obtained by improving a general upper bound. We explore the connection between ordered covering arrays and covering codes in NRT spaces, which generalize similar results for the Hamming metric. Combining the new upper bounds for covering codes in NRT spaces and ordered covering arrays, we improve upper bounds on covering codes in NRT spaces for larger alphabets. We give tables comparing the new upper bounds for covering codes to existing ones.', NULL);
INSERT INTO `list` VALUES (10613, '0000', 2012, 'article', '郑, 鹏飞 and 齐, 勇 and 陈, 鹏飞', '软件老化的多元时间序列分析方法', 'Measurement-based', NULL, '2012 计算机科学与探索', '计算机科学与探索', '6', '02', '125--133', NULL, 'https://chn.oversea.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFD&dbname=CJFD2012&filename=KXTS201202006&uniplatform=OVERSEA&v=5esuwSu7cGi52AiVULOPkKQqohs2405-RbVr3r5kQ8Jsbx4wzmCfxMcywK1IQ9Bf', 'Software Aging and Rejuvenation', '针对目前软件老化分析中的单参数模型,以及未考虑变量间关联性和影响性的多参数模型的不足,提出了运用多元时间序列模型分析软件老化的方法。通过对实验采集的HelixServer-VOD服务器性能数据的分析,运用格兰杰因果性检验,证实了软件老化发生和发展过程中各个性能参数间存在显著的相互影响性。引入向量自回归模型对软件老化进行建模,给出了软件老化在多个参数维度的联合预测以及参数间相互影响方式的定量描述。通过模型的迭代计算,比较了向量自回归模型与现行的未考虑参数间相互影响的模型对多个性能参数变化曲线的拟合及预测情况,证实了VAR模型更接近软件老化的本质。', NULL);
INSERT INTO `list` VALUES (10614, '0000', 2013, 'phdthesis', '靳, 瑜亮', '软件老化的加速寿命测试研究', 'testing', NULL, '2013 phd 软件老化的加速寿命测试研究', 'Phd', NULL, NULL, NULL, NULL, 'https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CMFD&dbname=CMFD201401&filename=1014132671.nh&uniplatform=NZKPT&v=IHcCMba4qibrcXf4k15hPl904E0igDNdO-EEIkwLCXLpBwLbaR9oJjOYbeKK056u', 'Software Aging and Rejuvenation', '“软件老化(Software Aging)”现象是指软件长时间运行时，由于计算机资源的消耗而造成的软件性能逐渐下降的现象。这种现象通常出现在服务器等需要7x24小时不间断运行的软件上，可能造成服务器软件服务能力的下降甚至服务器失效宕机。针对这种现象，学者提出了一种称作“软件再生(Software Rejuvenation)”的方法，也就是通过定期地重新启动服务器，重新初始化服务器的内部状态，释放可能造成老化的系统资源，从而避免或减少性能下降甚至被动宕机造成的损失。  内存泄漏是造成软件老化的一个重要原因，因此本文搭建了一个引入内存泄漏的软件老化测试平台，服务器端使用符合TPC-W基准测试标...', NULL);
INSERT INTO `list` VALUES (10615, '0000', 2018, 'phdthesis', '霍, 守玉', '安卓系统软件老化预测方法研究', 'Measurement-based（ML）', NULL, '2018 phd 安卓系统软件老化预测方法研究', 'Phd', NULL, NULL, NULL, NULL, 'https://chn.oversea.cnki.net/KCMS/detail/detail.aspx?dbcode=CMFD&dbname=CMFD201902&filename=1019832834.nh&uniplatform=OVERSEAS_CHS&v=dHojarLpEG9OdA6ZfwIUbOsIDdQGOqwnF4cJPU5g2deKL5hMlZYtSLiklKnY-VF-', 'Software Aging and Rejuvenation', '软件老化是指在系统持久和连续地运行过程中,由于老化相关的错误的累积而导致的资源持续消耗、系统性能持续下降或系统错误数持续增加,并最终导致系统崩溃的现象。安卓移动终端已深入到人们生活的各个方面,而安卓系统在长时间运行中容易产生启动时间增长和系统崩溃等问题,引发这些问题的一个重要原因是安卓系统软件老化,但安卓系统软件老化预测研究较少。研究安卓系统软件老化有助于提升系统的稳定性和用户体验,因此,本文基于页面错误数（Page Fault,PF）和启动时间（Launch Time,LT）老化指标,对比分析基于不同机器学习算法的安卓系统软件老化预测模型的性能,具体工作如下:1)在安卓系统老化数据预处理和特征提取阶段,本文更加全面地考虑了网络、虚拟内存和负载等方面的系统性能指标,并进行数据采集;本文基于K-means算法剔除应用启动等情况下由于系统性能指标突变而产生的离异点;除了常用的LT老化指标,本文还引入了PF指标作为安卓系统软件老化指标,并分别提取了与老化指标具有相关性的系统性能指标作为特征数据。2)在老化模型训练和预测阶段,首先,本文基于LT老化指标进行数据标注,采用决策树、支持向量机和深度信念网络算法构建安卓系统软件老化预测模型。实验结果表明,基于决策树算法和基于支持向量机算法的模型的预测性能较好,当标注的健康状态、亚健康状态和老化状态的数据均达到5000量级时,基于深度信念网络算法的模型也具有较好的预测性能。其次,本文基于PF老化指标进行数据标注,采用三种机器学习算法构建安卓系统软件老化预测模型。实验结果表明,基于PF老化指标标注的模型与基于LT老化指标标注的模型具有相当的安卓系统软件老化预测性能,这表明PF可作为安卓系统软件老化预测的备选指标之一。此外,本文基于LT和PF相结合的数据标注方式,采用三种机器学习算法构建安卓系统软件老化预测模型。实验结果表明,当分别选取标定老化状态较早的点标注数据时,基于支持向量机算法和基于深度信念网络算法的模型的方差比基于单个老化指标标注的模型的方差分别降低了33\\%和64\\%左右,即模型的稳定性得到一定提升,而基于决策树算法的模型的稳定性保持不变。本文开展的安卓系统软件老化预测方法的研究,在离异点处理、机器学习算法选取和老化指标选取等方面为安卓系统老化研究提供了新的思路和参考。', NULL);
INSERT INTO `list` VALUES (10616, '0000', 2019, 'phdthesis', '翁, 才生', '安卓软件老化与恢复的研究', 'Model-based&度量', NULL, '2019 phd 安卓软件老化与恢复的研究', 'Phd', NULL, NULL, NULL, NULL, '10.27381/d.cnki.gwlgu.2019.001357', 'Software Aging and Rejuvenation', '软件老化（Software Aging）指系统在长时间运行过程中,由于错误的积累导致系统性能逐步下降并最终可能导致系统崩溃的现象。软件恢复（Software Rejuvenation）是指一个需要成本但有效的用来抵抗软件老化所带来的影响的方法。类似于传统的硬件老化,软件老化也具有随机性的特点,但其出现频率更高、检测和分析更复杂、危害也更大,是近年来软件可靠性工程领域的新兴研究热点之一。安卓手机在市场上的份额占据大部分比例。一个常见的现象是随着安卓手机使用时间的增长,手机UI响应时间逐渐变长,性能逐渐下降,服务体验相对变差。这种现象可能是受到安卓软件老化的影响。研究安卓软件老化问题,有助于改善安卓性能,提高系统的可靠性并提升用户体验。本文首先通过构建实验方案并收集内存相关数据进行建模分析,验证安卓软件老化的存在性及其特点,以及传统温恢复策略对安卓软件恢复的作用;然后应用了随机森林方法来对老化状态进行识别;最后结合移动智能终端用户使用行为模式构建软件恢复模型,并提出综合考虑用户使用行为模式和反应用户体验的可信赖（Dependability）相关度量指标。主要工作具体如下:1)通过压力测试实验及建模分析,验证了安卓软件老化的存在性,并发现老化一般是不可逆的,而且温恢复（应用重启）对安卓软件恢复作用有限。已有大量研究表明内存泄漏是导致软件老化的一个主要原因,同时由于安卓内存管理机制的复杂性,因此本文通过黑盒测试的方法,构建压力实验观察安卓可用内存数据的变化情况,逐步验证安卓软件老化的一些相关假设,然后利用离散时间马尔科夫模型对所收集到的数据进行建模分析。2)通过使用随机森林算法来识别安卓软件老化过程中的各种状态,从而为安卓软件恢复提供了更好的指导意见。由于不同的负载可能会产生不同的软件老化现象,这可能会影响到对系统状态的判断。为准确识别安卓老化过程中的状态,本文首先通过模拟用户使用行为在安卓手机上进行压力实验,并收集相关数据,然后使用随机森林算法来对系统状态进行识别,实验表明该方法具有一个较低的识别错误率,最后在此基础上制定了一个相应的恢复策略,为将来制定更好的软件恢复策略提供意见。3)结合手机用户使用行为模式特点构建软件恢复模型,并提出两个定量分析度量指标:流畅可用度、用户体验度。移动智能终端包括安卓手机的用户使用行为具有碎片化和周期性等特点。因此,本文首先分别对用户使用行为模式和老化过程建模,然后利用随机Petri网将它们组合,并转化成连续时间马尔科夫链模型;在此基础之上,通过综合考虑使用行为模式和老化过程来制定恢复策略,以获得最佳的用户体验和最少的用户干扰,例如在使用模式为睡眠状态和系统进入老化状态（UI响应变慢）之前进行自动重启;同时针对传统可信赖性指标不包括反映用户体验的定量分析度量指标,在构建的恢复模型的基础之上,提出两个定量分析度量指标:流畅可用度（用户能流畅使用手机的概率）和用户体验度（用户对系统使用的整体体验感受值）;最后,通过数值实验分析验证了本文所提出的模型及度量指标的有效性。', NULL);
INSERT INTO `list` VALUES (10617, '0000', 2021, 'phdthesis', '丁, 立诚', '基于软件老化的软件可信性度量模型设计与工具实现', '度量', NULL, '2021 phd 基于软件老化的软件可信性度量模型设计与工具实现', 'Phd', NULL, NULL, NULL, NULL, '10.27149/d.cnki.ghdsu.2021.000026', 'Software Aging and Rejuvenation', '伴随软件的高速发展,各种软件事故层出不穷,这些事故导致的灾难性后果让人们意识到软件可信性的重要性,对可信性进行度量作为质量保证的重要手段不可或缺。传统可信性度量大多通过研究影响软件可信性的属性来量化评估软件整体的可信性,而可信属性相关度量考虑的因素大多偏向静态,往往会忽略软件在运行一段时间后产生的变化,无法反映出不同运行时刻软件可信度的变化情况。本文着重关注软件老化对软件可信性的影响,研究运行时间与软件可信度之间的关系,从提取失信证据的角度出发,设计一种与运行时间相关的软件可信度量模型,让软件可信度随运行时间发生变化。本文主要在以下三个方面进行了研究:首先,本文通过研究软件老化相关bug提取失信证据,然后为失信证据划分风险等级和对应的风险值,并以此为基础设计基于软件老化的失信证据度量元模型,通过对度量元分类并结合熵的概念,研究不同类型度量元对软件可信性的量化影响。其次,本文设计一种针对软件老化的软件可信性度量方法,研究导致软件老化的不同原因对软件可信性的影响,以“度量元-软件老化原因类别-软件”分层设计了基于软件老化的软件可信性度量模型,采用Brassard优先次序全面分析法确定各类别度量元的权重。最后,本文开发了基于软件老化的软件可信度量评估工具。该工具功能分为基本信息管理和可信度量评估两部分,实现了项目管理、失信证据处理、可信度计算、权重计算等功能,可以有效反映软件可信度随运行时间的变化情况。该工具将理论与实践结合,完成了基于软件老化的软件可信性度量模型及工具实现的全过程,丰富了软件可信性的基础研究理论体系。本文创新性地从失信角度构造度量元模型,量化分析可信性在软件老化的影响下随运行时间的变化情况,构建了一套完整的可信度量体系,包括可信性量化分析、度量模型构建和评估工具实现。在理论创新的同时,具有很强的实际应用价值,有助于提高需要长时间运行软件的可信性。', NULL);
INSERT INTO `list` VALUES (10618, '0000', 2021, 'article', '陈, 晓璠 and 邓, 砚谷', '基于动态命令树算法的软件老化趋势预测方法', 'Measurement-based', NULL, '2021 计算机仿真', '计算机仿真', '38', '11', '295--299+313', NULL, 'https://chn.oversea.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFD&dbname=CJFDLAST2021&filename=JSJZ202111060&uniplatform=OVERSEAS_CHS&v=hcKC0M6OGdIJ65e4s7OF_OZxRx38cnekDPPJaJ2umXD-N2CMlG39FOHUKl1xKoTs', 'Software Aging and Rejuvenation', '考虑到软件老化具有动态性,准确预测软件老化趋势,可降低软件老化所造成的损失,提出基于动态命令树算法的软件老化趋势预测方法。采用基于降噪自编码器与混合趋势粒子滤波的软件老化趋势预测方法,通过软件未老化特征训练降噪自编码器,把软件老化特征数据输入训练完毕的降噪自编码器中获取重构误差,对重构误差进行平滑处理后,设成观测值输入混合趋势粒子滤波算法,实施软件老化趋势预测。在预测阶段,使用基于动态命令树算法的软件老化趋势预测命令管理方法,实现软件老化趋势预测指令的动态管理,优化软件老化趋势的动态预测效果。实验结果表明,所提方法可提升软件老化趋势预测的精度,预测效果显著。', NULL);
INSERT INTO `list` VALUES (10619, '0000', 2020, 'article', '谭, 宇宁 and 党, 伟超 and 潘, 理虎 and 白, 尚旺', '基于SATLSTM的Web系统老化趋势预测', 'Measurement-based（ML）', NULL, '2020 计算机应用与软件', '计算机仿真', '37', '04', '17--24', NULL, 'https://chn.oversea.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFD&dbname=CJFDLAST2020&filename=JYRJ202004005&uniplatform=OVERSEAS_CHS&v=EO30oldB0qGIQ-MUvkDcsrm1C2NbhBBmbFWLbVxBKOjPigdN63snLQQV47Uu0nNZ', 'Software Aging and Rejuvenation', '为解决传统软件老化趋势预测模型泛化能力弱、预测准确度低的问题,根据老化数据的时序特性,提出一种基于自注意力机制的长短时记忆单元（Self-Attention-Long Short Term Memory,SATLST）循环神经网络老化趋势预测模型。将LSTM循环神经网络与自注意力机制融合,在深入挖掘老化数据潜在规律的同时,通过对不同输入数据分配不同权重的方式,加大对局部老化信息的关注度。应用加速寿命测试实验搭建软件老化测试平台,对Web服务器因内存泄漏引起的老化现象进行建模和预测。实验结果表明:相较于传统的ARIMA和BP神经网络模型,该模型训练结果与实际值接近,预测精度高,能准确预测Web系统软件老化趋势。', NULL);
INSERT INTO `list` VALUES (10620, '0000', 2010, 'inproceedings', 'Alonso, Javier and Torres, Jordi and Berral, Josep Ll. and Gavalda, Ricard', 'Adaptive on-line software aging prediction based on machine learning', '度量&Measurement-based（ML）', NULL, '2010 IEEE/IFIP International Conference on Dependable Systems Networks (DSN)', 'DSN', NULL, NULL, '507--516', NULL, '10.1109/DSN.2010.5544275', 'Software Aging and Rejuvenation', 'The growing complexity of software systems is resulting in an increasing number of software faults. According to the literature, software faults are becoming one of the main sources of unplanned system outages, and have an important impact on company benefits and image. For this reason, a lot of techniques (such as clustering, fail-over techniques, or server redundancy) have been proposed to avoid software failures, and yet they still happen. Many software failures are those due to the software aging phenomena. In this work, we present a detailed evaluation of our chosen machine learning prediction algorithm (M5P) in front of dynamic and non-deterministic software aging. We have tested our prediction model on a three-tier web J2EE application achieving acceptable prediction accuracy against complex scenarios with small training data sets. Furthermore, we have found an interesting approach to help to determine the root cause failure: The model generated by machine learning algorithms.', NULL);
INSERT INTO `list` VALUES (10621, '0000', 2011, 'inproceedings', 'Alonso, Javier and Matias, Rivalino and Vicente, Elder and Carvalho, Ana M. and Trivedi, Kishor', 'A Comparative Evaluation of Software Rejuvenation Strategies', 'rej', NULL, '2011 IEEE Third International Workshop on Software Aging and Rejuvenation', 'IW-SAR', NULL, NULL, '26--31', NULL, '10.1109/WoSAR.2011.16', 'Software Aging and Rejuvenation', 'In this paper we present an experimental comparative study of most of the rejuvenation techniques developed so far, divided into two groups: i) simple approaches: physical node reboot (switch off/on), VM reboot, OS reboot and standalone application restart, and ii) sophisticated methods: OS fast reboot, and application restart with hot standby mode. In our experiments we evaluate the availability and performance overheads incurred by software rejuvenation. We also analyze the selected rejuvenation techniques efficiency to mitigate the aging effects. We inject memory leaks at application level to simulate the aging effects. The results show that the availability and performance overheads introduced by the rejuvenation strategies are specific to the granularity level.', NULL);
INSERT INTO `list` VALUES (10622, '0000', 2013, 'article', 'Alonso, J. and Matias, R. and Vicente, E. and Maria, A. and Trivedi, K.S.', 'A comparative experimental study of software rejuvenation overhead', 'rej', NULL, '2013 Performance Evaluation', 'Perform. Eval', '70', '3', '231--250', NULL, '10.1016/j.peva.2012.09.002', 'Software Aging and Rejuvenation', 'In this paper we present a comparative experimental study of the main software rejuvenation techniques developed so far to mitigate the software aging effects. We consider six different rejuvenation techniques with different levels of granularity: (i) physical node reboot, (ii) virtual machine reboot, (iii) OS reboot, (iv) fast OS reboot, (v) standalone application restart, and (vi) application rejuvenation by a hot standby server. We conduct a set of experiments injecting memory leaks at the application level. We evaluate the performance overhead introduced by software rejuvenation in terms of throughput loss, failed requests, slow requests, and memory fragmentation overhead. We also analyze the selected rejuvenation techniques’ efficiency in mitigating the aging effects. Due to the growing adoption of virtualization technology, we also analyze the overhead of the rejuvenation techniques in virtualized environments. The results show that the performance overheads introduced by the rejuvenation techniques are related to the granularity level. We also capture different levels of memory fragmentation overhead induced by the virtualization demonstrating some drawbacks of using virtualization in comparison with non-virtualized rejuvenation approaches. Finally, based on these research findings we present comprehensive guidelines to support decision making during the design of rejuvenation scheduling algorithms, as well as in selecting the appropriate rejuvenation mechanism.', NULL);
INSERT INTO `list` VALUES (10623, '0000', 2010, 'inproceedings', 'Alonso, Javier and Torres, Jordi and Berral, Josep Ll. and Gavaldà, Ricard', 'J2EE instrumentation for software aging root cause application component determination with AspectJ', '度量', NULL, '2010 IEEE International Symposium on Parallel Distributed Processing, Workshops and Phd Forum (IPDPSW)', 'IPDPSW', NULL, NULL, '1--8', NULL, '10.1109/IPDPSW.2010.5470857', 'Software Aging and Rejuvenation', 'Unplanned system outages have a negative impact on company revenues and image. While the last decades have seen a lot of efforts from industry and academia to avoid them, they still happen and their impact is increasing. According to many studies, one of the most important causes of these outages is software aging. Software aging phenomena refers to the accumulation of errors, usually provoking resource contention, during long running application executions, like web applications, which normally cause applications/systems hang or crash. Determining the software aging root cause failure, not the resource or resources involved in, is a huge task due to the growing day by day complexity of the systems. In this paper we present a monitoring framework based on Aspect Programming to monitor the resources used by every application component in runtime. Knowing the resources used by every component of the application we can determine which components are related to the software aging. Furthermore, we present a case study where we evaluate our approach to determine in a web application scenario, which components are involved in the software aging with promising results.', NULL);
INSERT INTO `list` VALUES (10624, '0000', 2009, 'article', 'Alonso, Javier and Torres, Jordi and Gavaldà, Ricard', 'Predicting Web Server Crashes: A Case Study in Comparing Prediction Algorithms', '度量&Measurement-based（ML）', NULL, '2009 Fifth International Conference on Autonomic and Autonomous Systems', 'ICAS', NULL, NULL, '264--269', NULL, '10.1109/ICAS.2009.56', 'Software Aging and Rejuvenation', 'Traditionally, performance has been the most important metrics when evaluating a system. However, in the last decades industry and academia have been paying increasing attention to another metric to evaluate servers: availability. A web server may serve many users when running, but if it is out of service too much time, it becomes useless and expensive. The industry has adopted several techniques to improve system availability, yet crashes still happen. In this paper, we propose a new framework to predict time-to-failure when the system is suffering transient failures that consume resources randomly. We study which machine learning algorithms build a more accurate model of the behavior of the anomaly system, and focus on Linear Regression and Decision Tree algorithms. Our preliminary results show that M5P (a Decision Tree algorithm) is the best option to model the behavior of the system under the random injection of memory leaks.', NULL);
INSERT INTO `list` VALUES (10625, '0000', 2009, 'inproceedings', 'Alonso, Javier and Torres, Jordi and Gavaldà, Ricard', 'Predicting Web Server Crashes: A Case Study in Comparing Prediction Algorithms', '度量&Measurement-based（ML）', NULL, '2009 Fifth International Conference on Autonomic and Autonomous Systems', 'ICAS', NULL, NULL, '264--269', NULL, '10.1109/ICAS.2009.56', 'Software Aging and Rejuvenation', 'Traditionally, performance has been the most important metrics when evaluating a system. However, in the last decades industry and academia have been paying increasing attention to another metric to evaluate servers: availability. A web server may serve many users when running, but if it is out of service too much time, it becomes useless and expensive. The industry has adopted several techniques to improve system availability, yet crashes still happen. In this paper, we propose a new framework to predict time-to-failure when the system is suffering transient failures that consume resources randomly. We study which machine learning algorithms build a more accurate model of the behavior of the anomaly system, and focus on Linear Regression and Decision Tree algorithms. Our preliminary results show that M5P (a Decision Tree algorithm) is the best option to model the behavior of the system under the random injection of memory leaks.', NULL);
INSERT INTO `list` VALUES (10626, '0000', 2019, 'inproceedings', 'Andrade, Ermeson and Machida, Fumio', 'Analysis of Software Aging Impacts on Plant Anomaly Detection with Edge Computing', 'Model-based', NULL, '2019 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)', 'ISSREW', NULL, NULL, '204--210', NULL, '10.1109/ISSREW.2019.00073', 'Software Aging and Rejuvenation', 'Edge computing allows data-intensive analytic processes running on a cloud server to migrate to a local computing environment near the data sources, and as a result the architecture can benefit from a significant bandwidth reduction as well as improved security. However, due to the scarcity of resources on an edge device, a problem of software aging is likely to occur after longtime execution. The consequence of software aging should be significant, whereas such a risk has not been studied in the previous literature. In this paper, we propose a deterministic and stochastic Petri Net (DSPN) to quantitatively analyze the impacts of software aging phenomenon on a cyber-physical system using edge computing. As a data analytic application using real-world sensor data, we consider anomaly detection for a water treatment plant. We introduce two application-oriented performance measures, namely detection loss probability and the expected number of false alarms in terms of plant anomaly detection. Our numerical and simulation experiments on the proposed DSPN show that software aging clearly has negative impacts on the defined performance measures that reveal the necessity of greater attention to software aging issues in edge computing systems.', NULL);
INSERT INTO `list` VALUES (10627, '0000', 2011, 'inproceedings', 'Andrade, Ermeson C. and Machida, Fumio and Kim, Dong-Seong and Trivedi, Kishor S.', 'Modeling and Analyzing Server System with Rejuvenation through SysML and Stochastic Reward Nets', 'Model-based', NULL, '2011 Sixth International Conference on Availability, Reliability and Security', 'ARES', NULL, NULL, '161--168', NULL, '10.1109/ARES.2011.28', 'Software Aging and Rejuvenation', 'High-availability assurance of server systems is becoming an important issue, since many mission-critical applications are implemented on server systems. To achieve high-availability, software rejuvenation is a practical technique to reduce unexpected downtime caused by software aging in software applications running on server systems. Although analytic models of software rejuvenation are well-studied, such analysis is not used in server system administration due to the complexity of modeling. In this paper, we present an availability modeling method for server system with software rejuvenation based on SysML that is used to describe system configurations and maintenance operations semi-formally. The proposed approach allows system administrators, who do not have expertise in availability modeling, to design and study the effects of different rejuvenation policies deployed in server systems. To show the applicability of the proposed modeling and evaluation process, a case study of a web application server is presented. We show the correctness of our modeling method by comparing the conventional models for condition-based and time-based software rejuvenation.', NULL);
INSERT INTO `list` VALUES (10628, '0000', 2020, 'inproceedings', 'Andrade, Ermeson and Machida, Fumio and Pietrantuono, Roberto and Cotroneo, Domenico', 'Software Aging in Image Classification Systems on Cloud and Edge', '现象分析&度量', NULL, '2020 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)', 'ISSREW', NULL, NULL, '342--348', NULL, '10.1109/ISSREW51248.2020.00099', 'Software Aging and Rejuvenation', 'Image classification systems using machine learning are rapidly adopted in many software application systems. Machine learning models built for image classification tasks are usually deployed on either cloud computing or edge computers close to data sources depending on the performance and resource requirements. However, software reliability aspects during the operation of these systems have not been properly explored. In this paper, we experimentally investigate the software aging phenomena in image classification systems that are continuously running on cloud or edge computing environments. By performing statistical analysis on the measurement data, we detected a suspicious phenomenon of software aging induced by image classification workloads in the memory usages for cloud and edge computing systems. Contrary to the expectation, our experimental results show that the edge system is less impacted by software aging than the cloud system that has four times larger allocated memory resources. We also disclose our software aging data set on our project web site for further exploration of software aging and rejuvenation research.', NULL);
INSERT INTO `list` VALUES (10629, '0000', 2007, 'inproceedings', 'Andrzejak, Artur and Silva, Luis', 'Deterministic Models of Software Aging and Optimal Rejuvenation Schedules', 'Measurement-based', NULL, '2007 10th IFIP/IEEE International Symposium on Integrated Network Management', 'IM', NULL, NULL, '159--168', NULL, '10.1109/INM.2007.374780', 'Software Aging and Rejuvenation', 'Automated modeling of software aging processes is a prerequisite for cost-effective usage of adaptive software rejuvenation as a self-healing technique. We consider the problem of such automated modeling in server-type applications whose performance degrades depending on the \"work\" done since last rejuvenation, for example the number of served requests. This type of performance degradation - caused mostly by resource depletion - is common, as we illustrate in a study of the popular Axis Soap server 1.3. In particular, we propose deterministic models for approximating the leading indicators of aging and an automated procedure for statistical testing of their correctness. We further demonstrate how to use these models for finding optimal rejuvenation schedules under utility functions. Our focus is on the important case that the utility function is the average of a performance metric (such as maximum service rate). We also consider optional SLA constraints under which the performance should never drop below a specified level. Our approach is verified by a study of the aging processes in the Axis Soap 1.3 server. The experiments show that the deterministic modeling technique is appropriate in this case, and that the optimization of rejuvenation schedules can greatly improve the average maximum service rate of an aging application.', NULL);
INSERT INTO `list` VALUES (10630, '0000', 2008, 'inproceedings', 'Andrzejak, Artur and Silva, Luis', 'Using machine learning for non-intrusive modeling and prediction of software aging', 'Measurement-based（ML）', NULL, '2008 NOMS 2008 - 2008 IEEE Network Operations and Management Symposium', 'NOMS ', NULL, NULL, '25--32', NULL, '10.1109/NOMS.2008.4575113', 'Software Aging and Rejuvenation', 'The wide-spread phenomenon of software (running image) aging is known to cause performance degradation, transient failures or even crashes of applications. In this work we describe first a method for monitoring and modeling of performance degradation in SOA applications, particularly application servers. This method works for a large class of the aging processes caused by resource depletion (e.g. memory leaks). It can be deployed non-intrusively in a production environment, under arbitrary service request distributions. Based on this schema we investigate in the second part of the paper how machine learning (classification) algorithms can be used for proactive detection of performance degradation or sudden drops caused by aging. We leverage the predictive power of these algorithms with several techniques to make the measurement-based aging models more adaptive and more robust against transient failures. We evaluate several state-of-the-art classification methods for their accuracy and computational efficiency in this scenario. The studies are performed on a data set generated by a TPC-W benchmark instrumented with a memory leak injector. The results show that the probing method yields accurate aging models with low overhead and the machine learning approach gives statistically significant short-term predictions of degrading application performance. Both approaches can be used directly to fight aging via adaptive software rejuvenation (restart of the application), for operator alerting, or for short-term capacity planning.', NULL);
INSERT INTO `list` VALUES (10631, '0000', 2011, 'inproceedings', 'Araujo, Jean and Matos, Rubens and Maciel, Paulo and Matias, Rivalino and Beicker, Ibrahim', 'Experimental evaluation of software aging effects on the eucalyptus cloud computing infrastructure', 'Measurement-based', NULL, '2011 Proceedings of the Middleware 2011 Industry Track Workshop on - Middleware \'11', 'MWIT', NULL, NULL, '1--7', 'ACM Press', '10.1145/2090181.2090185', 'Software Aging and Rejuvenation', 'The need for reliability and availability has increased in modern applications, which need to handle rapidly growing demands while providing uninterrupted service. This work investigates the memory leak and memory fragmentation aging eﬀects on the Eucalyptus cloud-computing framework, which considers workloads composed of intensive requests addressing diﬀerent virtual machines. We experimentally show the existence of the investigated aging eﬀects in the cloud environment under study. Also, a software rejuvenation strategy to mitigate the observed aging eﬀects is proposed and its beneﬁts are evaluated.', NULL);
INSERT INTO `list` VALUES (10632, '0000', 2013, 'inproceedings', 'Araujo, Jean and Alves, Vandi and Oliveira, Danilo and Dias, Pedro and Silva, Bruno and Maciel, Paulo', 'An Investigative Approach to Software Aging in Android Applications', '度量', NULL, '2013 IEEE International Conference on Systems, Man, and Cybernetics', 'SMC', NULL, NULL, '1229--1234', NULL, '10.1109/SMC.2013.213', 'Software Aging and Rejuvenation', 'This paper proposes an investigative approach to indicators of software aging in applications developed for Android, a Linux-based operating system primarily designed for touch screen mobile devices such as smartphones and tablets. Software aging is a degrading factor in systems, leading to poor performance, failures, and may ultimately result in system downtime. The methodology proposed identifies memory leaking in Android applications. In order to test the approach, case studies were performed with the Monkey tool as workload generator, employing Linux utilities to monitor the environment. Communication between the computer and the smartphone was handled with the ADB tool, a toolkit included in the Android SDK package. Experimental results confirmed both the effectiveness of the procedure and the existence of software aging phenomenon in the Foursquare application running on the Android OS platform.', NULL);
INSERT INTO `list` VALUES (10633, '0000', 2011, 'inproceedings', 'Araujo, Jean and Matos, Rubens and Maciel, Paulo and Vieira, Francisco and Matias, Rivalino and Trivedi, Kishor S.', 'Software Rejuvenation in Eucalyptus Cloud Computing Infrastructure: A Method Based on Time Series Forecasting and Multiple Thresholds', 'Measurement-based', NULL, '2011 IEEE Third International Workshop on Software Aging and Rejuvenation', 'IW-SAR', NULL, NULL, '38--43', NULL, '10.1109/WoSAR.2011.18', 'Software Aging and Rejuvenation', 'The need for reliability and availability has increased in modern applications, in order to handle rapidly growing demands while providing uninterrupted service. Cloud computing systems fundamentally provide access to large pools of data and computational resources through a variety of interfaces similarly to existing grid and HPC resource management and programming systems. This work proposes an approach that uses time series to schedule rejuvenation, so as to reduce the downtime by predicting the proper moment to perform the rejuvenation.We show the results of our approach through experiments using the Eucalyptus cloud computing framework.', NULL);
INSERT INTO `list` VALUES (10634, '0000', 2011, 'article', 'Araujo, Jean and Matos, Rubens and Maciel, Paulo and Matias, Rivalino', 'Software aging issues on the eucalyptus cloud computing infrastructure', 'Measurement-based', NULL, '2011 IEEE International Conference on Systems, Man, and Cybernetics', 'SMC', NULL, NULL, '1411--1416', NULL, '10.1109/ICSMC.2011.6083867', 'Software Aging and Rejuvenation', 'Demands on software reliability and availability have increased due to the nature of present day applications. Cloud computing systems fundamentally provide access to large pools of data and computational resources through a variety of interfaces similarly to existing grid and HPC resource management and programming systems. This work investigates the software aging effects on the Eucalyptus cloud computing infrastructure considering workloads composed of provisioning different types of virtual machines.', NULL);
INSERT INTO `list` VALUES (10635, '0000', 2014, 'article', 'Araujo, Jean and Matos, Rubens and Alves, Vandi and Maciel, Paulo and Souza, F. Vieira de and Jr., Rivalino Matias and Trivedi, Kishor S.', 'Software aging in the eucalyptus cloud computing infrastructure: Characterization and rejuvenation', 'Measurement-based', NULL, '2014 J. Emerg. Technol. Comput. Syst.', 'J. Emerg. Technol. Comput. Syst.', '10', '1', '1--22', NULL, '10.1145/2539122', 'Software Aging and Rejuvenation', 'The need for high reliability, availability and performance has significantly increased in modern applications, that handle rapidly growing demands while providing uninterruptible services. Cloud computing systems fundamentally provide access to large pools of data and computational resources. Eucalyptus is a software framework largely used to implement private clouds and hybrid-style Infrastructure as a Service. It implements the Amazon Web Service (AWS) API, allowing interoperability with other AWS-based services. This article investigates the software aging effects in the Eucalyptus framework, considering workloads composed of intensive requests for remote storage attachment and virtual machine instantiations. We found problems that may be harmful to system dependability and performance, specifically regarding to RAM memory and swap space exhaustion, besides highly excessive CPU utilization by the virtual machines. We also present an approach that applies time series analysis to schedule rejuvenation, so as to reduce the downtime by predicting the proper moment to perform the rejuvenation. We experimentally evaluate our approach using an Eucalyptus test bed. The results show that our approach achieves higher availability, when compared to a threshold-triggered rejuvenation method based on continuous monitoring of resources utilization.', NULL);
INSERT INTO `list` VALUES (10636, '0000', 2021, 'inproceedings', 'Araujo, Jean and Melo, Carlos and Oliveira, Felipe and Pereira, Paulo and Matos, Rubens', 'A Software Maintenance Methodology: An Approach Applied to Software Aging', 'Model-based', NULL, '2021 IEEE International Systems Conference (SysCon)', 'SysCon', NULL, NULL, '1--8', NULL, '10.1109/SysCon48628.2021.9447082', 'Software Aging and Rejuvenation', 'The increasing use of computational systems has highlighted concerns about attributes that may influence the quality of service, such as performance, availability, reliability, and maintenance capacity. Failures in the software development process may impact these attributes. Flawed code and overall software misdesign may cause internal errors, leading to system malfunction. Some errors might be identified and fixed during the software testing process. However, other errors may manifest only during the production stage. This is the case of the software aging phenomenon, which is related to the progressive degradation that a software performance or reliability suffers during its operational life. This paper proposes a methodology for software maintenance that is tailored to identify, correct, and mitigate the software aging effects. If the source code can be modified and a new version deployed with minimal impact, thus data from aging detection is used for corrective maintenance, i.e., for fixing the bug that causes the aging effects. If the software cannot be fixed nor its version updated without long system interruption or other bad consequences, then our approach can mitigate the aging effects, in a preventive maintenance to avoid service outages. The proposed methodology is validated through both Stochastic Petri Net (SPN) models and experiments in a controlled environment. The model evaluation considering a hybrid maintenance routine (preventive and corrective) yielded an availability of 99.82\\%, representing an annual downtime of 15.9 hours. By contrast, the baseline scenario containing only reactive maintenance (i.e., repairing only after failure) had more than 1342 hours of annual downtime- 80 times higher than the proposed approach.', NULL);
INSERT INTO `list` VALUES (10637, '0000', 2004, 'article', 'Avizienis, A. and Laprie, J.-C. and Randell, B. and Landwehr, C.', 'Basic concepts and taxonomy of dependable and secure computing', '逻辑分析', NULL, '2004 IEEE Trans.Dependable and Secure Comput.', 'IEEE Trans.Dependable and Secure Comput.', '1', '1', '11--33', NULL, '10.1109/TDSC.2004.2', 'Software Aging and Rejuvenation', 'This paper gives the main definitions relating to dependability, a generic concept including as special case such attributes as reliability, availability, safety, integrity, maintainability, etc. Security brings in concerns for confidentiality, in addition to availability and integrity. Basic definitions are given first. They are then commented upon, and supplemented by additional definitions, which address the threats to dependability and security (faults, errors, failures), their attributes, and the means for their achievement (fault prevention, fault tolerance, fault removal, fault forecasting). The aim is to explicate a set of general concepts, of relevance across a wide range of situations and, therefore, helping communication and cooperation among a number of scientific and technical communities, including ones that are concentrating on particular types of system, of system failures, or of causes of system failures.', NULL);
INSERT INTO `list` VALUES (10638, '0000', 2008, 'inproceedings', 'Avritzer, Alberto and Cole, Robert G. and Weyuker, Elaine J.', 'Methods and opportunities for rejuvenation in aging distributed software systems', 'Measurement-based', NULL, '2008 IEEE International Conference on Software Reliability Engineering Workshops (ISSRE Wksp)', 'ISSRE', NULL, NULL, '1--6', NULL, '10.1109/ISSREW.2008.5355518', 'Software Aging and Rejuvenation', 'In this paper we describe several methods for detecting the need for software rejuvenation in mission critical systems that are subjected to worm infection. We introduce a new software rejuvenation algorithm that tracks both the state of the mission and the customer affecting metric, response time. We evaluate the probability of mission success of several different software rejuvenation algorithms using simulation.', NULL);
INSERT INTO `list` VALUES (10639, '0000', 2006, 'inproceedings', 'Avritzer, A. and Bondi, A. and Grottke, M. and Trivedi, K.S. and Weyuker, E.J.', 'Performance Assurance via Software Rejuvenation: Monitoring, Statistics and Algorithms', 'Hybrid', NULL, '2006 International Conference on Dependable Systems and Networks (DSN\'06)', 'DSN', NULL, NULL, '435--444', NULL, '10.1109/DSN.2006.58', 'Software Aging and Rejuvenation', 'We present three algorithms for detecting the need for software rejuvenation by monitoring the changing values of a customer-affecting performance metric, such as response time. Applying these algorithms can improve the values of this customer-affecting metric by triggering rejuvenation before performance degradation becomes severe. The algorithms differ in the way they gather and use sample values to arrive at a rejuvenation decision. Their effectiveness is evaluated for different sets of control parameters, including sample size, using simulation. The results show that applying the algorithms with suitable choices of control parameters can significantly improve system performance as measured by the response time', NULL);
INSERT INTO `list` VALUES (10640, '0000', 2020, 'article', 'Bai, Jing and Chang, Xiaolin and Machida, Fumio and Trivedi, Kishor S. and Han, Zhen', 'Analyzing Software Rejuvenation Techniques in a Virtualized System: Service Provider and User Views', 'Model-based', NULL, '2020 IEEE Access', 'Access', '8', NULL, '6448--6459', NULL, '10.1109/ACCESS.2019.2963397', 'Software Aging and Rejuvenation', 'Virtualization technology has promoted the fast development and deployment of cloud computing, and is now becoming an enabler of Internet of Everything. Virtual machine monitor (VMM), playing a critical role in a virtualized system, is software and hence it suffers from software aging after a long continuous running as well as software crashes due to elusive faults. Software rejuvenation techniques can be adopted to reduce the impact of software aging. Although there existed analytical model-based approaches for evaluating software rejuvenation techniques, none analyzed both application service (AS) availability and job completion time in a virtualized system with live virtual machine (VM) migration. This paper aims to quantitatively analyze software rejuvenation techniques from service provider and user views in a virtualized system deploying VMM reboot and live VM migration techniques for rejuvenation, under the condition that all the aging time, failure time, VMM fixing time and live VM migration time follow general distributions. We construct an analytical model by using a semi-Markov process (SMP) and derive formulas for calculating AS availability and job completion time. By analytical experiments, we can obtain the optimal migration trigger intervals for achieving the approximate maximum AS availability and the approximate minimum job completion time, and then service providers can make decisions for maximizing the benefits of service providers and users by adjusting parameter values.', NULL);
INSERT INTO `list` VALUES (10641, '0000', 2022, 'article', 'Bai, Jing and Chang, Xiaolin and Machida, Fumio and Jiang, Lili and Han, Zhen and Trivedi, Kishor S.', 'Impact of Service Function Aging on the Dependability for MEC Service Function Chain', 'Model-based', NULL, '2022 IEEE Transactions on Dependable and Secure Computing', 'TDSC', NULL, NULL, '1--1', NULL, '10.1109/TDSC.2022.3150782', 'Software Aging and Rejuvenation', 'The Multi-access Edge Computing (MEC) and Network Function Virtualization (NFV) integrated architecture is a key enabling platform for 5G to run multiple customized services in the form of service function chain (SFC) configured as an ordered set of service functions (SFs). However, memory-related software aging in the SF that can be exploited by attackers becomes a new threat to the dependability of MEC-SFC services. To provide dependable MEC-SFC services, proactive rejuvenation techniques to counteract the SF aging problem are essential. In this paper, we develop a semi-Markov model to quantitatively investigate the transient availability and steady-state dependability (availability and reliability) of MEC-SFC services. Our model enables the analysis of a MEC-SFC with any number of SFs, and can capture complex time-dependent behaviors of aging, failure, and recovery. The approximate accuracies of the presented model on dependability measures are comprehensively evaluated through comparative studies with simulation experiments. We then detect potential bottlenecks for a MEC-SFC system through sensitivity analysis and further analyze the impact of event-time interval distributions on steady-state dependability. Finally, we investigate the transient behaviors of a MEC-SFC service when varying system parameters during MEC-SFC operation.', NULL);
INSERT INTO `list` VALUES (10642, '0000', 2022, 'article', 'Bai, Jing and Chang, Xiaolin and Ning, Gaorong and Zhang, Zhenjiang and Trivedi, Kishor S.', 'Service Availability Analysis in a Virtualized System: A Markov Regenerative Model Approach', 'Model-based&rej', NULL, '2022 IEEE Transactions on Cloud Computing', 'TCC', '10', '3', '2118--2130', NULL, '10.1109/TCC.2020.3028648', 'Software Aging and Rejuvenation', 'With the rapid and wide development and deployment of system virtualization, service availability analysis has become increasingly important in a virtualized system (VS) which suffers from software aging. Software rejuvenation techniques can be applied to improve service availability but its effectiveness depends on the rejuvenation policy, which defines when and where to rejuvenate, and which rejuvenation technique to be triggered. This article aims to analyze the optimal inspection time interval for maximizing application service (AS) availability under a three-level rejuvenation policy, in which rejuvenation techniques are deployed at each level, namely, AS, virtual machine (VM), and virtual machine monitor (VMM) levels. We first apply Markov regenerative process to construct an analytical model for the VS. Experiments of injecting memory leaks are conducted to measure aging-related parameters. Furthermore, numerical analysis is carried out to study the quantitative relationship between AS availability and inspection time interval, and determine the approximate optimal inspection time interval.', NULL);
INSERT INTO `list` VALUES (10643, '0000', 2005, 'article', 'Bao, Y. and Sun, X. and Trivedi, K.S.', 'A Workload-Based Analysis of Software Aging, and Rejuvenation', 'Hybrid', NULL, '2005 IEEE Trans. Rel.', 'Trans. Rel.', '54', '3', '541--548', NULL, '10.1109/TR.2005.853442', 'Software Aging and Rejuvenation', 'We present a hierarchical model for the analysis of proactive fault management in the presence of system resource leaks. At the low level of the model hierarchy is a degradation model in which we use a nonhomogeneous Markov chain to establish an explicit connection between resource leaks, and the failure rate. With the degradation model, we prove that the failure rate is asymptotically constant in the absence of resource leaks, and it is increasing as leaks occur \\& accumulate, which confirms the resource leaks as an aging source. The proactive fault management (PFM) is modeled at the higher level as a semi-Markov process. The PFM model takes as input the degradation analysis from the low-level model, and allows us to determine optimal rejuvenation schedules with respect to various system measures.', NULL);
INSERT INTO `list` VALUES (10644, '0000', 2014, 'article', 'Barada, Subhashree and Swain, Santosh Kumar', 'A Survey Report On Software Aging and Rejuvenation studies in Virtualized Environment', '综述', NULL, '2014 ACM Journal on Emerging Technologies in Computing Systems', 'JETC', '5', '05', '6', NULL, NULL, 'Software Aging and Rejuvenation', 'Software aging is a phenomenon that occurs in a long running complex software system that tends to decrease in performance or increase in failure rate. This phenomenon lead to performance degradation and crash/hang failure. To counteract software aging a technique named as software rejuvenation has been proposed, which remove aging related failures and its effects. Nowadays, virtualized platform has become the popular choice to deploy complex and long running application. Critical and long running applications are always expected to be available but these applications are more prone to suffer from software aging phenomenon. To counteract this phenomenon software rejuvenation technique has been used. To eliminate downtime outages due to rejuvenation we have combined rejuvenation manager component with two aging indicators application-specific indicator and system-wide indicator. The idea behind our paper is to propose a algorithm which will choose the correct rejuvenation technique for virtual machine(VM) and virtual machine monitor(VMM) according to its aging effect. Through this method we can save both time and cost.', NULL);
INSERT INTO `list` VALUES (10645, '0000', 2012, 'inproceedings', 'Barbierato, Enrico and Bobbio, Andrea and Gribaudo, Marco and Iacono, Mauro', 'Multiformalism to Support Software Rejuvenation Modeling', 'Model-based', NULL, '2012 IEEE 23rd International Symposium on Software Reliability Engineering Workshops', 'ISSREW', NULL, NULL, '271--276', NULL, '10.1109/ISSREW.2012.92', 'Software Aging and Rejuvenation', 'The study of software aging and rejuvenation is based on models that conjugate the complexity of architectural models with the problem of time dependence of parameters. Exploiting the metaphors of common performance-oriented modeling formalisms (such as Petri nets or queuing networks) with the support of proper solution techniques can help modelers in approaching the analysis of complex software-based systems. This paper shows how SIMTHESys (a multiformalism modeling framework) can be used to approach the modeling problem by implementing a new user-defined modeling formalisms and the related fluid-based solution engine.', NULL);
INSERT INTO `list` VALUES (10646, '0000', 2021, 'inproceedings', 'Beierlieb, Lukas and Avritzer, Alberto and Iffländer, Lukas and Antunes, Nuno and Milenkoski, Aleksandar and Kounev, Samuel', 'Software Testing Strategies for Detecting Hypercall Handlers\' Aging-related Bugs', 'testing', NULL, '2021 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)', 'ISSREW', NULL, NULL, '48--55', NULL, '10.1109/ISSREW53611.2021.00043', 'Software Aging and Rejuvenation', 'With the continuing rise of cloud technology hypervisors play a vital role in the performance and reliability of current services. As long-running applications, they are susceptible to software aging. Hypervisors offer so-called hypercall interfaces for communication with the hosted virtual machines. These interfaces require thorough testing to ensure their long-term reliability. Existing research deals with the aging properties of hypervisors in general without considering the hypercalls. In this work, we share our experience that we collected during trying to understand hypercalls and their parameters and use them to construct test cases for hypervisor aging of Microsoft Hyper-V. We present a bug that we detected, which was reported and acknowledged by Microsoft. Further, based on our manual binary code analysis, we propose the idea of automating the analysis process to detect valid parameter ranges and execution conditions of hypercalls without manual effort.', NULL);
INSERT INTO `list` VALUES (10647, '0000', 2004, 'inproceedings', 'Bernstein, L. and Chandra, M. and Kintala', 'Software Rejuvenation', 'rej', NULL, 'not found', 'not found', NULL, NULL, NULL, NULL, 'https://www.semanticscholar.org/paper/Software-Rejuvenation-Bernstein-Chandra/7048bb581c033d0bd406287ac204d746f009aec0', 'Software Aging and Rejuvenation', 'S oftware modules comprise a large part of life-and mission-critical systems. System crashes are more likely to be the result of a fault in the software than in the hardware. In spite of our best efforts at removing the errors/faults (bugs 1) before deploying those systems, it is wise to assume that bugs remain in the system and those bugs often lead to failures (crashes). Software fault tolerance is aimed at tolerating those residual faults by building mechanisms to watch for failures and recover from them [1, 2]. Fault tolerance is a reac-tive approach: Failures usually happen at unexpected times, and the built-in mechanisms to recover from those failures will kick-in to restart the system and the service. However, these unscheduled interruptions in service are expensive and can be life-threatening. This article describes a proactive, preventive technique called software rejuvenation that prevents faults from becoming failures. Lawrence Bernstein observed in 1990 that faults/bugs, when triggered in software , do not always cause failures/crashes immediately but take the system into a state where it begins to decay 2. This decay has symptoms of memory leakage, broken pointers, unreleased file locks, numerical error accumulation, etc., causing gradual degradation in availability of service and data quality and eventually leading to a failure/crash. Based on this observation, a new method to enhance the dependability of a software system, called software rejuvenation, was introduced in 1995 by Kintala and his colleagues in Bell Labs [1, 3]. Software rejuvenation is a proactive approach that involves stopping an executing process periodically or when a failure is imminent, cleaning up the internal state of the system , and then restarting it at a known healthy state to prevent a predicted future failure. Software rejuvenation is as intuitive as occasionally rebooting your PC, except that it was never defined, implemented, modeled, and analyzed for software systems before 1995 [3]. Shari Pfleeger used the term software rejuvenation to mean, \" …looking back at software work products to try to derive additional information … \" in her seminal software engineering book [4]. Her use differs from ours as we focus on the execution of the software during its mission, and she focuses on the software development process. Use Since the 1960s, data communication designers knew to have software modules restart a communication line when it hung. Communication line handlers often include retry logic to restart a line if it hangs. IBM …', NULL);
INSERT INTO `list` VALUES (10648, '0000', 1998, 'inproceedings', 'Bobbio, A. and Sereno, M.', 'Fine Grained Software Rejuvenation Models', 'Measurement-based（阈值）', NULL, '1998 Proceedings. IEEE International Computer Performance and Dependability Symposium. IPDS\'98 (Cat. No.98TB100248)', 'IPDS', NULL, NULL, '4--12', NULL, '10.1109/IPDS.1998.707704', 'Software Aging and Rejuvenation', 'Preventive maintenance of operational software systems is a technique used to counteract the phenomenon of software \"aging\". Haung et al. (1995) proposed a technique called \"software rejuvenation\" in which the software is periodically stopped and then restarted in a \"robust\" state after a proper maintenance. This \"renewal\" of the software prevents, or at least postpones, the occurrence of crash failures. Previous models of software rejuvenation were all based on a \"black box\" approach in which the degradation mechanism was modeled by three stares: a fully available state, a degraded state from which the decision whether to rejuvenate can be taken, and a crash state. The present paper proposes a fine grained model for the quantitative analysis of software rejuvenation. The model is based on the assumption that it is possible to identify the current degradation level of the system by monitoring an observable quantity, so that the future strategy can be tuned on the measured parameter. Two different strategies are discussed to decide whether and when to rejuvenate. Furthermore, resorting to the theory of renewal processes with reward the steady-state unavailability can be estimated for the various policies and an optimality criterion can be invoked to evaluate the proper rejuvenation intervals. A set of numerical experiments conclude the paper.', NULL);
INSERT INTO `list` VALUES (10649, '0000', 2001, 'article', 'Bobbio, Andrea and Sereno, Matteo and Anglano, Cosimo', 'Fine grained software degradation models for optimal rejuvenation policies', 'Hybrid', NULL, '2001 Performance Evaluation', 'Perf. Eval.', '46', '1', '45--62', NULL, '10.1016/S0166-5316(01)00037-2', 'Software Aging and Rejuvenation', NULL, NULL);
INSERT INTO `list` VALUES (10650, '0000', 2012, 'inproceedings', 'Bovenzi, Antonio and Cotroneo, Domenico and Pietrantuono, Roberto and Russo, Stefano', 'On the Aging Effects Due to Concurrency Bugs: A Case Study on MySQL', '现象分析', NULL, '2012 IEEE 23rd International Symposium on Software Reliability Engineering', 'ISSRE', NULL, NULL, '211--220', NULL, '10.1109/ISSRE.2012.50', 'Software Aging and Rejuvenation', 'This study investigates software aging effects caused by the activation of concurrency bugs in a wellknown database management system (DBMS), namely MySQL. Experiments with different workloads are performed in order to reproduce the most likely conditions for concurrency bugs activation. Besides the typical aging effects observed in many operational systems (i.e., a gradual degradation over time), results highlight that both available resources and DBMS performance (e.g. service rate, service time, and connection latency) can decrease with time in a hard-to-predict way. We observed that, due to the activation of concurrency bug, the DBMS enters a degraded state in which: i) the estimation of Time-To-Failure (TTF) by means of memory depletion trend analysis is highly inaccurate, and ii) the failure rate does not depend on the instantaneous and/or mean accumulated work. Results suggest that, in such cases, finer-grained indicators and/or different techniques need to be taken into account for properly preventing failures.', NULL);
INSERT INTO `list` VALUES (10651, '0000', 2013, 'inproceedings', 'Bovenzi, Antonio and Alonso, Javier and Yamada, Hiroshi and Russo, Stefano and Trivedi, Kishor S.', 'Towards fast OS rejuvenation: An experimental evaluation of fast OS reboot techniques', 'rej', NULL, '2013 IEEE 24th International Symposium on Software Reliability Engineering (ISSRE)', 'ISSRE', NULL, NULL, '61--70', NULL, '10.1109/ISSRE.2013.6698905', 'Software Aging and Rejuvenation', 'Continuous or high availability is a key requirement for many modern IT systems. Computer operating systems play an important role in IT systems availability. Due to the complexity of their architecture, they are prone to suffer failures due to several types of software faults. Software aging causes a nonnegligible fraction of these failures. It leads to an accumulation of errors with time, increasing the system failure rate. This phenomenon can be accompanied by performance degradation and eventually system hang or even crash. As a countermeasure, software rejuvenation entails stopping the system, cleaning its internal state, and resuming its operation. This process usually incurs downtime. For an operating system, the downtime impacts any application running on top of it. Several solutions have been developed to speed up the boot time of operating systems in order to reduce the downtime overhead. We present a study of two fast OS reboot techniques for rejuvenation of Linux-based operating systems, namely Kexec and Phase-based reboot. The study measures the performance penalty they introduce and the gain in reduction of downtime overhead. The results reveal that the Kexec and Phase-based reboot have no statistically significant impact in terms of performance penalty from the user perspective. However, they may require extra resource (e.g., CPU) usage. The downtime overhead reduction, compared with normal Linux and VM reboots, is 77\\% and 79\\% in Kexec and Phase-based reboot, respectively.', NULL);
INSERT INTO `list` VALUES (10652, '0000', 2011, 'inproceedings', 'Bovenzi, Antonio and Cotroneo, Domenico and Pietrantuono, Roberto and Russo, Stefano', 'Workload Characterization for Software Aging Analysis', '度量', NULL, '2011 IEEE 22nd International Symposium on Software Reliability Engineering', 'ISSRE', NULL, NULL, '240--249', NULL, '10.1109/ISSRE.2011.18', 'Software Aging and Rejuvenation', 'The phenomenon of software aging is increasingly recognized as a relevant problem of long-running systems. Numerous experiments have been carried out in the last decade to empirically analyze software aging. Such experiments, besides highlighting the relevance of the phenomenon, have shown that aging is tightly related to the applied workload. However, due to the differences among the experimented applications and among the experimental conditions, results of past studies are not comparable to each other. This prevent from drawing general conclusions (e.g., about the aging-workload relationship), and from comparing systems from the aging perspective. In this paper, we propose a procedure to carry out aging experiments in different applications for: i) assessing aging trend of the individual systems, as well as assessing differences among them (i.e., obtaining comparable results), ii) inferring workload-aging relationships from experiments performed on different applications, by highlighting the most relevant workload parameters. The procedure is applied, through a set of long-running experiments, to three real-scale software applications, namely Apache Web Server, James Mail Server, and CARDAMOM, a middleware for the development of air traffic control (ATC) systems.', NULL);
INSERT INTO `list` VALUES (10653, '0000', 2013, 'article', 'Bruneo, Dario and Distefano, Salvatore and Longo, Francesco and Puliafito, Antonio and Scarpa, Marco', 'Workload-Based Software Rejuvenation in Cloud Systems', 'Model-based&rej', NULL, '2013 IEEE Transactions on Computers', 'TC', '62', '6', '1072--1085', NULL, '10.1109/TC.2013.30', 'Software Aging and Rejuvenation', 'Cloud computing is a promising paradigm able to rationalize the use of hardware resources by means of virtualization. Virtualization allows to instantiate one or more virtual machines (VMs) on top of a single physical machine managed by a virtual machine monitor (VMM). Similarly to any other software, a VMM experiences aging and failures. Software rejuvenation is a proactive fault management technique that involves terminating an application, cleaning up the system internal state, and restarting it to prevent the occurrence of future failures. In this work, we propose a technique to model and evaluate the VMM aging process and to investigate the optimal rejuvenation policy that maximizes the VMM availability under variable workload conditions. Starting from dynamic reliability theory and adopting symbolic algebraic techniques, we investigate and compare existing time-based VMM rejuvenation policies. We also propose a time-based policy that adapts the rejuvenation timer to the VMM workload condition improving the system availability. The effectiveness of the proposed modeling technique is demonstrated through a numerical example based on a case study taken from the literature.', NULL);
INSERT INTO `list` VALUES (10654, '0000', 2004, 'inproceedings', 'Candea, G. and Kawamoto, Shinichi and Fujiki, Yuichi and Friedman, Greg and Fox, A.', 'Microreboot - A Technique for Cheap Recovery', 'rej', NULL, '2004 Proc. 6th Symposium on Operating Systems Design and Implementation (OSDI), San Francisco, CA, Dec 2004\r\n', 'OSDI', NULL, NULL, NULL, NULL, 'https://www.semanticscholar.org/paper/Microreboot-A-Technique-for-Cheap-Recovery-Candea-Kawamoto/bbcb4f6ca45e14c3a7e4fa674e3778dbe2fd3d78', 'Software Aging and Rejuvenation', 'A significant fraction of software failures in large-scale Internet systems are cured by rebooting, even when the exact failure causes are unknown. However, rebooting can be expensive, causing nontrivial service disruption or downtime even when clusters and failover are employed. In this work we use separation of process recovery from data recovery to enable microrebooting - a fine-grain technique for surgically recovering faulty application components, without disturbing the rest of the application. \r\n\r\nWe evaluate microrebooting in an Internet auction system running on an application server. Microreboots recover most of the same failures as full reboots, but do so an order of magnitude faster and result in an order of magnitude savings in lost work. This cheap form of recovery engenders a new approach to high availability: microreboots can be employed at the slightest hint of failure, prior to node failover in multi-node clusters, even when mistakes in failure detection are likely; failure and recovery can be masked from end users through transparent call-level retries; and systems can be rejuvenated by parts, without ever being shut down.', NULL);
INSERT INTO `list` VALUES (10655, '0000', 2022, 'inproceedings', 'Carnevali, Laura and Paolieri, Marco and Reali, Riccardo and Scommegna, Leonardo and Vicario, Enrico', 'A Markov Regenerative Model of Software Rejuvenation Beyond the Enabling Restriction', 'Model-based', NULL, '2022 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)', 'ISSREW', NULL, NULL, '138--145', NULL, '10.1109/ISSREW55968.2022.00060', 'Software Aging and Rejuvenation', 'Software rejuvenation is a proactive maintenance technique that counteracts software aging by restarting a system or some of its components. We present a non-Markovian model of software rejuvenation where the underlying stochastic process is a Markov Regenerative Process (MRGP) beyond the enabling restriction, i.e., beyond the restriction of having at most one general (GEN, i.e., non-exponential) timer enabled in each state. The use of multiple concurrent GEN timers allows more accurate fitting of duration distributions from observed statistics (e.g., mean and variance), as well as better model expressiveness, enabling the formulation of mixed rejuvenation strategies that combine time-triggered and event-triggered rejuvenation. We leverage the functions for regenerative analysis based on stochastic state classes of the ORIS tool (through its SIRIO library) to evaluate this class of models and to select the rejuvenation period achieving an optimal tradeoff between two steady-state metrics, availability and undetected failure probability. We also show that, when G EN timers are replaced by exponential timers with the same mean (to satisfy enabling restriction), transient and steady-state are affected, resulting in inaccurate rejuvenation policies.', NULL);
INSERT INTO `list` VALUES (10656, '0000', 2010, 'article', 'Carrozza, G. and Cotroneo, D. and Natella, R. and Pecchia, A. and Russo, S.', 'Memory leak analysis of mission-critical middleware', 'Measurement-based', NULL, '2010 Journal of Systems and Software', 'JSS', '83', '9', '1556--1567', NULL, '10.1016/j.jss.2010.05.027', 'Software Aging and Rejuvenation', 'Memory leaks are recognized to be one of the major causes of memory exhaustion problems in complex software systems. This paper proposes a practical approach to detect aging phenomena caused by memory leaks in distributed objects Off-The-Shelf middleware, which are commonly used to develop critical applications. The approach, which is validated on a real-world case study from the Air Traffic Control domain, defines algorithms and ad hoc support tools to perform data filtering and to find the best trade off between experimentation time and statistical accuracy of aging trend estimates. Experiments show that fixing memory leaks is not always the key to solve memory exhaustion problems.', NULL);
INSERT INTO `list` VALUES (10657, '0000', 2002, 'inproceedings', 'Cassidy, K.J. and Gross, K.C. and Malekpour, A.', 'Advanced pattern recognition for detection of complex software aging phenomena in online transaction processing servers', 'Measurement-based（ML）', NULL, '2002 Proceedings International Conference on Dependable Systems and Networks', 'DSN', NULL, NULL, '478--482', NULL, '10.1109/DSN.2002.1028933', 'Software Aging and Rejuvenation', 'Software aging phenomena have been recently studied; one particularly complex type is shared memory pool latch contention in large OLTP servers. Latch contention onset leads to severe performance degradation until a manual rejuvenation of the DBMS shared memory pool is triggered. Conventional approaches to automated rejuvenation have failed for latch contention because no single resource metric has been identified that can be monitored to alert the onset of this complex mechanism. The current investigation explores the feasibility of applying an advanced pattern recognition method that is embodied in a commercially available equipment condition monitoring system (SmartSignal eCM/spl trade/) for proactive annunciation of software-aging faults. One hundred data signals are monitored from a large OLTP server, collected at 20-60 sec. intervals over a 5-month period. Results show 13 variables consistently deviate from normal operation prior to a latch event, providing up to 2 hours early warning.', NULL);
INSERT INTO `list` VALUES (10658, '0000', 2001, 'article', 'Castelli, V. and Harper, R. E. and Heidelberger, P. and Hunter, S. W. and Trivedi, K. S. and Vaidyanathan, K. and Zeggert, W. P.', 'Proactive management of software aging', 'Model-based', NULL, '2001 IBM J. Res. Dev.', 'J. Res. Dev.', '45', '2', '311--332', NULL, '10.1147/rd.452.0311', 'Software Aging and Rejuvenation', 'Software failures are now known to be a dominant source of system outages. Several studies and much anecdotal evidence point to \"software aging\" as a common phenomenon, in which the state of a software system degrades with time. Exhaustion of system resources, data corruption, and numerical error accumulation are the primary symptoms of this degradation, which may eventually lead to performance degradation of the software, crash/hang failure, or other undesirable effects. \"Software rejuvenation\" is a proactive technique intended to reduce the probability of future unplanned outages due to aging. The basic idea is to pause or halt the running software, refresh its internal state, and resume or restart it. Software rejuvenation can be performed by relying on a variety of indicators of aging, or on the time elapsed since the last rejuvenation. In response to the strong desire of customers to be provided with advance notice of unplanned outages, our group has developed techniques that detect the occurrence of software aging due to resource exhaustion, estimate the time remaining until the exhaustion reaches a critical level, and automatically perform proactive software rejuvenation of an application, process group, or entire operating system, depending on the pervasiveness of the resource exhaustion and our ability to pinpoint the source. This technology has been incorporated into the IBM Director for xSeries servers. To quantitatively evaluate the impact of different rejuvenation policies on the availability of cluster systems, we have developed analytical models based on stochastic reward nets (SRNs). For timebased rejuvenation policies, we determined the optimal rejuvenation interval based on system availability and cost. We also analyzed a rejuvenation policy based on prediction, and showed that it can further increase system availability and reduce downtime cost. These models are very general and can capture a multitude of cluster system characteristics, failure behavior, and performability measures, which we are just beginning to explore.', NULL);
INSERT INTO `list` VALUES (10659, '0000', 2018, 'article', 'Chen, Pengfei and Qi, Yong and Li, Xinyi and Hou, Di and Lyu, Michael Rung-Tsong', 'ARF-Predictor: Effective Prediction of Aging-Related Failure Using Entropy', '度量', NULL, '2018 IEEE Transactions on Dependable and Secure Computing', 'TDSC', '15', '4', '675--693', NULL, '10.1109/TDSC.2016.2604381', 'Software Aging and Rejuvenation', 'Even well-designed software systems suffer from chronic performance degradation, also known as “software aging”, due to internal (e.g., software bugs) or external (e.g., resource exhaustion) impairments. These chronic problems often fly under the radar of software monitoring systems before causing severe impacts (e.g., system failures). Therefore, it is a challenging issue how to timely predict the occurrence of failures caused by these problems. Unfortunately, the effectiveness of prior approaches are far from satisfactory due to the insufficiency of aging indicators adopted by them. To accurately predict failures caused by software aging which are named as Aging-Related Failure (ARFs), this paper presents a novel entropy-based aging indicator, namely Multidimensional Multi-scale Entropy (MMSE) which leverages the complexity embedded in runtime performance metrics to indicate software aging. To the best of our knowledge, this is the first time to leverage entropy to predict ARFs. Based upon MMSE, we implement three failure prediction approaches encapsulated in a proof-of-concept prototype named ARF-Predictor. The experimental evaluations in a Video on Demand (VoD) system, and in a real-world production system, AntVision, show that ARF-Predictor can predict ARFs with a very high accuracy and a low Ahead-Time-To-Failure (ATTF). Compared to previous approaches, ARF-Predictor improves the prediction accuracy by about 5 times and reduces ATTF even by 3 orders of magnitude. In addition, ARF-Predictor is light-weight enough to satisfy the real-time requirement.', NULL);
INSERT INTO `list` VALUES (10660, '0000', 2021, 'article', 'Chouhan, S. S. and Rathore, S.', 'Generative Adversarial Networks-Based Imbalance Learning in Software Aging-Related Bug Prediction', 'other', NULL, '2021 IEEE Transactions on Reliability', 'Trans. Rel.', NULL, NULL, NULL, NULL, '10.1109/TR.2021.3052510', 'Software Aging and Rejuvenation', 'An oversampling approach, generative adversarial networks-based synthetic data generation-based ARBs prediction models and experimental results showed that the presented approach led to the improved performance of prediction models for the ARBs Prediction as compared to the other state-of-the-art models. Software aging refers to a problem of performance decay in the software systems, which are running for a long period. The primary cause of this phenomenon is the accumulation of run-time errors in the software, which are also known as aging-related bugs (ARBs). Many efforts have been reported earlier to predict the origin of ARBs in the software so that these bugs can be identified and fixed during testing. Imbalanced dataset, where the representation of ARBs patterns is very less as compared to the representation of the non-ARBs pattern significantly hinders the performance of the ARBs prediction models. Therefore, in this article, we present an oversampling approach, generative adversarial networks-based synthetic data generation-based ARBs prediction models. The approach uses generative adversarial networks to generate synthetic samples for the ARBs patterns in the given datasets implicitly and build the prediction models on the processed datasets. To validate the performance of the presented approach, we perform an experimental study for the seven ARBs datasets collected from the public repository and use various performance measures to evaluate the results. The experimental results showed that the presented approach led to the improved performance of prediction models for the ARBs prediction as compared to the other state-of-the-art models.', NULL);
INSERT INTO `list` VALUES (10661, '0000', 2007, 'inproceedings', 'Cotroneo, Domenico and Orlando, Salvatore and Russo, Stefano', 'Characterizing Aging Phenomena of the Java Virtual Machine', 'Measurement-based&度量', NULL, '2007 26th IEEE International Symposium on Reliable Distributed Systems (SRDS 2007)', 'SRDS', NULL, NULL, '127--136', NULL, '10.1109/SRDS.2007.22', 'Software Aging and Rejuvenation', 'In this work we investigate software aging phenomena inside the Java Virtual Machine (JVM). Starting from an experimental campaign on real world testbeds, this work isolates the contribution of the JVM to the overall aging trend, and identifies, through statistical methods, which workload parameters are more relevant to aging dynamics. Experimental results show that the Sun Hotpost JVM experiences software aging phenomena. A consistent memory depletion trend (up to 50 KB/min) has been observed during periods of low garbage collector activity; the Just-In-Time compiler is also responsible for a lighter, but not negligible, memory depletion trend; finally, a consistent throughput loss (up to 24 KB/min) has been observed.', NULL);
INSERT INTO `list` VALUES (10662, '0000', 2020, 'article', 'Cotroneo, Domenico and Iannillo, Antonio Ken and Natella, Roberto and Pietrantuono, Roberto', 'A comprehensive study on software aging across android versions and vendors', 'Measurement-based', NULL, '2020 Empir Software Eng', 'Empir Software Eng', '25', '5', '3357--3395', NULL, '10.1007/s10664-020-09838-3', 'Software Aging and Rejuvenation', 'This paper analyzes the phenomenon of software aging – namely, the gradual performance degradation and resource exhaustion in the long run – in the Android OS. The study intends to highlight if, and to what extent, devices from different vendors, under various usage conditions and configurations, are affected by software aging and which parts of the system are the main contributors. The results demonstrate that software aging systematically determines a gradual loss of responsiveness perceived by the user, and an unjustified depletion of physical memory. The analysis reveals differences in the aging trends due to the workload factors and to the type of running applications, as well as differences due to vendors’ customization. Moreover, we analyze several system-level metrics to trace back the software aging effects to their main causes. We show that bloated Java containers are a significant contributor to software aging, and that it is feasible to mitigate aging through a micro-rejuvenation solution at the container level.', NULL);
INSERT INTO `list` VALUES (10663, '0000', 2019, 'inproceedings', 'Cotroneo, Domenico and De Simone, Luigi and Natella, Roberto and Pietrantuono, Roberto and Russo, Stefano', 'A Configurable Software Aging Detection and Rejuvenation Agent for Android', 'Measurement-based', NULL, '2019 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)', 'ISSREW', NULL, NULL, '239--245', NULL, '10.1109/ISSREW.2019.00078', 'Software Aging and Rejuvenation', 'This paper presents the design of ADaRTA, an aging detection and rejuvenation tool for Android. The tool is a software agent which i) performs selective monitoring of system processes and of trends in system performance indicators; ii) detects the aging state and estimates the time-to-aging-failure, through heuristic rules; iii) schedules and applies rejuvenation, based on the estimated time-to-aging-failure. The agent rules and parameters have been defined for ease of configuration and tuning by device designers. A stress testing experiment is discussed, showing ADaRTA\'s configurability for the device under test, and the ability of detecting the aging state to prevent device enter a failure state.', NULL);
INSERT INTO `list` VALUES (10664, '0000', 2013, 'article', 'Cotroneo, Domenico and Grottke, Michael and Natella, Roberto and Pietrantuono, Roberto and Trivedi, Kishor S.', 'Fault triggers in open-source software: An experience report', '分析bug报告&Classification', NULL, '2013 IEEE 24th International Symposium on Software Reliability Engineering (ISSRE)', 'ISSRE', NULL, NULL, '178--187', NULL, '10.1109/ISSRE.2013.6698917', 'Software Aging and Rejuvenation', 'With software systems becoming increasingly large and complex, many difficulties in coping with software bugs arise for developers. Despite good development practices, thorough testing, and proper maintenance policies, a non-negligible number of bugs remain in the released software. Understanding the type of residual bugs is fundamental for adopting proper countermeasures in current and future software releases. Depending on the fault triggering conditions that lead to a failure, developers can introduce fault-tolerance mechanisms and plan verification and validation strategies. In this paper, we analyze bugs in four large open-source software systems during their lifecycle, based on the concept of fault triggers. We first investigate how the type of system affects the bug type proportions, and their evolution over years. Then, an analysis of bug subtypes is performed, so as to better understand their nature, followed by a comparison with respect to attributes such as their average time to fix and severity.', NULL);
INSERT INTO `list` VALUES (10665, '0000', 2010, 'article', 'Cotroneo, Domenico and Natella, Roberto and Pietrantuono, Roberto', 'Is software aging related to software metrics?', '度量', NULL, '2010 IEEE Second International Workshop on Software Aging and Rejuvenation', 'IW-SAR', NULL, NULL, '1--6', NULL, '10.1109/WOSAR.2010.5722096', 'Software Aging and Rejuvenation', 'This work presents an empirical analysis aiming at investigating what kind of relationship exists between software aging and several static features of the software. While past studies on software aging focused on predicting the aging effects by monitoring and analytically modeling resource consumption at runtime, this study intends to explore if the static features of the software, as derived by its source code, presents potential relationships with software aging. We adopt a set of common software metrics concerning program structure, such as size and cyclomatic complexity, along with some features specifically developed for this study; metrics were then computed from ten complex software applications affected by aging. A statistical analysis to infer their relationship with software aging was carried out. Results encourage further investigations in this direction, since they show that software aging effects are related to the static features of software.', NULL);
INSERT INTO `list` VALUES (10666, '0000', 2013, 'article', 'Cotroneo, Domenico and Orlando, Salvatore and Pietrantuono, Roberto and Russo, Stefano', 'A measurement-based ageing analysis of the JVM', '度量', NULL, '2013 Journal of Software Testing, Verification and Reliability', 'J. Softw. Test. Verif. Reliab.', '23', '3', '199--239', NULL, '10.1002/stvr.467', 'Software Aging and Rejuvenation', 'SUMMARYIn this work, a software ageing analysis of Java-based software systems is conducted. The JVM is the core layer in Java-based systems, and its dependability greatly affects the overall system quality. Starting from an experimental campaign on a real-world test bed, this work isolates the contribution of the JVM to the overall ageing trend, and identifies, through statistical methods, which workload parameters are the most relevant to ageing dynamics. Results revealed the presence of several ageing dynamics in the JVM, including (i) a throughput loss trend mainly dependent on the execution unit, (ii) a slow memory depletion drift due to the just-in-time-compiler activity and (iii) a fast memory depletion drift caused by dynamics inside the garbage collector. The outlined procedure and obtained results are useful in order to (i) identify the presence of ageing phenomena, (ii) perform online ageing detection and time-to-exhaustion prediction and (iii) define optimal rejuvenation techniques. Copyright © 2011 John Wiley \\& Sons, Ltd.', NULL);
INSERT INTO `list` VALUES (10667, '0000', 2012, 'inproceedings', 'Cotroneo, Domenico and Natella, Roberto', 'Monitoring of Aging Software Systems Affected by Integer Overflows', '分析bug报告&度量', NULL, '2012 IEEE 23rd International Symposium on Software Reliability Engineering Workshops', 'ISSREW', NULL, NULL, '265--270', NULL, '10.1109/ISSREW.2012.91', 'Software Aging and Rejuvenation', 'Numerical aging-related bugs, which can manifest themselves as the accumulation of floating-point errors and the overflow of integers, represent a known but relatively neglected issue in the field of software aging and rejuvenation. Unfortunately, it is very difficult to avoid and to fix these bugs, since the rules of computer arithmetic and programming languages are often misunderstood or disregarded by programmers. Even though software rejuvenation can potentially mitigate these problems, its adoption is prevented by the lack of approaches for forecasting numerical software aging failures: in order to efficiently plan rejuvenation, the rate of numerical errors has to be known, or at least estimated. In this paper, we focus on software aging phenomena related to integer overflows. We present some examples of integer overflow issues of the MySQL open-source DBMS, and an approach for identifying symptoms of potential integer overflows by on-line monitoring.', NULL);
INSERT INTO `list` VALUES (10668, '0000', 2013, 'article', 'Cotroneo, Domenico and Natella, Roberto and Pietrantuono, Roberto', 'Predicting aging-related bugs using software complexity metrics', 'other', NULL, '2013 Performance Evaluation', 'Perf. Eval', '70', '3', '163--178', NULL, '10.1016/j.peva.2012.09.004', 'Software Aging and Rejuvenation', 'Long-running software systems tend to show degraded performance and an increased failure occurrence rate. This problem, known as Software Aging, which is typically related to the runtime accumulation of error conditions, is caused by the activation of the so-called Aging-Related Bugs (ARBs). This paper aims to predict the location of Aging-Related Bugs in complex software systems, so as to aid their identification during testing. First, we carried out a bug data analysis on three large software projects in order to collect data about ARBs. Then, a set of software complexity metrics were selected and extracted from the three projects. Finally, by using such metrics as predictor variables and machine learning algorithms, we built fault prediction models that can be used to predict which source code files are more prone to Aging-Related Bugs.', NULL);
INSERT INTO `list` VALUES (10669, '0000', 2010, 'inproceedings', 'Cotroneo, Domenico and Natella, Roberto and Pietrantuono, Roberto and Russo, Stefano', 'Software Aging Analysis of the Linux Operating System', '度量', NULL, '2010 IEEE 21st International Symposium on Software Reliability Engineering', 'ISSRE', NULL, NULL, '71--80', NULL, '10.1109/ISSRE.2010.24', 'Software Aging and Rejuvenation', 'Software systems running continuously for a long time tend to show degrading performance and an increasing failure occurrence rate, due to error conditions that accrue over time and eventually lead the system to failure. This phenomenon is usually referred to as Software Aging. Several long-running mission and safety critical applications have been reported to experience catastrophic aging-related failures. Software aging sources (i.e., aging-related bugs) may be hidden in several layers of a complex software system, ranging from the Operating System (OS) to the user application level. This paper presents a software aging analysis at the Operating System level, investigating software aging sources inside the Linux kernel. Linux is increasingly being employed in critical scenarios; this analysis intends to shed light on its behaviour from the aging perspective. The study is based on an experimental campaign designed to investigate the kernel internal behaviour over long running executions. By means of a kernel tracing tool specifically developed for this study, we collected relevant parameters of several kernel subsystems. Statistical analysis of collected data allowed us to confirm the presence of aging sources in Linux and to relate the observed aging dynamics to the monitored subsystems behaviour. The analysis output allowed us to infer potential sources of aging in the kernel subsystems.', NULL);
INSERT INTO `list` VALUES (10670, '0000', 2011, 'inproceedings', 'Cotroneo, Domenico and Natella, Roberto and Pietrantuono, Roberto and Russo, Stefano', 'Software Aging and Rejuvenation: Where We Are and Where We Are Going', '综述', NULL, '2011 IEEE Third International Workshop on Software Aging and Rejuvenation', 'IW-SAR', NULL, NULL, '1--6', 'IEEE', '10.1109/WoSAR.2011.15', 'Software Aging and Rejuvenation', 'After 16 years, a signiﬁcant body of knowledge has been established in the area of Software Aging and Rejuvenation (SAR). In this paper, we survey papers about SAR that appeared in IEEE conferences and booktitles, identify where SAR research has been mostly focused, and highlight some aspects deserving more attention, with the aim to provoke a constructive discussion among SAR researches about where SAR has arrived and where it should be headed in the next future.', NULL);
INSERT INTO `list` VALUES (10671, '0000', 2016, 'inproceedings', 'Cotroneo, Domenico and Fucci, Francesco and Iannillo, Antonio Ken and Natella, Roberto and Pietrantuono, Roberto', 'Software Aging Analysis of the Android Mobile OS', '度量', NULL, '2016 IEEE 27th International Symposium on Software Reliability Engineering (ISSRE)', 'ISSRE', NULL, NULL, '478--489', NULL, '10.1109/ISSRE.2016.25', 'Software Aging and Rejuvenation', 'Mobile devices are significantly complex, feature-rich, and heavily customized, thus they are prone to software reliability and performance issues. This paper considers the problem of software aging in Android mobile OS, which causes the device to gradually degrade in responsiveness, and to eventually fail. We present a methodology to identify factors (such as workloads and device configurations) and resource utilization metrics that are correlated with software aging. Moreover, we performed an empirical analysis of recent Android devices, finding that software aging actually affects them. The analysis pointed out processes and components of the Android OS affected by software aging, and metrics useful as indicators of software aging to schedule software rejuvenation actions.', NULL);
INSERT INTO `list` VALUES (10672, '0000', 2022, 'article', 'Cotroneo, Domenico and De Simone, Luigi and Natella, Roberto and Pietrantuono, Roberto and Russo, Stefano', 'Software Micro-Rejuvenation for Android Mobile Systems', 'Measurement-based', NULL, '2022 Journal of Systems and Software', 'JSS', '186', NULL, '111181', NULL, '10.1016/j.jss.2021.111181', 'Software Aging and Rejuvenation', 'Software aging – the phenomenon affecting many long-running systems, causing performance degradation or an increasing failure rate over mission time, and eventually leading to failure – is known to affect mobile devices and their operating systems, too. Software rejuvenation – the technique typically used to counteract aging – may compromise the user’s perception of availability and reliability of the personal device, if applied at a coarse grain, e.g., by restarting applications or, worse, rebooting the entire device. This article proposes a configurable micro-rejuvenation technique to counteract software aging in Android-based mobile devices, acting at a fine-grained level, namely on in-memory system data structures. The technique is engineered in two phases. Before releasing the (customized) Android version, a heap profiling facility is used by the manufacturer’s developers to identify potentially bloating data structures in Android services and to instrument their code. After release, an aging detection and rejuvenation service will safely clean up the bloating data structures, with a negligible impact on user perception and device availability, as neither the device nor operating system’s processes are restarted. The results of experiments show the ability of the technique to provide significant gains in aging mobile operating system responsiveness and time to failure.', NULL);
INSERT INTO `list` VALUES (10673, '0000', 2014, 'article', 'Cotroneo, Domenico and Natella, Roberto and Pietrantuono, Roberto and Russo, Stefano', 'A survey of software aging and rejuvenation studies', '综述', NULL, '2014 J. Emerg. Technol. Comput. Syst.', 'J. Emerg. Technol. Comput. Syst.', '10', '1', '1--34', NULL, '10.1145/2539117', 'Software Aging and Rejuvenation', 'Software aging\r\nis a phenomenon plaguing many long-running complex software systems, which exhibit performance degradation or an increasing failure rate. Several strategies based on the proactive\r\nrejuvenation\r\nof the software state have been proposed to counteract software aging and prevent failures. This survey article provides an overview of studies on Software Aging and Rejuvenation (SAR) that have appeared in major booktitles and conference proceedings, with respect to the statistical approaches that have been used to forecast software aging phenomena and to plan rejuvenation, the kind of systems and aging effects that have been studied, and the techniques that have been proposed to rejuvenate complex software systems. The analysis is useful to identify key results from SAR research, and it is leveraged in this article to highlight trends and open issues.', NULL);
INSERT INTO `list` VALUES (10674, '0000', 2021, 'inproceedings', 'da Costa, Jackson T. and de S. Matos, Rubens and de Araujo, Jean C. T. and Maciel, Paulo R. M.', 'Systematic Mapping of Literature on Software Aging and Rejuvenation Research Trends', '综述', NULL, '2021 Annual Reliability and Maintainability Symposium (RAMS)', 'RAMS', NULL, NULL, '1--6', NULL, '10.1109/RAMS48097.2021.9605775', 'Software Aging and Rejuvenation', 'SUMMARY \\& CONCLUSIONSSoftware aging is a topic in the literature that has matured over the past 30 years and can be defined as software degradation during its operational life. On the other hand, the software rejuvenation technique is a proactive measure that includes the application stop, removal of error accumulation conditions, and restart in a clean environment. This paper provides a systematic mapping of the contemporary literature on Software Aging and Rejuvenation (SAR), observing the research trends in this theme in the last decade, from 2010 to 2019. The results highlight which strategic approaches of rejuvenation or aging detection have been approached when designing solutions both in the commercial and academic fields, and thus, researchers can use them when dealing with new software aging phenomena. Besides, it can be of great relevance for the academic community that studies the SAR to provide a current view on state of the art in this topic.', NULL);
INSERT INTO `list` VALUES (10675, '0000', 2018, 'article', 'Dang, Weichao', 'Optimization of Software Rejuvenation Policy based on State-Control-Limit', 'testing', NULL, '2018 IJPE', 'IJPE', NULL, NULL, NULL, NULL, '10.23940/ijpe.18.02.p3.210222', 'Software Aging and Rejuvenation', 'Semantic Scholar extracted view of \"Optimization of Software Rejuvenation Policy based on State-Control-Limit\" by Weichao Dang', NULL);
INSERT INTO `list` VALUES (10676, '0000', 2022, 'inproceedings', 'Dias, Douglas and Machida, Fumio and Andrade, Ermeson', 'Analysis of Software Aging in a Blockchain Platform', 'Measurement-based&度量', NULL, '2022 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)', 'ISSREW', NULL, NULL, '170--177', NULL, '10.1109/ISSREW55968.2022.00064', 'Software Aging and Rejuvenation', 'Blockchain platforms have gained popularity in recent years and integrated with other digital technologies like Internet of Things (IoT) and Artificial Intelligence (AI) for multiple-business purposes. Software aging is a common issue in many long-running software systems, but little has been experienced in the context of blockchain platforms. To narrow this gap, this work aims to characterize potential software aging issues in the Cardano blockchain platform that is considered the largest cryptocurrency adopting proof-of-stake. By performing statistical analysis on the measurement data of the Cardano blockchain deployed in two environments with different configurations, we found a symptom of software aging through memory degradation that was confirmed by the Mann-Kendall test. By analyzing the running processes, we identify the cardano-node (the main process of the platform) as the process possibly responsible for such degradation.', NULL);
INSERT INTO `list` VALUES (10677, '0000', 2000, 'article', 'Dohi, T. and Goseva-Popstojanova, K. and Trivedi, K.S.', 'Analysis of software cost models with rejuvenation', 'Model-based', NULL, '2000 Proceedings. Fifth IEEE International Symposium on High Assurance Systems Engineering (HASE 2000)', 'HASE', NULL, NULL, '25--34', NULL, '10.1109/HASE.2000.895436', 'Software Aging and Rejuvenation', 'Software rejuvenation is a preventive maintenance technique that has been extensively studied in the recent literature. In this paper we extend the classical result by Huang et al. (1995), and in addition propose a modified stochastic model to generate the software rejuvenation schedule. More precisely, the software rejuvenation models are formulated via the semi-Markov process, and the optimal software rejuvenation schedule which minimizes the expected costs per unit time in the steady-state are derived analytically for respective cases. Further we develop non-parametric algorithms to estimate the optimal software rejuvenation schedules, provided that the statistical complete (unsensored) sample data of failure time is given. In numerical examples, we compare two models in terms of economic justification, and examine asymptotic properties for the statistical estimation algorithms.', NULL);
INSERT INTO `list` VALUES (10678, '0000', 2001, 'article', 'Dohi, T.', 'Estimating Software Rejuvenation Schedules in High-Assurance Systems', 'Model-based', NULL, '2001 The Computer Journal', 'Comput. J.', '44', '6', '473--485', NULL, '10.1093/comjnl/44.6.473', 'Software Aging and Rejuvenation', 'Software rejuvenation is a preventive maintenance technique that has been extensively studied in recent literature. In this paper, we extend the classical result by Huang et al. (1995), and in addition propose a modified stochastic model to generate the software rejuvenation schedule. More precisely, the software rejuvenation models are formulated via the semi-Markov reward process, and the optimal software rejuvenation schedules are derived analytically in terms of the reward rate. In particular, we consider the two special cases: steady-state availability and expected cost per unit time in the steady state. Further, we develop non-parametric algorithms to estimate the optimal software rejuvenation schedules, provided that the statistically complete (unsensored) sample data of failure time is given. In numerical examples, we compare two models from the viewpoints of system availability and economic justification, and examine asymptotic properties for the statistical estimation algorithms.', NULL);
INSERT INTO `list` VALUES (10679, '0000', 2001, 'inproceedings', 'Dohi, T. and Danjou, T. and Okamura, H.', 'Optimal software rejuvenation policy with discounting', 'Model-based', NULL, '2001 Proceedings 2001 Pacific Rim International Symposium on Dependable Computing', 'PRDC', NULL, NULL, '87--94', NULL, '10.1109/PRDC.2001.992684', 'Software Aging and Rejuvenation', 'Software rejuvenation is a preventive maintenance technique that has been extensively studied in the recent literature. We consider a generalized problem to estimate the optimal software rejuvenation schedule. More precisely, the software rejuvenation model is formulated via the semi-Markov process, and the optimal software rejuvenation schedule which minimizes the expected total discounted cost over an infinite time horizon is derived analytically. Further, we develop a statistically nonparametric algorithm to estimate the optimal software rejuvenation schedule, provided that the complete sample data of failure time is given. In numerical examples, we investigate how the discount factor affects the optimal policy and examine an asymptotic property for the statistical estimation algorithm.', NULL);
INSERT INTO `list` VALUES (10680, '0000', 2000, 'inproceedings', 'Dohi, T. and Goseva-Popstojanova, K. and Trivedi, K.S.', 'Statistical Non-Parametric Algorithms to Estimate the Optimal Software Rejuvenation Schedule', 'Model-based', NULL, '2000 Pacific Rim International Symposium on Dependable Computing', 'PRDC', NULL, NULL, '77--84', 'IEEE', '10.1109/PRDC.2000.897287', 'Software Aging and Rejuvenation', 'In this paper, we extend the classical result by Huang, Kintala, Kolettis and Fulton (1995), and in addition propose a modified stochastic model to determine the software rejuvenation schedule. More precisely, the software rejuvenation models are formulated via the semi-Markov processes, and the optimal software rejuvenation schedules which maximize the system availabilities are derived analytically for respective cases. Further, we develop nonparametric statistical algorithms to estimate the optimal software rejuvenation schedules, provided that the statistical complete (unsensored) sample data of failure times is given. In numerical examples, we examine asymptotic properties for the statistical estimation algorithms.', NULL);
INSERT INTO `list` VALUES (10681, '0000', 2017, 'inproceedings', 'Du, Xiaoting and Zheng, Zheng and Xiao, Guanping and Yin, Beibei', 'The Automatic Classification of Fault Trigger Based Bug Report', 'Classification', NULL, '2017 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)', 'ISSREW', NULL, NULL, '259--265', NULL, '10.1109/ISSREW.2017.28', 'Software Aging and Rejuvenation', 'Understanding the types of defects is of practical interest, which could help developers adopt proper measures in current and future software releases. As the amount of bug reports increasing, manual classification brings a heavy burden to developers. In this paper, we propose a word2vec based framework of multi-granularity automatic classification for bug reports based on fault triggers. Except classifying bug reports into bug/non-bug and Bohrbug/Mandelbug, the classification of Mandelbugs is the focus of this paper. Characteristic representation of common classification methods suffer from data sparsity and high dimensionality, thus we use word2vec, which can express words as low-dimensional word vectors with semantic relations in this paper. Furthermore, in order to improve the quality of classification, we analyzed the impact factors of classification. The results show that our method performs well in automatic classifying bugs into fault trigger classes.', NULL);
INSERT INTO `list` VALUES (10682, '0000', 2019, 'article', 'Du, Xiaoting and Zhou, Zenghui and Yin, Beibei and Xiao, Guanping', 'Cross-project bug type prediction based on transfer learning', 'other', NULL, '2019 Software Quality Journal', 'Softw. Qual. J', NULL, NULL, NULL, NULL, '10.1007/s11219-019-09467-0', 'Software Aging and Rejuvenation', 'A cross-project bug type prediction framework based on transfer learning, which breaks the assumption of traditional machine learning methods that the training set and the test set should follow the same distribution, is proposed. The prediction of bug types provides useful insights into the software maintenance process. It can improve the efficiency of software testing and help developers adopt corresponding strategies to fix bugs before releasing software projects. Typically, the prediction tasks are performed through machine learning classifiers, which rely heavily on labeled data. However, for a software project that has insufficient labeled data, it is difficult to train the classification model for predicting bug types. Although labeled data of other projects can be used as training data, the results of the cross-project prediction are often poor. To solve this problem, this paper proposes a cross-project bug type prediction framework based on transfer learning. Transfer learning breaks the assumption of traditional machine learning methods that the training set and the test set should follow the same distribution. Our experiments show that the results of cross-project bug type prediction have significant improvement by adopting transfer learning. In addition, we have studied the factors that influence the prediction results, including different pairs of source and target projects, and the number of bug reports in the source project.', NULL);
INSERT INTO `list` VALUES (10683, '0000', 2021, 'article', 'Du, Xiaoting and Zheng, Zheng and Xiao, Guanping and Zhou, Zenghui and Trivedi, Kishor S.', 'DeepSIM: Deep Semantic Information-Based Automatic Mandelbug Classification', 'Classification', NULL, '2021 IEEE Transactions on Reliability', 'Trans. Rel.', NULL, NULL, '1--15', NULL, '10.1109/TR.2021.3110096', 'Software Aging and Rejuvenation', 'Understanding and predicting types of bugs are of practical importance for developers to improve the testing efficiency and take appropriate steps to address bugs in software releases. However, due to the complex conditions under which faults manifest and the complexity of the classification rules, the automatic classification of Mandelbugs is a difficult task. In this article, we present a deep semantic information-based Mandelbug classification method that combines a semantic model with a deep learning classifier and makes use of both labeled and unlabeled bug reports. By training the bug report semantic model on millions of bug reports, each word in the text of a bug report is represented as a word embedding that preserves the semantic relationship among the words. Then, a convolutional neural network model is designed to capture the high-level features of bug reports to obtain a more accurate classification. Moreover, the effects of the semantic model size and domain on the classification results are investigated, and the quality of word embeddings is evaluated by analyzing several important parameters.', NULL);
INSERT INTO `list` VALUES (10684, '0000', 2022, 'article', 'Du, Xiaoting and Sui, Yulei and Liu, Zhihao and Ai, Jun', 'An Empirical Study of Fault Triggers in Deep Learning Frameworks', '分析bug报告&Classification', NULL, '2022 IEEE Transactions on Dependable and Secure Computing', 'TDSC', NULL, NULL, '1--1', NULL, '10.1109/TDSC.2022.3152239', 'Software Aging and Rejuvenation', 'Deep learning frameworks play a key rule to bridge the gap between deep learning theory and practice. With the growing of safety- and security-critical applications built upon deep learning frameworks, their reliability is becoming increasingly important. To ensure the reliability of these frameworks, several efforts have been taken to study the causes and symptoms of bugs in deep learning frameworks, however, relatively little progress has been made in investigating the fault triggering conditions of those bugs. This paper presents the first comprehensive empirical study on fault triggering conditions in three widely-used deep learning frameworks (i.e., TensorFlow, MXNET, and PaddlePaddle). We have collected 3,555 bug reports from GitHub repositories of these frameworks. A bug classification is performed based on fault triggering conditions, followed by the analysis of frequency distribution of different bug types and the evolution features. The correlations between bug types and fixing time are investigated. Moreover, we have also studied the root causes of Bohrbugs and Mandelbugs and investigated the important consequences of each bug type. Finally, the analysis of regression bugs in deep learning frameworks is conducted. We have revealed 12 important findings based on our empirical results and have provided 10 implications for developers and users.', NULL);
INSERT INTO `list` VALUES (10685, '0000', 2020, 'inproceedings', 'Du, Xiaoting and Xiao, Guanping and Sui, Yulei', 'Fault Triggers in the TensorFlow Framework: An Experience Report', '分析bug报告&Classification', NULL, '2020 IEEE 31st International Symposium on Software Reliability Engineering (ISSRE)', 'ISSRE', NULL, NULL, '1--12', NULL, '10.1109/ISSRE5003.2020.00010', 'Software Aging and Rejuvenation', 'TensorFlow is one of the most popular machine learning frameworks for developing machine learning algorithms. Because of the popularity and large-scale use of TensorFlow, even a single bug may lead to severe consequences and impact a large number of users. With a growing number of safety-critical systems built upon TensorFlow, its reliability is becoming increasingly important. An essential step to ensure TensorFlow\'s reliability is to understand the characteristics of bugs that occurred in TensorFlow. This paper presents the first comprehensive empirical study on fault triggering conditions in TensorFlow. 2,285 bug reports from TensorFlow\'s GitHub repository are collected. A bug classification is performed based on fault triggering conditions, followed by the frequency distribution of different types of bugs and the evolution features of varying bug types over time. Then the relationships between bug types and fixing time are also investigated. In addition, the root causes of Bohrbugs and Mandelbugs are studied. Five root causes are discovered. Furthermore, the analysis of regression bugs in TensorFlow is conducted. We have revealed 10 important findings based on our empirical results. There are 8 implications based on these findings are provided for developers and users.', NULL);
INSERT INTO `list` VALUES (10686, '0000', 2009, 'inproceedings', 'Du, Xiaozhi and Qi, Yong and Hou, Di and Chen, Ying and Zhong, Xiao', 'Modeling and Performance Analysis of Software Rejuvenation Policies for Multiple Degradation Systems', 'Hybrid', NULL, '2009 33rd Annual IEEE International Computer Software and Applications Conference', 'COMPSAC', '1', NULL, '240--245', NULL, '10.1109/COMPSAC.2009.39', 'Software Aging and Rejuvenation', 'Software rejuvenation is a preventive and proactive technology to counteract the phenomenon of software aging and system failures and to improve the system reliability. In this paper we present and analyze three software rejuvenation policies for an operational software system with multiple degradations, called preemptive rejuvenation, delayed rejuvenation and mixed rejuvenation. These policies consider both history data and current running state, and the rejuvenation action is triggered on the basis of predetermined performance threshold and rejuvenation interval respectively. Continuous-time Markov chains are used to describe the analytic models. To evaluate these polices expediently, we utilize deterministic and stochastic Petri nets to solve the models. Numerical results show that the deployment of software rejuvenation in the system leads to significant improvement in availability and throughput. These three rejuvenation policies are better than the standard rejuvenation policy, and the mixed policy is the best one.', NULL);
INSERT INTO `list` VALUES (10687, '0000', 2008, 'inproceedings', 'El-Shishiny, Hisham and Deraz, Sally and Bahy, Omar', 'Mining Software Aging Patterns by Artificial Neural Networks', 'Measurement-based（ML）', NULL, '2008 Artificial Neural Networks in Pattern Recognition', 'ANNPR', NULL, NULL, '252--262', 'Springer', '10.1007/978-3-540-69939-2_24', 'Software Aging and Rejuvenation', 'This paper investigates the use of Artificial Neural Networks (ANN) to mine and predict patterns in software aging phenomenon. We analyze resource usage data collected on a typical long-running software system: a web server. A Multi-Layer Perceptron feed forward Artificial Neural Network was trained on an Apache web server dataset to predict future server swap space and physical free memory resource exhaustion through ANN univariate time series forecasting and ANN nonlinear multivariate time series empirical modeling. The results were benchmarked against those obtained from non-parametric statistical techniques, parametric time series models and other empirical modeling techniques reported in the literature.', NULL);
INSERT INTO `list` VALUES (10688, '0000', 2016, 'inproceedings', 'Escheikh, Mohamed and Tayachi, Zayneb and Barkaoui, Kamel', 'Workload-Dependent Software Aging Impact on Performance and Energy Consumption in Server Virtualized Systems', 'Model-based&rej', NULL, '2016 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)', 'ISSREW', NULL, NULL, '111--118', NULL, '10.1109/ISSREW.2016.31', 'Software Aging and Rejuvenation', 'Dependability modeling and performability analysis of server virtualized systems (SVSs) are today a key challenging problem to evaluate cost-effectiveness and savings in green data centers. This paper tackles various issues related to performability analysis of server virtualized system (SVS) handling workload-aware power management (PM) mechanism and subject to software aging, unplanned failures and Migrate-VM rejuvenation. In this work we develop a modeling approach based on stochastic reward nets (SRNs) to investigate dependencies between several SVS modules including virtual machine monitor (VMM), virtual machine (VM), data intensive applications and power-manageable component (PMC) with workload-aware timebased PM mechanism. We show through numerical analysis how availability, power usage and power-performance trade-off, of SVS, are impacted by aging and workload burstiness.', NULL);
INSERT INTO `list` VALUES (10689, '0000', 2008, 'inproceedings', 'Eto, Hiroyuki and Dohi, Tadashi and Ma, Jianhua', 'Simulation-Based Optimization Approach for Software Cost Model with Rejuvenation', 'Hybrid', NULL, '2008 Autonomic and Trusted Computing', 'ATC', NULL, NULL, '206--218', 'Springer', NULL, 'Software Aging and Rejuvenation', 'Software rejuvenation is a preventive and proactive maintenance solution that is particularly useful for counteracting the phenomenon of software aging. In this paper we consider an operational software system with multiple degradations and derive the optimal software rejuvenation policy minimizing the expected operation cost per unit time in the steady state, via the dynamic programing approach. Especially, we develop a reinforcement learning algorithm to estimate the optimal rejuvenation schedule adaptively and examine its asymptotic properties through a simulation experiment.', NULL);
INSERT INTO `list` VALUES (10690, '0000', 2022, 'inproceedings', 'Fantechi, Alessandro and Gori, Gloria and Papini, Marco', 'Software rejuvenation and runtime reliability monitoring', 'Hybrid', NULL, '2022 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)', 'ISSREW', NULL, NULL, '162--169', NULL, '10.1109/ISSREW55968.2022.00063', 'Software Aging and Rejuvenation', 'The overall system reliability of complex Cyber Physical systems is contributed both by hardware reliability and software reliability. The former can be often increased through fault-tolerant mechanisms and architectures, while the latter can take advantage of a suitable rejuvenation policy. These characteristics call for flexible runtime safety checks of system executions that go beyond conventional runtime mon-itoring of pre-programmed safety conditions, also in order to minimize maintenance costs. Defining a satisfying monitoring model for complex systems is still a challenge. In this paper, we investigate the application of a novel approach, named Reliability Based Monitoring (RBM), that allows for a flexible runtime monitoring of software reliability in complex systems. The approach leverages a hierarchical reliability model periodically applied to runtime diagnostics data: this allows to dynamically plan rejuvenation activities that are able to prevent software failures.', NULL);
INSERT INTO `list` VALUES (10691, '0000', 2001, 'article', 'Fetzer, C. and Hogstedt, K.', 'Rejuvenation and failure detection in partitionable systems', 'rej', NULL, '2001 Proceedings 2001 Pacific Rim International Symposium on Dependable Computing', 'PRDC', NULL, NULL, '154--161', NULL, '10.1109/PRDC.2001.992692', 'Software Aging and Rejuvenation', 'Certain gateways (e.g., some cable or DSL modems) are known to have low reliability and low availability. Most failures of these devices can however be \"fixed\" by rejuvenating the device after a failure has been detected. Such a detection based rejuvenation strategy permits increasing the availability of these gateways. In the considered scenario, rejuvenation is non-trivial since a failure of such a gateway will leave it partitioned away from the network. In particular, network operators that want to rejuvenate these gateways are in a different network partition, and can therefore not initiate a remote rejuvenation. In this paper we propose a failure detection based rejuvenation service and a remote detection service. The rejuvenation service detects and fixes \"soft\" failures automatically (in one partition), and the detection service detects (in another partition) all rejuvenations exactly once, within a bounded amount of time, even when the gateway is rejuvenated consecutively. The detection service also allows the detection of \"hard\" failures, and filtering of notifications of soft failures.', NULL);
INSERT INTO `list` VALUES (10692, '0000', 2018, 'article', 'Ficco, Massimo and Pietrantuono, Roberto and Russo, Stefano', 'Aging-related performance anomalies in the apache storm stream processing system', '度量&Measurement-based', NULL, '2018 Future Generation Computer Systems', 'FGCS', '86', NULL, '975--994', NULL, '10.1016/j.future.2017.08.051', 'Software Aging and Rejuvenation', 'Event stream processing has recently emerged as a popular paradigm for implementing high-volume distributed (near-)real time data processing applications. Several open source systems are today available, supporting the development of such applications, many of which developed with the technologies of the Apache Software Foundation. These so called stream processors are long-running complex software systems which may be affected by software aging, a well-known phenomenon among operation engineers, consisting of a progressive increase in the failure rate or in performance degradation of a software system over time. We address the problem of identifying symptoms and sources of software aging in the Apache Storm event stream processing system; this helps to identify proper strategies to prevent or mitigate anomalous behaviors in production environments. To this aim, we present an experimental study investigating aging manifestations in a popular system, namely Apache Storm. Results show that Storm presents anomalous behaviors in long runs, which prevent some topologies from working continuously. These can be attributed to software aging, due to Storm internal resource management mechanisms influenced by the garbage collector and the memory assigned to worker processes. We discuss the aging-related Apache Storm behaviors, and we experiment rejuvenation actions, showing that they are actually able to remove them.', NULL);
INSERT INTO `list` VALUES (10693, '0000', 2018, 'article', 'Ficco', 'Aging-related Performance Anomalies in the Apache Storm Stream Processing System', '现象分析', NULL, '2018 Future Generation Computer Systems', 'FGCS', NULL, NULL, NULL, NULL, NULL, 'Software Aging and Rejuvenation', NULL, NULL);
INSERT INTO `list` VALUES (10694, '0000', 1995, 'inproceedings', 'Garg, S. and Puliafito, A. and Telek, M. and Trivedi, K.S.', 'Analysis of Software Rejuvenation using Markov Regenerative Stochastic Petri Net', 'Model-based', NULL, '1995 Proceedings of Sixth International Symposium on Software Reliability Engineering', 'ISSRE', NULL, NULL, '180--187', 'IEEE', '10.1109/ISSRE.1995.497656', 'Software Aging and Rejuvenation', 'In a client-server type system, the server software is required to run continuously for very long periods. Due to repeated and potentially faulty usage by many clients, such software \"ages\" with time and eventually fails. (Huang et al., 1995) proposed a technique called \"software rejuvenation\" in which the software is periodically stopped and then restarted in a \"robust\" state after proper maintenance. This \"renewal\" of software prevents (or at least postpones) the crash failure. As the time lost (or the cost incurred) due to the software failure is typically more than the time lost (or the cost incurred) due to rejuvenation, the technique reduces the expected unavailability of the software. We present a quantitative analysis of software rejuvenation. The behavior of the system is represented through a Markov Regenerative Stochastic Petri Net (MRSPN) model which is solved both for steady state as well as transient conditions. We provide a closed-form analytical solution for the steady state expected down time (and the expected cost incurred) due to system unavailability. We also evaluate the optimal rejuvenation interval which minimizes the expected unavailability of the software.', NULL);
INSERT INTO `list` VALUES (10695, '0000', 1998, 'article', 'Garg, S. and Puliafito, A. and Telek, M. and Trivedi, K.', 'Analysis of Preventive Maintenance in Transactions Based Software Systems', 'Model-based', NULL, '1998 IEEE Transactions on Computers', 'TC', '47', '1', '96--107', NULL, '10.1109/12.656092', 'Software Aging and Rejuvenation', 'Preventive maintenance of operational software systems, a novel technique for software fault tolerance, is used specifically to counteract the phenomenon of software \"aging\". However, it incurs some overhead. The necessity to do preventive maintenance, not only in general purpose software systems of mass use, but also in safety-critical and highly available systems, clearly indicates the need to follow an analysis based approach to determine the optimal times to perform preventive maintenance. In this paper, we present an analytical model of a software system which serves transactions. Due to aging, not only the service rate of the software decreases with time, but also the software itself experiences crash/hang failures which result in its unavailability. Two policies for preventive maintenance are modeled and expressions for resulting steady state availability, probability that an arriving transaction is lost and an upper bound on the expected response time of a transition are derived. Numerical examples are presented to illustrate the applicability of the models.', NULL);
INSERT INTO `list` VALUES (10696, '0000', 1998, 'inproceedings', 'Garg, S. and van Moorsel, A. and Vaidyanathan, K. and Trivedi, K.S.', 'A methodology for detection and estimation of software aging', '度量&Measurement-based', NULL, '1998 Proceedings Ninth International Symposium on Software Reliability Engineering (Cat. No.98TB100257)', 'ISSRE', NULL, NULL, '283--292', NULL, '10.1109/ISSRE.1998.730892', 'Software Aging and Rejuvenation', 'The phenomenon of software aging refers to the accumulation of errors during the execution of the software which eventually results in it\'s crash/hang failure. A gradual performance degradation may also accompany software aging. Pro-active fault management techniques such as \"software rejuvenation\" (Y. Huang et al., 1995) may be used to counteract aging if it exists. We propose a methodology for detection and estimation of aging in the UNIX operating system. First, we present the design and implementation of an SNMP based, distributed monitoring tool used to collect operating system resource usage and system activity data at regular intervals, from networked UNIX workstations. Statistical trend detection techniques are applied to this data to detect/validate the existence of aging. For quantifying the effect of aging in operating system resources, we propose a metric: \"estimated time to exhaustion\", which is calculated using well known slope estimation techniques. Although the distributed data collection tool is specific to UNIX, the statistical techniques can be used for detection and estimation of aging in other software as well.', NULL);
INSERT INTO `list` VALUES (10697, '0000', 1996, 'inproceedings', 'Garg, Sachin and Huang, Yennun and Kintala, Chandra and Trivedi, Kishor S.', 'Minimizing completion time of a program by checkpointing and rejuvenation', 'rej&other', NULL, '1996 Proceedings of the 1996 ACM SIGMETRICS international conference on Measurement and modeling of computer systems  - SIGMETRICS \'96', 'SIGMETRICS', NULL, NULL, '252--261', 'ACM Press', '10.1145/233013.233050', 'Software Aging and Rejuvenation', 'Checkpointing with rollback-recovery is a well known technique to reduce the completion time of a program in the presence of failures. While checkpointing is corrective in nature, rejuvenation refers to preventive maintenance of software aimed to reduce unexpected failures mostly resulting from the \"aging\" phenomenon. In this paper, we show how both these techniques may be used together to further reduce the expected completion time of a program. The idea of using checkpoints to reduce the amount of rollback upon a failure is taken a step further by combining it with rejuvenation. We derive the equations for expected completion time of a program with finite failure free running time for the following three cases when; (a) neither checkpointing nor rejuvenation is employed, (b) only checkpointing is employed, and finally (c) both checkpointing and rejuvenation are employed.We also present numerical results for Weibull failure time distribution for the above three cases and discuss optimal checkpointing and rejuvenation that minimizes the expected completion time. Using the numerical results, some interesting conclusions are drawn about benefits of these techniques in relation to the nature of failure distribution.', NULL);
INSERT INTO `list` VALUES (10698, '0000', 1996, 'inproceedings', 'Garg, S. and Van, M. A.', 'Towards Performability Modeling of Software Rejuvenation', 'Model-based', NULL, '1996 Computer Science', 'CS', NULL, NULL, NULL, NULL, 'https://www.semanticscholar.org/paper/Towards-Performability-Modeling-of-Software-Garg-Van/984b0fdd90caf2d0141ab9f6aecf5069b3c291c0', 'Software Aging and Rejuvenation', 'In this paper, we discuss issues in performability modeling of {\\textbackslash}software rejuvenation,\" a form of software fault tolerance based on occasionally cleaning up the operational environment. System factors which play a key role in such a model are identi ed. Among these, we comment on two issues of particular interest when modeling software rejuvenation: (1) the representation of the degradation in operational environment, and, (2) the inclusion in the model of the system monitor, on which the decision to rejuvenate is based. We also survey how each of these factors have been accounted for in previous performability models and show possible directions for future work.', NULL);
INSERT INTO `list` VALUES (10699, '0000', 2003, 'article', 'Ghoneim, Salma A.', 'Evaluation of the DRM and the Time for Preventive Maintenance for Aging Software', '度量&Model-based', NULL, '2003 Software Quality Journal', 'Softw Qual J', '11', '1', '57--75', NULL, '10.1023/A:1023636112886', 'Software Aging and Rejuvenation', 'An attempt to capture software aging and specify when to do preventive maintenance (PM) is presented in this paper. A composite measure termed the DRM, Deteriorating Response Measure, is defined. It is based on the analysis of the deteriorating speed of the software against time and load. This speed is characterized as follows: (1) It decays with increased load. (2) It does not increase again when the load decreases, this indicates “loss of elasticity.” The DRM is mathematically formulated based on a queueing system model.Specifying when to do preventive maintenance depends on the decision maker\'s perspective of the manifestation of aging. It is tried here to formalize this dependence. Three degrading performance metrics are defined for a DRM: (1) Decaying restored speed value. (2) Increasing speed offset ratio (recoverability index). (3) Increasing operation interval offset. These metrics can be used singly or aggregately in a DRM to specify when to do preventive maintenance. Results of model testing are also shown.This work can be part of an on-line procedure that calculates performance indexes for a server type software system like a web browser, an operating system, a database, and helps in the decision to do preventive maintenance for aging software.', NULL);
INSERT INTO `list` VALUES (10700, '0000', 2006, 'article', 'Grottke, M. and Li, L. and Vaidyanathan, K. and Trivedi, K.S.', 'Analysis of Software Aging in a Web Server', 'Measurement-based', NULL, '2006 IEEE Trans. Rel.', 'Trans. Rel.', '55', '3', '411--420', NULL, '10.1109/TR.2006.879609', 'Software Aging and Rejuvenation', 'Several recent studies have reported \\& examined the phenomenon that long-running software systems show an increasing failure rate and/or a progressive degradation of their performance. Causes of this phenomenon, which has been referred to as \"software aging\", are the accumulation of internal error conditions, and the depletion of operating system resources. A proactive technique called \"software rejuvenation\" has been proposed as a way to counteract software aging. It involves occasionally terminating the software application, cleaning its internal state and/or its environment, and then restarting it. Due to the costs incurred by software rejuvenation, an important question is when to schedule this action. While periodic rejuvenation at constant time intervals is straightforward to implement, it may not yield the best results. The rate at which software ages is usually not constant, but it depends on the time-varying system workload. Software rejuvenation should therefore be planned \\& initiated in the face of the actual system behavior. This requires the measurement, analysis, and prediction of system resource usage. In this paper, we study the development of resource usage in a web server while subjecting it to an artificial workload. We first collect data on several system resource usage \\& activity parameters. Non-parametric statistical methods are then applied toward detecting \\& estimating trends in the data sets. Finally, we fit time series models to the data collected. Unlike the models used previously in the research on software aging, these time series models allow for seasonal patterns, and we show how the exploitation of the seasonal variation can help in adequately predicting the future resource usage. Based on the models employed here, proactive management techniques like software rejuvenation triggered by actual measurements can be built', NULL);
INSERT INTO `list` VALUES (10701, '0000', 2005, 'inproceedings', 'Grottke, Michael and Trivedi, Kishor S.', 'A Classification of Software Faults', NULL, NULL, '2005 Supplemental Proc. Sixteenth International IEEE Symposium on Software Reliability Engineering', 'ISSRE', NULL, NULL, '4.19--4.20', 'IEEE', 'https://scholar.google.com.hk/scholar?hl=zh-CN&as_sdt=0%2C5&as_vis=1&q=A+Classification+of+Software+Faults&btnG=', 'Software Aging and Rejuvenation', NULL, NULL);
INSERT INTO `list` VALUES (10702, '0000', 2010, 'inproceedings', 'Grottke, Michael and Nikora, Allen P. and Trivedi, Kishor S.', 'An empirical investigation of fault types in space mission system software', '分析bug报告&Classification', NULL, '2010 IEEE/IFIP International Conference on Dependable Systems & Networks (DSN)', 'DSN', NULL, NULL, '447--456', NULL, '10.1109/DSN.2010.5544284', 'Software Aging and Rejuvenation', 'As space mission software becomes more complex, the ability to effectively deal with faults is increasingly important. The strategies that can be employed for fighting a software bug depend on its fault type. Bohrbugs are easily isolated and removed during software testing. Mandelbugs appear to behave chaotically. While it is more difficult to detect these faults during testing, it may not be necessary to correct them; a simple retry after a failure occurrence may work. Aging-related bugs, a sub-class of Mandelbugs, can cause an increasing failure rate. For these faults, proactive techniques may prevent future failures. In this paper, we analyze the faults discovered in the on-board software for 18 JPL/NASA space missions. We present the proportions of the various fault types and study how they have evolved over time. Moreover, we examine whether or not the fault type and attributes such as the failure effect are independent.', NULL);
INSERT INTO `list` VALUES (10703, '0000', 2008, 'inproceedings', 'Grottke, Michael and Matias, Rivalino and Trivedi, Kishor S.', 'The fundamentals of software aging', '逻辑分析', NULL, '2008 IEEE International Conference on Software Reliability Engineering Workshops (ISSRE Wksp)', 'ISSREW', NULL, NULL, '1--6', 'IEEE', '10.1109/ISSREW.2008.5355512', 'Software Aging and Rejuvenation', 'Since the notion of software aging was introduced thirteen years ago, the interest in this phenomenon has been increasing from both academia and industry. The majority of the research efforts in studying software aging have focused on understanding its effects theoretically and empirically. However, conceptual aspects related to the foundation of this phenomenon have not been covered in the literature. This paper discusses foundational aspects of the software aging phenomenon, introducing new concepts and interconnecting them with the current body of knowledge, in order to compose a base taxonomy for the software aging research. Three real case studies are presented with the purpose of exemplifying many of the concepts discussed.', NULL);
INSERT INTO `list` VALUES (10704, '0000', 2015, 'inproceedings', 'Guo, Chunhui and Wu, Hao and Hua, Xiayu and Lautner, Douglas and Ren, Shangping', 'Use Two-Level Rejuvenation to Combat Software Aging and Maximize Average Resource Performance', 'rej&Measurement-based', NULL, '2015 IEEE 17th International Conference on High Performance Computing and Communications, 2015 IEEE 7th International Symposium on Cyberspace Safety and Security, and 2015 IEEE 12th International Conference on Embedded Software and Systems', 'CSS/ICESS', NULL, NULL, '1160--1165', NULL, '10.1109/HPCC-CSS-ICESS.2015.306', 'Software Aging and Rejuvenation', 'Software aging is a common phenomenon which is often manifested through system performance degradation. Rejuvenation is one of the most commonly used approaches to handle issues caused by software aging. To combat resource performance degradation and at the same time maintain maximized average resource performance, we present a two-level rejuvenation strategy, i.e., interleaving a set of n warm rejuvenations with one cold rejuvenation. Our target is to find the optimal n that maximizes system average performance. We first define a resource model that takes into consideration of performance degradation and two-level rejuvenations. Based on the resource model, we formally analyze the resource supply and present the MAX-PERFORMANCE algorithm to determine the optimal rejuvenation pattern that maximizes the average resource performance. The simulation results show that with a two-level rejuvenation strategy, we can achieve 25.22\\% higher average resource performance compared with a single level rejuvenation strategy.', NULL);
INSERT INTO `list` VALUES (10705, '0000', 2010, 'inproceedings', 'Hanmer, Robert S. and Mendiratta, Veena B.', 'Rejuvenation with workload migration', 'Model-based', NULL, '2010 International Conference on Dependable Systems and Networks Workshops (DSN-W)', 'DSN-W', NULL, NULL, '80--85', NULL, '10.1109/DSNW.2010.5542617', 'Software Aging and Rejuvenation', 'A five-state model of software rejuvenation is introduced that divides the working state into three sub-states: working, vulnerable, and preparing. The preparing state models the period during which workload is drained from software elements that are about to be rejuvenated. We compared our model to a four-state model that only has working and vulnerable sub-states.', NULL);
INSERT INTO `list` VALUES (10706, '0000', 2020, 'inproceedings', 'Hao, Zeming and Liu, Jing', 'GAN-ASD: Precise Software Aging State Detection for Android System Based on BEGAN Model and State Clustering', 'Measurement-based（ML）', NULL, '2020 20th IEEE/ACM International Symposium on Cluster, Cloud and Internet Computing (CCGRID)', 'DSN-W', NULL, NULL, '212--221', 'IEEE', '10.1109/CCGrid49817.2020.00-72', 'Software Aging and Rejuvenation', 'Software applications may become no response or stop running due to performance degradation, system crashes, or program cumulative failures, after long-term execution in Android system. These phenomena have been validated to be common in mobile systems which is caused by software aging. To handle the software aging dilemma, software rejuvenation is an efficient way. In order to make rejuvenation more efficient, identifying the aging state of Android system precisely is the key point. In this paper, we propose a novel Android system aging state detection method based on the Boundary Equilibrium Generative Adversarial Network (BEGAN) and state clustering technology, which is named as GAN-ASD. The method has three phases: Firstly, Interpolation Clipping Processing is used to processes the time series dataset which is constituted by the sample of Android Aging Indicators. Secondly, according to the time series dataset, BEGAN based generation method will fit the user\'s usage habits and generate the dataset which has software aging characteristics. At last, we use the generative dataset to train a K-Means clustering model. With the trained model, we can precisely determine whether the current Android system enters into the aging state or remains in the normal state. In order to validate the effectiveness of the GAN-ASD, we use two evaluation criterion in our comparison experiment. One is rejuvenation coefficient (RC) which evaluates the user experience and the other one is rejuvenation frequency (RF) which evaluates the rejuvenation cost. The results show that our method performs better than the fixed-interval rejuvenation and random rejuvenation operations.', NULL);
INSERT INTO `list` VALUES (10707, '0000', 2008, 'inproceedings', 'He, Xin and Wei, Wei and Gui, Xiaolin', 'The Software Rejuvenation Model with Pre-start Technology', 'rej', NULL, '2008 International Symposiums on Information Processing', 'CCGRID', NULL, NULL, '723--727', 'IEEE', '10.1109/ISIP.2008.19', 'Software Aging and Rejuvenation', 'Software aging related failures can be prevented by applying software rejuvenation technology. But the restart operation in the software rejuvenation phase makes the system unable to provide services, which leads to system unavailability. The software rejuvenation model with pre-start technology is therefore proposed to reduce downtime and improve availability by switching between active copy and backup copy, which can substitute for restart operation and resolve unavailability problem. First of all, the rejuvenation operation of model with pre-start technology is described and improvements on the conventional model are presented. Second, the model availability is calculated by Markov Regenerative process. And finally, according to the experimental results, current model proves to be more available than the conventional one.', NULL);
INSERT INTO `list` VALUES (10708, '0000', 2007, 'article', 'Hoffmann, Guenther A. and Trivedi, Kishor S. and Malek, Miroslaw', 'A Best Practice Guide to Resource Forecasting for Computing Systems', 'Measurement-based（ML）', NULL, '2007 IEEE Transactions on Reliability', 'Trans. Rel.', '56', '4', '615--628', NULL, '10.1109/TR.2007.909764', 'Software Aging and Rejuvenation', 'Recently, measurement-based studies of software systems have proliferated, reflecting an increasingly empirical focus on system availability, reliability, aging, and fault tolerance. However, it is a nontrivial, error-prone, arduous, and time-consuming task even for experienced system administrators, and statistical analysts to know what a reasonable set of steps should include to model, and successfully predict performance variables, or system failures of a complex software system. Reported results are fragmented, and focus on applying statistical regression techniques to monitored numerical system data. In this paper, we propose a best practice guide for building empirical models based on our experience with forecasting Apache web server performance variables, and forecasting call availability of a real-world telecommunication system. To substantiate the presented guide, and to demonstrate our approach in a step by step manner, we model, and predict the response time, and the amount of free physical memory of an Apache web server system, as well as the call availability of an industrial telecommunication system. Additionally, we present concrete results for a) variable selection where we cross benchmark three procedures, b) empirical model building where we cross benchmark four techniques, and c) sensitivity analysis. This best practice guide intends to assist in configuring modeling approaches systematically for best estimation, and prediction results.', NULL);
INSERT INTO `list` VALUES (10709, '0000', 2015, 'inproceedings', 'Hua, Xiayu and Guo, Chunhui and Wu, Hao and Lautner, Douglas and Ren, Shangping', 'Schedulability Analysis for Real-Time Task Set on Resource with Performance Degradation and Periodic Rejuvenation', 'Model-based', NULL, '2015 IEEE 21st International Conference on Embedded and Real-Time Computing Systems and Applications', 'RTCSA', NULL, NULL, '197--206', NULL, '10.1109/RTCSA.2015.16', 'Software Aging and Rejuvenation', 'Most schedulability analyses in the literature assume that the performance of computing resource does not change over time. However, due to ever increased complexity of computer systems, software aging issues become more difficult, if not impossible, to eradicate. Hence, the assumption that computing resource has a constant performance in its entire lifetime does not hold in real world long-standing systems. In this paper, we study real-time task schedulability under a resource model that the resource\'s performance degrades with a known degradation function and the resource is periodically rejuvenated. The resource model is referred to as P2-resource model for performance degradation and periodic rejuvenation. We address three real-task schedulability related questions under the P2-resource model, i.e., (1) resource supply bounds of the P2-resource, (2) task set utilization bounds under Earliest Deadline First (EDF) and Rate Monotonic (RM) scheduling policies, respectively, and (3) experimentally study the tightness of the bounds developed, and the impact of resource degradation rate, rejuvenation period, and rejuvenation cost on the bounds.', NULL);
INSERT INTO `list` VALUES (10710, '0000', 2017, 'article', 'Hua, Xiayu and Guo, Chunhui and Wu, Hao and Lautner, Douglas and Ren, Shangping', 'Schedulability Analysis for Real-Time Task Set on Resource with Performance Degradation and Dual-Level Periodic Rejuvenations', 'Model-based', NULL, '2017 IEEE Trans. Comput.', 'Trans. Comput', '66', '3', '553--559', NULL, '10.1109/TC.2016.2602833', 'Software Aging and Rejuvenation', 'Researches in real-time scheduling often assume that the performance of a computing resource does not change over time. However, as system softwares and system architectures become increasingly complex, resource performance degradation over time becomes more evident. In this paper, we study the schedulability of a hard real-time task set on a resource which has performance degradation over time with a known pattern and use both cold and warm periodic rejuvenations as countermeasures. Such resource model is referred to as \\&lt;inline-formula\\&gt;\\&lt;tex-math notation=\"LaTeX\"\\&gt; \\$P{\\textasciicircum}2D\\$\\&lt;/tex-math\\&gt;\\&lt;alternatives\\&gt;\\&lt;inline-graphic xlink:href=\"hua-ieq1-2602833.gif\"/\\&gt;\\&lt;/alternatives\\&gt;\\&lt;/inline-formula\\&gt; -resource model for \\&lt;underline\\&gt;p\\&lt;/underline\\&gt;erformance degradation and \\&lt;underline\\&gt;p\\&lt;/underline\\&gt;eriodic rejuvenation with \\&lt;underline\\&gt;d\\&lt;/underline\\&gt;ual-levels. In this paper, we study (1) the formal specification of the \\&lt;inline-formula\\&gt;\\&lt;tex-math notation=\"LaTeX\"\\&gt;\\$P{\\textasciicircum}2D\\$\\&lt;/tex-math\\&gt;\\&lt;alternatives\\&gt; \\&lt;inline-graphic xlink:href=\"hua-ieq2-2602833.gif\"/\\&gt;\\&lt;/alternatives\\&gt;\\&lt;/inline-formula\\&gt;-resource model, (2) \\&lt;inline-formula\\&gt;\\&lt;tex-math notation=\"LaTeX\"\\&gt;\\$P{\\textasciicircum}2D\\$\\&lt;/tex-math\\&gt;\\&lt;alternatives\\&gt; \\&lt;inline-graphic xlink:href=\"hua-ieq3-2602833.gif\"/\\&gt;\\&lt;/alternatives\\&gt;\\&lt;/inline-formula\\&gt;-resource  supply analysis, and (3) task set utilization bounds of a \\&lt;inline-formula\\&gt;\\&lt;tex-math notation=\"LaTeX\"\\&gt;\\$P{\\textasciicircum}2D\\$\\&lt;/tex-math\\&gt;\\&lt;alternatives\\&gt; \\&lt;inline-graphic xlink:href=\"hua-ieq4-2602833.gif\"/\\&gt;\\&lt;/alternatives\\&gt;\\&lt;/inline-formula\\&gt;-resource under Earliest Deadline First (EDF) and Rate Monotonic (RM) scheduling policies.', NULL);
INSERT INTO `list` VALUES (10711, '0000', 1995, 'inproceedings', 'Huang, Y. and Kintala, C. and Kolettis, N. and Fulton, N.D.', 'Software rejuvenation: analysis, module and applications', 'Model-based', NULL, '1995 International Symposium on Fault-Tolerant Computing', 'ISFTC', NULL, NULL, '381--390', 'IEEE', '10.1109/FTCS.1995.466961', 'Software Aging and Rejuvenation', 'Software rejuvenation is the concept of gracefully terminating an application and immediately restarting it at a clean internal state. In a client-server type of application where the server is intended to ran perpetually for providing a service to its clients, rejuvenating the server process periodically during the most idle time of the server increases the availability of that service. In a long-running computation-intensive application, rejuvenating the application periodically and restarting it at a previous checkpoint increases the likelihood of successfully completing the application execution. We present a model for analyzing software rejuvenation in such continuously-running applications and express downtime and costs due to downtime during rejuvenation in terms of the parameters in that model. Threshold conditions for rejuvenation to be beneficial are also derived. We implemented a reusable module to perform software rejuvenation. That module can be embedded in any existing application on a UNIX platform with minimal effort. Experiences with software rejuvenation in a billing data collection subsystem of a telecommunications operations system and other continuously-running systems and scientific applications in AT\\&T are described.{\\textless}{\\textgreater}', NULL);
INSERT INTO `list` VALUES (10712, '0000', 2021, 'inproceedings', 'Huo, Huixia and Chen, Zhuoqian and Xu, Houbao', 'Dynamic Analysis of the Software Rejuvenation System with Degradation Levels', 'Model-based', NULL, '2021 40th Chinese Control Conference (CCC)', 'CCC', NULL, NULL, '843--848', NULL, '10.23919/CCC52363.2021.9549437', 'Software Aging and Rejuvenation', 'A preemptive rollback policy called software rejuvenation, as an effective tool to improve the performance of the software system, has been widely discussed on the premise that all states of the system follow the exponential distribution. However, the research on the software rejuvenation system with nonexponential repair time is very limited. This paper aims to study the dynamic behavior and evaluation index of the software rejuvenation system with general repair time. Firstly, we establish a software rejuvenation system by assigning a performance capacity level in each of the possible states, and formulate the system with an abstract Cauchy problem. Then the well-posedness of the system is proved by using cofinal theory and analyzing the spectral distribution of the system operators, and the expression of the system overall performance capacity as an important evaluation index is also given. In addition, an approximate system is constructed and the dynamical solution of the software rejuvenation system is obtained as the limit of the approximate system dynamical solution. At last, numerical examples are presented to illustrate dynamic behavior of the system and the influence of the the evaluation index on the rejuvenation strategy.', NULL);
INSERT INTO `list` VALUES (10713, '0000', 2018, 'inproceedings', 'Huo, Shouyu and Zhao, Dongdong and Liu, Xing and Xiang, Jianwen and Zhong, Yingshou and Yu, Haiguo', 'Using Machine Learning for Software Aging Detection in Android System', '度量&Measurement-based（ML）', NULL, '2018 Tenth International Conference on Advanced Computational Intelligence (ICACI)', 'ICACI', NULL, NULL, '741--746', 'IEEE', '10.1109/ICACI.2018.8377553', 'Software Aging and Rejuvenation', 'Software aging is a common experience in Android operating system, as the gradual performance degradation is usually complained by the users. However, the mathematical modelling and detection of such experience is still an emerging issue due to the complexity and relatively young age of Android. This paper applies and compares three machine learning algorithms, namely decision tree, Support Vector Machine (SVM), and Deep Belief Network (DBn), for the detection of software aging in Android. In addition to the traditional aging indicator of launch time (LT), this paper also investigates the effectiveness of page fault (PF) and multiple labels (i.e., the combination of LT and PF). Experimental results show that the accuracy of DBN is comparable to decision tree and SVM when the data volume increases to 5000, which means DBN and other similar algorithms suitable for high dimensional and large data may also play a role in software aging. The results also reveal that PF is a little more stable than LT in terms of variance of accuracy, and it can also be used a good indicator for aging of Android. However, the performance of multiple labels is not improved in our experiments. The observations of this paper are supposed to assist further analysis of software aging in Android and the design of corresponding rejuvenation methods.', NULL);
INSERT INTO `list` VALUES (10714, '0000', 2007, 'inproceedings', 'Rinsaka, Koichiro and Dohi, Tadashi', 'A Faster Estimation Algorithm for Periodic Preventive Rejuvenation Schedule Maximizing System Availability', NULL, NULL, '2007 Proceedings of the 4th international symposium on Service Availability', 'ISAS', '4526', NULL, '94--109', 'Springer Berlin Heidelberg', '10.1007/978-3-540-72736-1_9', 'Software Aging and Rejuvenation', 'It is of great importance to perform preventive rejuvenation of software systems with service degradation. In this paper we develop a faster estimation algorithm for the optimal periodic rejuvenation schedule which maximizes the steady-state system availability. In the case with unknown system failure time distribution, a non-parametric estimation approach based on the empirical distribution of system failure time has been proposed in the literature, but often failed to obtain the exact estimates for the small sample cases. We improve the existing availability estimation algorithm in terms of convergence speed and derive the more eﬀective estimation scheme based on the kernel density of system failure time. Throughout simulation experiments, the proposed estimation scheme is compared with the existing approach and can be validated in the sense of asymptotic optimality.', NULL);
INSERT INTO `list` VALUES (10715, '0000', 2022, 'article', 'Jang, Eun-Tae and Baek, Sung Hoon and Park, K.', 'Aging Analysis Framework of Windows-Based Systems through Differential-Analysis of System Snapshots', 'testing', NULL, '2022 Computers, Materials & Continua', 'CMC', NULL, NULL, NULL, NULL, '10.32604/cmc.2022.026663', 'Software Aging and Rejuvenation', 'In the proposed system aging analysis framework, the framework aims to forcibly age a Windows-based system by repeating the software installation/removal operation by utilizing the system forced aging module. : When a Windows-based system is used for an exceedingly long time, its performance degrades, and the error occurrence rate tends to increase. This is generally called system aging. To investigate the reasons for system aging, various studies have been conducted within the range of the operating system kernel to the user application. However, finding an accurate reason for system performance degradation remains challenging research topic. In this study, system monitoring was conducted by dividing a system into ‘before software installation,’ ‘after software installation,’ and ‘after software removal.’ We confirmed that when a software installed in a system is removed, various system elements, such as storage and memory, are not restored to the level prior to the software installation. Consequently, we established a hypothesis regarding the performance degradation of a computer system owing to repeated software installation/removal operations, investigated the correlation between system aging and repeated software installation/removal operations, and proposed a system aging analysis framework for analyzing the reason behind system aging. In the proposed system aging analysis framework, we aim to forcibly age a Windows-based system by repeating the software installation/removal operation by utilizing the system forced aging module. The framework identifies the elements affecting system performance through a differential data analysis of the system time-series data extracted by the system performance extraction and system component snapshot modules. Consequently, the aging analysis framework presented in this study is expected to be effectively utilized as an index for studying', NULL);
INSERT INTO `list` VALUES (10716, '0000', 2008, 'article', 'Jia, Yun-Fei and Su, Jing-Ya and Cai, Kai-Yuan', 'A feedback control approach for software rejuvenation in a web server', '度量&rej', NULL, '2008 IEEE International Conference on Software Reliability Engineering Workshops (ISSRE Wksp)', 'ISSREW', NULL, NULL, '1--6', NULL, '10.1109/ISSREW.2008.5355514', 'Software Aging and Rejuvenation', 'Software aging refers to the phenomenon that applications will show growing failure rate or performance degradation after longtime execution. This phenomenon usually results from the accumulation of error conditions, such as memory leaks, round-off errors, file tables not released, etc. Unexpected downtime cost due to software aging is huge, particularly for e-commerce Websites and safety/business-critical applications. Software rejuvenation is an effective but expensive fault tolerance technique to deal with software aging phenomenon. This technique usually involves the termination of services due to the restart of computer systems. In this paper, a ¿lightweight¿ complementary technique of software rejuvenation is proposed to reduce the severity of software aging in terms of its impact on system resource usage by online tuning the settings of related parameters. Unlike traditional software restart involved in traditional rejuvenation, this technique is based on the idea of fine adjustment of software state. Experiments are conducted to reveal the relationship between certain parameters of Web server and resource usage. Accordingly, a PI (proportional-integral) controller is designed to online tune the parameters of web server with the purpose of counteracting the effect of software aging. Simulation results show that the technique is cost-effective.', NULL);
INSERT INTO `list` VALUES (10717, '0000', 2022, 'inproceedings', 'Jia, Kai and Yu, Xiao and Zhang, Chen and Hu, Wenhua and Zhao, Dongdong and Xiang, Jianwen', 'The Impact of Software Aging and Rejuvenation on the User Experience for Android System', 'Model-based', NULL, '2022 IEEE 33rd International Symposium on Software Reliability Engineering (ISSRE)', 'ISSRE', NULL, NULL, '435--445', NULL, '10.1109/ISSRE55969.2022.00049', 'Software Aging and Rejuvenation', 'In the Android system, software aging is an essential factor affecting user experience. Its occurrence will lead to poor responsiveness or crash/hang failure of the system. Recently, the strategies to schedule rejuvenation are marching toward a situation that needs to consider both usage behavioral aspects of its users (i.e., switch between active and sleep modes) and two-level software aging process (i.e., Operating System (OS) and Application Software (AS)), because rejuvenating the OS or AS during active time slot contributes to terrible user experience. To be able to achieve higher user experience and lower user interference, in this paper, we present to employ the Continuous Time Markov Chain (CTMC) model to study the impact of software aging and rejuvenation on user experience on two different rejuvenation strategies: condition-based and time-based rejuvenations. In contrast to the existing works, our models capture the interactions between usage behavioral aspects of users and two-level aging and rejuvenation. We then define three metrics to evaluate the user experience, including User-perceived (1) Fluency (UF), (2) Failure Probability (UFP), and (3) Availability (UA). The numerical analysis has the following noticed conclusions. The optimal value of UF yielded by condition-based rejuvenation reaches a 3.486\\% improvement over that of time-based. Therefore, the former is an appealing rejuvenation solution. Moreover, compared with single-level (OS and AS) rejuvenation models, two-level rejuvenation indeed improves the user experience. Concretely, the values of three metrics achieve 80.20\\% and 14.45\\%,83.39\\% and 98.45\\%, 0.004\\% and 0.048\\% improvements, respectively.', NULL);
INSERT INTO `list` VALUES (10718, '0000', 2008, 'inproceedings', 'Jia, Yun-Fei and Zhao, Lei and Cai, Kai-Yuan', 'A Nonlinear Approach to Modeling of Software Aging in a Web Server', '现象分析&Measurement-based', NULL, '2008 15th Asia-Pacific Software Engineering Conference', 'APSEC', NULL, NULL, '77--84', NULL, '10.1109/APSEC.2008.38', 'Software Aging and Rejuvenation', 'Software aging refers to the phenomenon that the performance degradation, increasing failure rate or massive resource usage demonstrated in long-running software systems such as web servers. It was reported that software aging has a significant relationship with resource usage. To study the software aging phenomenon in web servers, we built an experimental platform with a server and multiple clients to collect the data of system resource usage on the server. In this paper, we present several experiments based on the platform and study software aging phenomenon of a widely used web server software system - the Apache HTTP server. Some repeatable software aging phenomena are observed in our experiments. The process of software aging is shown to be nonlinear and chaotic. In order to better present the nonlinear interplay of various resource parameters of web server and forecast resource exhaustion, a nonlinear dynamic model of software aging is constructed to formulate software aging process.', NULL);
INSERT INTO `list` VALUES (10719, '0000', 2008, 'article', 'Jia, Yun-Fei and Chen, Xiu-E and Zhao, Lei and Cai, Kai-Yuan', 'On the Relationship between Software Aging and Related Parameters (Short Paper)', '度量&rej', NULL, '2008 The Eighth International Conference on Quality Software', 'QSIC', NULL, NULL, '241--246', NULL, '10.1109/QSIC.2008.54', 'Software Aging and Rejuvenation', 'Software aging refers to the phenomenon that long-running software shows signs of increasing failing rate, overmuch resource usage, and performance degradation. Software rejuvenation is a proactive approach to dealing with this problem. However, commonly used rejuvenation methods involve a relatively larger overhead. An alternative is to reduce the severity of software aging by online adjusting the settings of related parameters of the system. In this paper, we conduct controlled experiments to analyze severity of software aging under different settings of related parameters. Based on the experimental data, a metric is defined to measure the severity of software aging. A multiple-input and multiple-output (MIMO) model is then constructed to formulate the relationship between severity of software aging and related parameter settings. The proposed MIMO model gives us a way to control the severity of software aging at runtime.', NULL);
INSERT INTO `list` VALUES (10720, '0000', 2017, 'article', 'Jia, Shiqing and Hou, Chunyan and Wang, Jinsong', 'Software aging analysis and prediction in a web server based on multiple linear regression algorithm', 'Measurement-based', NULL, '2017 IEEE 9th International Conference on Communication Software and Networks (ICCSN)', 'ICCSN', NULL, NULL, '1452--1456', NULL, '10.1109/ICCSN.2017.8230349', 'Software Aging and Rejuvenation', 'In the last few years, software aging has been reported. The phenomenon of software aging is that the performance of the software system is degradation in a long-running state, which is the result of exhaustion of system resources, the accumulation of internal error conditions and so on. In order to counteract software aging, a technique, which called software rejuvenation, has been proposed, this procedure involves occasionally stopping a system process, cleaning its running environment and restarting it. Due to the direct and indirect costs incurred by software rejuvenation, when to carry out this action is very important. Traditionally, most scholars focused on time series or analytic methods to model software aging process, however, machine learning algorithm has been neglected. In this paper, we make a detailed analysis and predict about the web server parameters by multiple linear regression algorithm. Firstly, the aging phenomenon of the system is simulated by the pressure testing tool and then collecting data and preprocessed. Secondly, we fit time series models to the data collected and determine the trend of resource consumption. Thirdly, using the feature selection algorithm to select a subset set as the input parameters of the algorithm. Fourthly, using the multiple linear regression algorithm to analysis and predict the aging process. Finally, we evaluate the feasibility of the algorithm by evaluation metrics. The result shows that we can use this algorithm to predict the aging process in the allowable error range.', NULL);
INSERT INTO `list` VALUES (10721, '0000', 2005, 'inproceedings', 'Jian Xu and Jing You and Kun Zhang', 'A Neural-Wavelet based Methodology for Software Aging Forecasting', 'Measurement-based（ML）', NULL, '2005 IEEE International Conference on Systems, Man and Cybernetics', 'SMC', '1', NULL, '59--63', NULL, '10.1109/ICSMC.2005.1571122', 'Software Aging and Rejuvenation', 'A number of recent studies have reported the phenomenon of \"software aging\", characterized by progressive performance degradation and a sudden crash/hang of a software system due to exhaustion of operating system resources, fragmentation and accumulation of errors. To counteract this phenomenon, this paper proposed a novel four-stage method for software aging forecast in operation. The prior data of software performance parameters are treated as time series. The forecast method combines wavelet multiresolution decomposition and neural networks. First, we apply a smoothing unit based on the wavelet multiresolution analysis to reduce the influence of noise. Second, the special performance data is decomposed into different scales by nondecimated Haar wavelet decomposition. Third, each scale is predicted by a separate neural network. Lastly, the next sample of the original time series is predicted by another neural network. The proposed method is tested using the performance parameters data collected from a realistic software system to evaluate the forecasting performance.', NULL);
INSERT INTO `list` VALUES (10722, '0000', 2007, 'article', 'Jiang, Letian and Xu, Guozhi', 'Modeling and analysis of software aging and software failure', 'Hybrid', NULL, '2007 Journal of Systems and Software', 'JSS', '80', '4', '590--595', NULL, '10.1016/j.jss.2006.06.029', 'Software Aging and Rejuvenation', 'Semantic Scholar extracted view of \"Modeling and analysis of software aging and software failure\" by Letian Jiang et al.', NULL);
INSERT INTO `list` VALUES (10723, '0000', 2010, 'inproceedings', 'Jiang, Letian and Peng, Xiangyu and Xu, Guozhi', 'Time and Prediction based Software Rejuvenation Policy', 'Hybrid', NULL, '2010 Second International Conference on Information Technology and Computer Science', 'ICITCS', NULL, NULL, '114--117', NULL, '10.1109/ITCS.2010.34', 'Software Aging and Rejuvenation', 'Operational software systems often experience an “aging” phenomenon, characterized by progressive performance degradation and a sudden hang/crash failure. Software rejuvenation is a proactive fault-tolerance strategy aimed to prevent unexpected outages due to aging. Existing rejuvenation approaches can be largely classified into two types: Purely Time based software rejuvenation policy (PTSRP) and Purely Prediction based Software rejuvenation policy (PPSRP). In this paper, combining the merits of these two policies, a new rejuvenation policy, Time and Prediction based Software Rejuvenation Policy (TPSRP), is proposed. In this policy, time based rejuvenation policy is performed from the system\'s start or restart, during which prediction based policy is also employed. To evaluate the effectiveness of this new policy, system availability and Downtime cost is adopted and a stochastic reward net model is built. Numerical results show that under the same conditions, TPSRP can achieve higher availability and lower downtime cost than both the PTSRP and PPSRP.', NULL);
INSERT INTO `list` VALUES (10724, '0000', 2010, 'inproceedings', 'Jun Guo and Weiyue Li and Xinya Song and Bin Zhang and Yunsheng Wang', 'Software Rejuvenation Strategy Based on Components', 'rej&Measurement-based（阈值DOSA）', NULL, '2010 Second World Congress on Software Engineering', 'WCSE', NULL, NULL, '80--83', NULL, '10.1109/WCSE.2010.113', 'Software Aging and Rejuvenation', 'Since Component-Based Software Development technology has been widely used, traditional software rejuvenation strategy seems too rough on solving Component-Software aging, the whole system will be regenerated even only a few components aging, which leads to high cost of software rejuvenation and reduces the stability of the system. Therefore, we propose a component-based software rejuvenation strategy and we make components be the objects of rejuvenation. The aging components will be rejuvenated when software ages. In this paper, the process of judging software aging and software rejuvenation are described, then we propose the methods of judging software aging, determining the sequence that the aging components to be rejuvenated and rejuvenating components. Finally, an experiment is done to certify the efficiency of the strategy.', NULL);
INSERT INTO `list` VALUES (10725, '0000', 2021, 'article', 'Khanna, Megha and Aggarwal, Mehak and Singhal, Naman', 'Empirical Analysis of Artificial Immune System Algorithms for Aging Related Bug Prediction', 'other', NULL, '2021 7th International Conference on Advanced Computing and Communication Systems (ICACCS)', 'ICACCS', NULL, NULL, NULL, NULL, '10.1109/ICACCS51430.2021.9441809', 'Software Aging and Rejuvenation', 'An empirical study that statistically analyzes the effectiveness of AIS classifiers for ARB prediction on five open-source software datasets and indicates the effectivenessof AIS algorithms for developing ARBs prediction models. The complex nature of human immunology algorithms has motivated the research community to explore their practical applications in various other fields. As a result, Artificial Immune Systems (AISs) is one such class of algorithms that has found its way into software quality predictive modeling. In this paper, we evaluate AIS algorithms for developing Aging-Related Bug (ARB) prediction models. Software Aging, the gradual degradation and resource exhaustion in software systems, is said to be caused by ARBs, which may or may not be identified during software testing. Therefore, predicting ARBs before software release can help software managers in reducing their impact. This paper presents an empirical study that statistically analyzes the effectiveness of AIS classifiers for ARB prediction on five open-source software datasets. In order to account for the imbalanced nature of the investigated datasets, we used resampling and cost-sensitive classifiers. The results of the study indicate the effectiveness of AIS algorithms for developing ARB prediction models.', NULL);
INSERT INTO `list` VALUES (10726, '0000', 2021, 'article', 'Khleel, Nasraldeen Alnor Adam and Nehéz, K.', 'Comprehensive Study on Machine Learning Techniques for Software Bug Prediction', 'other', NULL, '2021 International Journal of Advanced Computer Science and Applications', 'IJACSA', NULL, NULL, NULL, NULL, '10.14569/ijacsa.2021.0120884', 'Software Aging and Rejuvenation', 'The results of this study demonstrated that the proposed models performed better than other models that used the same data sets and show that machine learning algorithms can be used effectively for prediction of bugs. Software bugs are defects or faults in computer programs or systems that cause incorrect or unexpected operations. These negatively affect software quality, reliability, and maintenance cost; therefore many researchers have already built and developed several models for software bug prediction. Till now, a few works have been done which used machine learning techniques for software bug prediction. The aim of this paper is to present comprehensive study on machine learning techniques that were successfully used to predict software bug. Paper also presents a software bug prediction model based on supervised machine learning algorithms are Decision Tree (DT), Naïve Bayes (NB), Random Forest (RF) and Logistic Regression (LR) on four datasets. We compared the results of our proposed models with those of the other studies. The results of this study demonstrated that our proposed models performed better than other models that used the same data sets. The evaluation process and the results of the study show that machine learning algorithms can be used effectively for prediction of bugs. Keywords—Static code analysis; software bug prediction; software metrics; machine learning techniques', NULL);
INSERT INTO `list` VALUES (10727, '0000', 2009, 'article', 'Kintala, Chandra M.', 'Software Rejuvenation in Embedded Systems', 'Model-based', NULL, '2009 Journal of Automata', 'J Autom', 'Languages and Combinatorics', NULL, '6373', NULL, '10.25596/JALC-2009-063', 'Software Aging and Rejuvenation', 'Mobile communication devices have multitasking embedded software running in their\r\noperating systems (OS) as well as applications. Both the OS modules and the application \r\ncomponents are assigned predetermined memory in those devices due to near-realtime \r\nperformance requirements and lack of virtual memory. Memory (stack and\r\nheap) overflow problems occur in such software components because of programmer\'s\r\ninability to accurately estimate the size of the needed memory and also because of\r\nMandelbugs due to their complexity. A new software rejuvenation variation called Opportunistic \r\nMicro Rejuvenation (OMR) is proposed where a task that `misbehaves\' is\r\nidentified and rejuvenated at an opportune instant. Following the traditional model\r\nfor software rejuvenation, a Stochastic Area Network model is used to simulate and\r\nstudy the availability of such embedded systems with OMR. It is shown that OMR\r\nalone will increase the availability only slightly but when combined with other memory\r\nmanagement techniques, such as shared supplementary memory, OMR will increase the\r\navailability significantly.', NULL);
INSERT INTO `list` VALUES (10728, '0000', 2007, 'inproceedings', 'Kourai, Kenichi and Chiba, Shigeru', 'A Fast Rejuvenation Technique for Server Consolidation with Virtual Machines', 'rej', NULL, '2007 37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN\'07)', 'DSN', NULL, NULL, '245--255', NULL, '10.1109/DSN.2007.6', 'Software Aging and Rejuvenation', 'As server consolidation using virtual machines (VMs) is carried out, software aging of virtual machine monitors (VMMs) is becoming critical. Performance degradation or crash failure of a VMM affects all VMs on it. To counteract such software aging, a proactive technique called software rejuvenation has been proposed. A typical example of rejuvenation is to reboot a VMM. However, simply rebooting a VMM is undesirable because that needs rebooting operating systems on all VMs. In this paper, we propose a new technique for fast rejuvenation of VMMs called the warm-VM reboot. The warm-VM reboot enables efficiently rebooting only a VMM by suspending and resuming VMs without accessing the memory images. To achieve this, we have developed two mechanisms: on-memory suspend/resume of VMs and quick reload of VMMs. The warm- VM reboot reduces the downtime and prevents the performance degradation due to cache misses after the reboot.', NULL);
INSERT INTO `list` VALUES (10729, '0000', 2011, 'article', 'Kourai, Kenichi and Chiba, Shigeru', 'Fast Software Rejuvenation of Virtual Machine Monitors', 'rej', NULL, '2011 IEEE Transactions on Dependable and Secure Computing', 'TDSC', '8', '6', '839--851', NULL, '10.1109/TDSC.2010.20', 'Software Aging and Rejuvenation', 'As server consolidation using virtual machines (VMs) is carried out, software aging of virtual machine monitors (VMMs) is becoming critical. Since a VMM is fundamental software for running VMs, its performance degradation or crash failure affects all VMs running on top of it. To counteract such software aging, a proactive technique called software rejuvenation has been proposed. A simple example of rejuvenation is to reboot a VMM. However, simply rebooting a VMM is undesirable because that needs rebooting operating systems on all VMs. In this paper, we propose a new technique for fast rejuvenation of VMMs called the warm-VM reboot. The warm-VM reboot enables efficiently rebooting only a VMM by suspending and resuming VMs without saving the memory images to persistent storage. To achieve this, we have developed two mechanisms: on-memory suspend/resume of VMs and quick reload of a VMM. Compared with a normal reboot, the warm-VM reboot reduced the downtime by 74 percent at maximum. It also prevented the performance degradation due to cache misses after the reboot, which was 52 percent in case of a normal reboot. In a cluster environment, the warm-VM reboot achieved higher total throughput than the system using VM migration and a normal reboot.', NULL);
INSERT INTO `list` VALUES (10730, '0000', 2015, 'inproceedings', 'Kourai, Kenichi and Ooba, Hiroki', 'Zero-copy Migration for Lightweight Software Rejuvenation of Virtualized Systems', 'rej', NULL, '2015 Proceedings of the 6th Asia-Pacific Workshop on Systems', 'APSys', NULL, NULL, '1--8', 'Association for Computing Machinery', '10.1145/2797022.2797026', 'Software Aging and Rejuvenation', 'Virtualized systems tend to suffer from software aging, which is the phenomenon that the state of a running system degrades with time. Software aging is restored by a technique called software rejuvenation, e.g., a system reboot. To reduce the downtime due to software rejuvenation, all the virtual machines (VMs) on an aged virtualized system have to be migrated in advance. However, VM migration stresses the system and causes performance degradation. In this paper, we propose VMBeam, which enables lightweight software rejuvenation of virtualized systems using zero-copy migration. When rejuvenating an aged virtualized system, VMBeam starts a new virtualized system at the same host by using nested virtualization. Then it migrates all the VMs from the aged virtualized system to the clean one. At this time, VMBeam directly relocates the memory of the VMs on the aged virtualized system to the clean virtualized system without any copy. We have implemented VMBeam in Xen and confirmed the decreases of system loads.', NULL);
INSERT INTO `list` VALUES (10731, '0000', 2011, 'inproceedings', 'Koutras, V.P. and Platis, A.N.', 'Applying Partial and Full Rejuvenation in Different Degradation Levels', 'Model-based&rej', NULL, '2011 IEEE Third International Workshop on Software Aging and Rejuvenation', 'IW-SAR', NULL, NULL, '20--25', NULL, '10.1109/WoSAR.2011.14', 'Software Aging and Rejuvenation', 'In this paper, a two-level software rejuvenation model is introduced. The innovative aspect consists in combining partial, full and failed rejuvenation with the concept of triggering rejuvenation even if the software did not reach the failure probable state. In the later case, either partial or full rejuvenation actions can be performed. The aim is to observe the effects of partial and full rejuvenation frequencies on system\'s performance, in order to distinguish optimal rejuvenation schedules. System\'s performance is expressed through availability, downtime and rejuvenation cost indicators.', NULL);
INSERT INTO `list` VALUES (10732, '0000', 2008, 'article', 'Koutras, V.P. and Platis, A.N. and Limnios, N.', 'Availability and reliability estimation for a system undergoing minimal, perfect and failed rejuvenation', 'Model-based&rej', NULL, '2008 IEEE International Conference on Software Reliability Engineering Workshops (ISSRE Wksp)', 'ISSREW', NULL, NULL, '1--6', NULL, '10.1109/ISSREW.2008.5355519', 'Software Aging and Rejuvenation', 'In this paper, a software rejuvenation model is presented in which two different rejuvenation actions are considered, perfect and minimal. The concept of a failed rejuvenation action which leads the system to failure is also introduced. The presented model is studied under a Continuous Time Markov Chain (CTMC) framework and a maximum likelihood estimator of the generator matrix is presented. Based on this, estimators for instantaneous availability and reliability function are also presented. Moreover, the behavior of the above estimators is studied under various rejuvenation policies. A numerical example based on simulation results is finally presented.', NULL);
INSERT INTO `list` VALUES (10733, '0000', 2008, 'inproceedings', 'Koutras, V. P. and Platis, A. N.', 'Modeling Perfect and Minimal Rejuvenation for Client Server Systems with Heterogeneous Load', 'Model-based&rej', NULL, '2008 14th IEEE Pacific Rim International Symposium on Dependable Computing', 'PRDC', NULL, NULL, '95--103', NULL, '10.1109/PRDC.2008.22', 'Software Aging and Rejuvenation', 'In the present study a client-server system is considered, which experiences resource degradation as clients\' requests increase. Software rejuvenation is performed in order to counteract resource exhaustion. Two different levels of rejuvenation actions are implemented, perfect, and minimal. Moreover the concept of a failed rejuvenation is introduced to model the fact that rejuvenation due to some circumstances cannot be accomplished. As the load of such a system varies from hour to hour but reveals a cyclic behavior from day to day, different rejuvenation policies for each period of the day are proposed using a cyclic non-homogeneous Markov (CNHM) model. As a measure of performance, the steady-state expected downtime cost is considered. Additionally, to set off the need of CNHM modeling, the system is also modeled by a Homogeneous Markov Chain (HMC) and the performance results are compared.', NULL);
INSERT INTO `list` VALUES (10734, '0000', 2017, 'inproceedings', 'Kumar, Lov and Sureka, Ashish', 'Aging Related Bug Prediction using Extreme Learning Machines', 'other', NULL, '2017 14th IEEE India Council International Conference (INDICON)', 'INDICON', NULL, NULL, '1--6', NULL, '10.1109/INDICON.2017.8487925', 'Software Aging and Rejuvenation', 'Aging-Related Bugs (ARBs) occur in long running systems due to error conditions caused because of accumulation of problems such as memory leakage or unreleased files and locks. Aging-Related Bugs are hard to discover during software testing and also challenging to replicate. Automatic identification and prediction of aging related fault-prone files and classes in an object oriented system can help the software quality assurance team to optimize their testing efforts. In this paper, we present a study on the application of static source code metrics and machine learning techniques to predict aging related bugs. We conduct a series of experiments on publicly available dataset from two large open-source software systems: Linux and MySQL. Class imbalance and high dimensionality are the two main technical challenges in building effective predictors for aging related bugs. We investigate the application of five different feature selection techniques (OneR, Information Gain, Gain Ratio, RELEIF and Symmetric Uncertainty) for dimensionality reduction and SMOTE method to counter the effect of class imbalance in our proposed machine learning based solution approach. We apply Extreme Learning Machines (ELM) with three different kernels (linear, polynomial and RBF) and present experimental results which demonstarte the effectiveness of our approach.', NULL);
INSERT INTO `list` VALUES (10735, '0000', 2018, 'article', 'Kumar, Lov and Sureka, Ashish', 'Feature Selection Techniques to Counter Class Imbalance Problem for Aging Related Bug Prediction: Aging Related Bug Prediction', 'other', NULL, '2018 Proceedings of the 11th Innovations in Software Engineering Conference', 'ISEC', NULL, NULL, '1--11', NULL, '10.1145/3172871.3172872', 'Software Aging and Rejuvenation', 'Aging-Related Bugs (ARBs) occur in long running systems due to error conditions caused because of accumulation of problems such as memory leakage or unreleased files and locks. Aging-Related Bugs are hard to discover during software testing and also challenging to replicate. Automatic identification and prediction of aging related fault-prone files and classes in an object oriented system can help the software quality assurance team to optimize their testing efforts. In this paper, we present a study on the application of static source code metrics and machine learning techniques to predict aging related bugs. We conduct a series of experiments on publicly available dataset from two large open-source software systems: Linux and MySQL. Class imbalance and high dimensionality are the two main technical challenges in building effective predictors for aging related bugs. We investigate the application of five different feature selection techniques (OneR, Information Gain, Gain Ratio, RELEIF and Symmetric Uncertainty) for dimensionality reduction and five different strategies (Random Under-sampling, Random Oversampling, SMOTE, SMOTEBoost and RUSBoost) to counter the effect of class imbalance in our proposed machine learning based solution approach. Experimental results reveal that the random under-sampling approach performs best followed by RUSBoost in-terms of the mean AUC metric. Statistical significance test demonstrates that there is a significant difference between the performance of the various feature selection techniques. Experimental results shows that Gain Ratio and RELEIF performs best in comparison to other strategies to address the class imbalance problem. We infer from the statistical significance test that there is no difference between the performances of the five different learning algorithms.', NULL);
INSERT INTO `list` VALUES (10736, '0000', 2013, 'article', 'Langner, Felix and Andrzejak, Artur', 'Detecting software aging in a cloud computing framework by comparing development versions.', 'testing', NULL, '2013 IFIP/IEEE International Symposium on Integrated Network Management (IM 2013)', 'IM', NULL, NULL, NULL, NULL, NULL, 'Software Aging and Rejuvenation', 'Software aging, i.e. degradation of software performance or functionality caused by resource depletion is usually discovered only in the production scenario. This incurs large costs and delays of defect removal and requires provisional solutions such as rejuvenation (controlled restarts). We propose a method for detecting aging problems shortly after their introduction by runtime comparisons of different development versions of the same software. Possible aging issues are discovered by analyzing the differences in runtime traces of selected metrics. The required comparisons are workload-independent which minimizes the additional effort of dedicated stress tests. Consequently, the method requires only minimal changes to the traditional development and testing process. This paves the way to detecting such problems before public releases, greatly reducing the cost of defect ﬁxing. Our study focuses on the memory leaks of Eucalyptus, a popular open source framework for managing cloud computing environments.', NULL);
INSERT INTO `list` VALUES (10737, '0000', 2011, 'inproceedings', 'Lavallée, Mathieu and Robillard, Pierre N.', 'Causes of premature aging during software development: an observational study', '现象分析', NULL, '2011 Proceedings of the 12th International Workshop on Principles of Software Evolution and the 7th annual ERCIM Workshop on Software Evolution', 'IWPSE-EVOL', NULL, NULL, '61--70', 'Association for Computing Machinery', '10.1145/2024445.2024458', 'Software Aging and Rejuvenation', 'Much work has been done on the subject of what happens to software architecture during maintenance activities. There seems to be a consensus that it degrades during the evolution of the software. More recent work shows that this degradation occurs even during development activities: design decisions are either adjusted or forgotten. Some studies have looked into the causes of this degradation, but these have mostly done so at a very high level. This study examines three projects at code level. Three architectural pre-implementation designs are compared with their post-implementation design counterparts, with special attention paid to the causes of the changes. We found many negative changes causing anti-patterns, at the package, class, and method levels. After analysis of the code, we were able to find the specific reasons for the poor design decisions. Although the underlying causes are varied, they can be grouped into three basic categories: knowledge problems, artifact problems, and management problems. This categorization shows that anti-pattern causes are varied and are not all due to the developers. The main conclusion is that promoting awareness of anti-patterns to developers is insufficient to prevent them since some of the causes escape their grasp.', NULL);
INSERT INTO `list` VALUES (10738, '0000', 2002, 'inproceedings', 'Lei Li and Vaidyanathan, K. and Trivedi, K.S.', 'An approach for estimation of software aging in a Web server', 'Measurement-based', NULL, '2002 Proceedings International Symposium on Empirical Software Engineering', 'ESEM', NULL, NULL, '91--100', NULL, '10.1109/ISESE.2002.1166929', 'Software Aging and Rejuvenation', 'A number of recent studies have reported the phenomenon of \"software aging\", characterized by progressive performance degradation or a sudden hang/crash of a software system due to exhaustion of operating system resources, fragmentation and accumulation of errors. To counteract this phenomenon, a proactive technique called \"software rejuvenation\" has been proposed. This essentially involves stopping the running software, cleaning its internal state and then restarting it. Software rejuvenation, being preventive in nature, begs the question as to when to schedule it. Periodic rejuvenation, while straightforward to implement, may not yield the best results. A better approach is based on actual measurement of system resource usage and activity that detects and estimates resource exhaustion times. Estimating the resource exhaustion times makes it possible for software rejuvenation to be initiated or better planned so that the system availability is maximized in the face of time-varying workload and system behavior. We propose a methodology based on time series analysis to detect and estimate resource exhaustion times due to software aging in a Web server while subjecting it to an artificial workload. We first collect and log data on several system resource usage and activity parameters on a Web server. Time-series ARMA models are then constructed from the data to detect aging and estimate resource exhaustion times. The results are then compared with previous measurement-based models and found to be more efficient and computationally less intensive. These models can be used to develop proactive management techniques like software rejuvenation which are triggered by actual measurements.', NULL);
INSERT INTO `list` VALUES (10739, '0000', 2017, 'inproceedings', 'Li, Lingling and He, Huihong and Wang, Qiang and Zhang, Hong', 'Aberrant software-aging server detection and analysis using sliding window over LOF', 'Measurement-based', NULL, '2017 8th IEEE International Conference on Software Engineering and Service Science (ICSESS)', 'ICSESS', NULL, NULL, '652--656', NULL, '10.1109/ICSESS.2017.8342999', 'Software Aging and Rejuvenation', 'As software grows rapidly in size and complexity, software aging has been observed more frequently in long-running computer system failures. Ever since the notion of software aging was introduced, lots of researches have devoted in studying software aging empirically by learning aging trend under controlled experiments. However, we notice that how software aging evolves within online system is seldom covered in the literature. To fill the blank and improve usability of software-aging works, we in this paper propose an approach to detect aberrant software aging in online system, i.e., servers grow old more quickly or slowly than the rest servers. We believe studying aberrant aging can contribute to better understanding of software aging in real world. The mechanism utilizes random sliding windows over LOF (Local Outlier Factor) algorithm to analyze the CPU and workload indicators, which displays good accuracy and recall rate in a real world application. Moreover, we analyze how the software trend to age aberrantly and verify if aberrant aging also obeys the rules in controlled experiment. We conclude three aging patterns from these aberrant aging servers, and find out CPU-oriented indicators shows higher precision and recall rate than memory-oriented in analyzing software aging.', NULL);
INSERT INTO `list` VALUES (10740, '0000', 2021, 'inproceedings', 'Li, Mingxi and Yin, Bei-Bei', 'ARB-BERT: An Automatic Aging-Related Bug Report Classification Method based on BERT', 'Classification', NULL, '2021 8th International Conference on Dependable Systems and Their Applications (DSA)', 'DSA', NULL, NULL, '474--483', NULL, '10.1109/DSA52907.2021.00071', 'Software Aging and Rejuvenation', 'Software aging is a common phenomenon in most software systems. It refers to the increase of failure rates or the decline of performance in a long-running software system, mainly caused by Aging-Related Bugs (ARBs). Failure incurred by software aging may cause economic loss and may lead to casualties in security-critical systems. Automatic classification of ARB reports is an effective method to ensure the software system\'s quality by helping us detect and fix the bugs in software systems. There are two challenges in the automatic classification of ARB reports at present. Firstly, it is difficult to distinguish the ARB reports since the semantics of the text is ambiguous and hard to be recognized; secondly, the number of ARB reports is much smaller than other types of bugs, which may lead to class imbalance. Therefore, An ARB Report Automatic Classification Method based on BERT(ARB-BERT) is proposed in this paper to alleviate these problems. We combined back-translation, random under-sampling and random over-sampling to reduce the class imbalance problem in classification. By considering the ARB reports\' characteristics, we utilize BERT as the semantic model, extracting feature vectors containing more accurate and sufficient information. The experimental results show that our method can improve the accuracy, precision, F-measure, and recall value compared with previous methods.', NULL);
INSERT INTO `list` VALUES (10741, '0000', 2021, 'inproceedings', 'Li, Dimeng and Liang, Mengting and Xu, Bin and Yu, Xiao and Zhou, Junwei and Xiang, Jianwen', 'A Cross-Project Aging-Related Bug Prediction Approach Based on Joint Probability Domain Adaptation and k-means SMOTE', 'other', NULL, '2021 IEEE 21st International Conference on Software Quality, Reliability and Security Companion (QRS-C)', 'QRS-C', NULL, NULL, '350--358', NULL, '10.1109/QRS-C55045.2021.00059', 'Software Aging and Rejuvenation', 'In long-running systems, the phenomenon of performance degradation and failure rate increase caused by Aging-Related Bugs (ARBs) is known as software aging. Because of the low presence and reproducing difficulty of ARBs, collecting enough training data to predict ARBs in a project is not easy. Thus, cross-project ARB prediction has been proposed. There are two main challenges in cross-project ARB prediction, namely distribution differences and severe class imbalance. As for the first challenge, existing cross-project ARB prediction approaches only focus on the transferability between domains while ignoring the discriminability between classes. As for the second challenge, existing approaches only consider the imbalance between the classes while ignoring the within-class imbalance problem. To solve these problems, a cross-project ARB prediction approach based on Joint Probability Domain Adaptation (JPDA) and k- means SMOTE (KS), called JPKS, is proposed. JPDA is used to consider the transferability and discriminability simultaneously, and KS solves the within-class and between-class imbalance problems. Experiments are conducted on two natural software systems to verify the performance of JPKS. The results show that JPKS can improve the performance of ARB prediction.', NULL);
INSERT INTO `list` VALUES (10742, '0000', 2020, 'article', 'Li, Jingwei and Qi, Yong and Wang, Guanghua and Lin, Jinwei', 'Planning Optimal Rejuvenation Policy for Aging Software Systems via a Two-Layer Model', 'Hybrid', NULL, '2020 IEEE Access', 'Access', '8', NULL, '136725--136735', NULL, '10.1109/ACCESS.2020.3011813', 'Software Aging and Rejuvenation', 'Software rejuvenation is a proactive fault management technique widely used for preventing performance degradation and failures due to software aging. It works by proactively terminating the system, cleaning the internal state of the system, and restarting the system. Since rejuvenation incurs extra system overhead and downtime cost, it is important to determine the optimal time to trigger rejuvenation. This paper proposes a two-layer model to characterize the system failure behavior and rejuvenation process under aging condition, planning a time-based rejuvenation policy maximizing the system availability and minimizing downtime cost. The lower layer is a failure model that uses an analytical model and runtime measurements to build the failure distribution of the aging system. The upper layer is a rejuvenation model that takes the failure distribution from the lower layer as input to formulate the availability function and downtime cost function. Taking these two functions as optimization targets, we can obtain the optimal rejuvenation time. Compared with the traditional analytical model, the two-layer model modeling software failure considers runtime measurements, which can describe the aging behavior more accurately. In the experimental part, we comprehensively evaluate the two-layer model by studying the aging of the web search system. The results show that the two-layer model reduces unavailability by 18.18\\% and reduces downtime cost by 31.22\\% in comparison with the traditional analytical model.', NULL);
INSERT INTO `list` VALUES (10743, '0000', 2012, 'inproceedings', 'Li, Su and Yong, Qi', 'Software Aging Detection Based on NARX Model', 'Measurement-based&度量', NULL, '2012 Ninth Web Information Systems and Applications Conference', 'WISA', NULL, NULL, '105--110', NULL, '10.1109/WISA.2012.22', 'Software Aging and Rejuvenation', 'Software aging is a severe test on the reliability of the software. In this paper, we present a method of nonlinear autoregressive models with exogenous inputs to detect the aging phenomenon of the software system. This method considered the relationship between multivariable and the influence of the delay of historical data. The experimental analysis shows that, using the NARX model to detect fault can be effectively applied in the software aging test.', NULL);
INSERT INTO `list` VALUES (10744, '0000', 2020, 'inproceedings', 'Liu, Qinchen and Xiang, Jianwen and Xu, Bin and Zhao, Dongdong and Hu, Wenhua and Wang, Jian', 'Aging-Related Bugs Prediction Via Convolutional Neural Network', 'other', NULL, '2020 7th International Conference on Dependable Systems and Their Applications (DSA)', 'DSA', NULL, NULL, '90--98', NULL, '10.1109/DSA51864.2020.00020', 'Software Aging and Rejuvenation', 'Software aging refers to the phenomenon of system performance degradation or system crash in long-term running systems, which is mainly caused by Aging-Related Bugs (ARBs). To predict Aging-Related Bugs, previous studies usually focused on manually designing features, which extracted from the programs, and utilized different machine learning algorithms to detect those buggy codes. However, these traditional features often failed to distinguish programs\' semantic differences.To explore deeply programs\' semantics and make full use of these information, in this paper, we proposed a method, which based on deep learning method to automatically learn programs\' semantic features of source codes. Specifically, we utilized Convolutional Neural Network (CNN) to automatically generate more distinguished features which based on the abstract Syntax Trees (ASTs) of programs. Meanwhile, we combined these features with conventional aging-related metrics for more accurate ARB prediction. Finally, we evaluated our model on Linux and MySQL datasets, the experiment results showed that our approach was better than the baselines. The improvement can be achieved up to 6.9\\% on Linux, and 24.1\\% on MySQL in terms of balance, compared to traditional Naive Bayes method. And compared to Naive Bayes with logarithmic transformation, the improvement is 1\\% and 4.7\\% respectively.', NULL);
INSERT INTO `list` VALUES (10745, '0000', 2019, 'inproceedings', 'Liu, Jing and Tan, Xueyong and Wang, Yan', 'CSSAP: Software Aging Prediction for Cloud Services Based on ARIMA-LSTM Hybrid Model', 'Measurement-based（ML）', NULL, '2019 IEEE International Conference on Web Services (ICWS)', 'ICWS', NULL, NULL, '283--290', NULL, '10.1109/ICWS.2019.00055', 'Software Aging and Rejuvenation', 'Cloud services typically compose of multiple distributed software components that communicate with each other through web service interfaces in the cloud environments. During their long time running, the accumulation of cloud software internal errors or large consumption of computing resources will very likely lead to software aging problems. In order to solve this problem, software rejuvenation technology is proposed to prevent them from causing more serious failures by restarting the services running. In the research field of software aging and rejuvenation for cloud services, how to accurately predict the cloud resource consumption in the aging software system for determining suitable time to perform rejuvenation is a significant and indispensable issue. In this paper, a novel hybrid aging prediction model named CSSAP is proposed, which well integrates the Autoregressive Integrated Moving Average (ARIMA) model and Long Short Term Memory (LSTM) model for better fitting the linear pattern and mining the nonlinear relationship in the time series of computing resource usage data for cloud services. The experiments results show that through such hybrid and unified time series analysis, our CASSP prediction method has 4\\% to 71\\% improvements in MAE evaluation criteria and 6\\% to 66\\% improvements in RMSE evaluation criteria under different time series scenarios compared with single model used, that is, the more accurate and more comprehensive aging prediction results achieved by CSSAP is definitely conducive to perform more effective and more efficient software aging and rejuvenation for cloud services.', NULL);
INSERT INTO `list` VALUES (10746, '0000', 2019, 'article', 'Liu, Jing and Meng, Lingze', 'Integrating Artificial Bee Colony Algorithm and BP Neural Network for Software Aging Prediction in IoT Environment', 'Measurement-based（ML）', NULL, '2019 IEEE Access', 'Access', '7', NULL, '32941--32948', NULL, '10.1109/ACCESS.2019.2903081', 'Software Aging and Rejuvenation', 'Software aging is a common phenomenon that exists in systems that require long periods of operation, especially in Internet-of-Things environments. The back propagation (BP) neural network has been adopted widely to predict the trend of software aging. However, the weight and threshold of the BP neural network are randomly initialized, so it is easy to get the unsatisfactory local optimal solutions and the convergence speed of computing is slow. In this paper, we propose a novel software aging prediction method using the artificial bee colony algorithm to optimize the BP neural network model for achieving better software aging prediction accuracy. The experiment results show that our method fits the prediction trend of software aging more accurately than the traditional BP neural network, and our method also has faster convergence speed and more stable prediction results.', NULL);
INSERT INTO `list` VALUES (10747, '0000', 2015, 'article', 'Liu, Jing and Zhou, Jiantao and Buyya, Rajkumar', 'Software Rejuvenation Based Fault Tolerance Scheme for Cloud Applications', 'Measurement-based&other', NULL, '2015 IEEE 8th International Conference on Cloud Computing', 'CLOUD', NULL, NULL, '1115--1118', NULL, '10.1109/CLOUD.2015.164', 'Software Aging and Rejuvenation', 'Cloud applications are typically composed of multiple cloud service components communicating with each other through web service interfaces, where each component fulfills specified functionalities. Lack of effective fault tolerance scheme is one of major obstacles for enhancing availability and efficiency of complex and aging cloud application systems. In this paper, we propose a holistic software rejuvenation based fault tolerance scheme for cloud applications, which contains three indispensible parts: adaptive failure detection, aging degree evaluation, and checkpoint with trace replay based component rejuvenation. Through a preliminary and qualitative evaluation, it shows that our new fault tolerance scheme brings promising improvement on the availability of cloud applications.', NULL);
INSERT INTO `list` VALUES (10748, '0000', 2022, 'inproceedings', 'Liu, Zhihao and Zheng, Yang and Du, Xiaoting and Hu, Zheng and Ding, Wenjie and Miao, Yanming and Zheng, Zheng', 'Taxonomy of Aging-related Bugs in Deep Learning Libraries', '分析bug报告&Classification', NULL, '2022 IEEE 33rd International Symposium on Software Reliability Engineering (ISSRE)', 'ISSRE', NULL, NULL, '423--434', NULL, '10.1109/ISSRE55969.2022.00048', 'Software Aging and Rejuvenation', 'Deep learning libraries are the cornerstone of deep learning systems, and millions of deep learning applications are built on top of deep learning libraries. Due to long-term continuous running, many numerical operations and heavy dependence on resources, deep learning libraries are prone to the effects of software aging. Aging in deep learning libraries can threaten the reliability of deep learning systems and make training and application of deep learning more time-consuming and expensive, causing users to lose confidence in it. In this work, we manually screened 138 bug reports containing aging-related bugs from a total of 13,694 bug reports in four popular deep learning libraries (i.e., TensorFlow, MXNET, PaddlePaddle and MindSpore). We analyzed the information in these 138 bug reports to answer three questions: What categories of aging-related bugs exist in deep learning libraries? What is the distribution of different categories of aging-related bugs in deep learning libraries? Which deep learning phases are most susceptible to software aging? Finally, we conducted a fine-grained taxonomy of aging-related bugs, including four levels and seventeen categories, and obtained eight important findings with corresponding practical implications.', NULL);
INSERT INTO `list` VALUES (10749, '0000', 2010, 'inproceedings', 'Macêdo, Autran and Ferreira, Taís B. and Matias, Rivalino', 'The mechanics of memory-related software aging', '现象分析', NULL, '2010 IEEE Second International Workshop on Software Aging and Rejuvenation', 'IW-SAR', NULL, NULL, '1--5', NULL, '10.1109/WOSAR.2010.5722097', 'Software Aging and Rejuvenation', 'Software aging is a phenomenon defined as the continuing degradation of software systems during runtime, being particularly noticeable in long-running applications. Memory-related aging effects are one of the most important problems in this research field. Therefore understanding their causes and how they work is a major requirement in designing dependable software systems. In this paper we go deep into how memory management works inside application process, focusing on two memory problems that cause software aging: fragmenting and leakage. We explain the mechanics of memory-related software aging effects dissecting a real and widely adopted memory allocator. Along with the theoretical explanation, we present an experimental study that illustrates how memory fragmenting and leakage occur and how they accumulate over time in order to cause system aging-related failures.', NULL);
INSERT INTO `list` VALUES (10750, '0000', 2012, 'inproceedings', 'Machida, Fumio and Xiang, Jianwen and Tadano, Kumiko and Maeno, Yoshiharu', 'Aging-Related Bugs in Cloud Computing Software', '分析bug报告&Classification', NULL, '2012 IEEE 23rd International Symposium on Software Reliability Engineering Workshops', 'ISSREW', NULL, NULL, '287--292', NULL, '10.1109/ISSREW.2012.97', 'Software Aging and Rejuvenation', 'Cloud computing is established on advanced software technologies intended to enhance the scalability of computing infrastructure by making full use of commodity servers. The more cloud computing relies on software technologies, the more software bugs have significant impacts on the system availability. Aging-related bugs, which cause the accumulation of errors in long time software execution, often remain even after the release of a stable version of the software. This paper investigates the bug reports of five major open-source software projects related to cloud computing and confirms the issues about the existence of aging-related bugs. From the investigation how the developers work around such aging-related bugs, the importance of the tool assistance for reproducing the aging problem in replicated site is discussed.', NULL);
INSERT INTO `list` VALUES (10751, '0000', 2013, 'inproceedings', 'Machida, Fumio and Andrzejak, Artur and Matias, Rivalino and Vicente, Elder', 'On the effectiveness of Mann-Kendall test for detection of software aging', '度量', NULL, '2013 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)', 'ISSREW', NULL, NULL, '269--274', NULL, '10.1109/ISSREW.2013.6688905', 'Software Aging and Rejuvenation', 'Software aging (i.e. progressive performance degradation of long-running software systems) is difficult to detect due to the long latency until it manifests during program execution. Fast and accurate detection of aging is important for eliminating the underlying defects already during software development and testing. Also in a deployment scenario, aging detection is needed to plan mitigation methods like software rejuvenation. The goal of this paper is to evaluate whether the Mann-Kendall test is an effective approach for detecting software aging from traces of computer system metrics. This technique tests for existence of monotonic trends in time series, and studies of software aging often consider existence of trends in certain metrics as indication of software aging. Through an experimental study we show that the Mann-Kendall test is highly vulnerable to creating false positives in context of aging detection. By increasing the amount of data considered in the test, the false positive rate can be reduced; however, time to detect aging increases considerably. Our findings indicate that aging detection using the Mann-Kendall test alone is in general unreliable, or may require long measurement times.', NULL);
INSERT INTO `list` VALUES (10752, '0000', 2011, 'inproceedings', 'Machida, Fumio and Nicola, Victor F. and Trivedi, Kishor S.', 'Job Completion Time on a Virtualized Server Subject to Software Aging and Rejuvenation', 'Model-based', NULL, '2011 IEEE Third International Workshop on Software Aging and Rejuvenation', 'IW-SAR', NULL, NULL, '44--49', NULL, '10.1109/WoSAR.2011.10', 'Software Aging and Rejuvenation', 'Virtual machine monitor (VMM) rejuvenation is a proactive recovery method against failures caused by software aging in VMM. Since the job running on a hosted virtual machine (VM) is interrupted at VMM rejuvenation, the preemption type of VMM rejuvenation is important for the performance of job execution. In preemptive repeat (prt), the interrupted job needs to restart after recovery. In preemptive resume (prs), the job can resume the execution from the interrupted point. In this paper, we analyze the completion time of a job running on a virtualized server subject to software aging and rejuvenation in prt case or prs case. The theory developed in [1] is used to obtain the Laplace-Stieltjes transform (LST) of job completion time for the server modeled as a semi-Markov process. Numerical inversion of the obtained LST shows that VMM rejuvenation with prs job interruption improves the performance of job execution, while the rejuvenation with prt job interruption may degrade or improve its performance depending on the severity of performance degradation caused by software aging.', NULL);
INSERT INTO `list` VALUES (10753, '0000', 2014, 'article', 'Machida, F. and Nicola, V. and Trivedi, Kishor S.', 'Job completion time on a virtualized server with software rejuvenation', 'Model-based', NULL, '2014 ACM J. Emerg. Technol. Comput. Syst.', 'J. Emerg. Technol. Comput. Syst.', NULL, NULL, NULL, NULL, '10.1145/2539121', 'Software Aging and Rejuvenation', 'With the parameter settings, VMM rejuvenation with prs job interruption improves the performance of job execution regardless of the aging type, with performance degradation is taken into account. This article analyzes the completion time of a job running on a virtualized server subject to software aging and rejuvenation in a virtual machine monitor (VMM). A job running on the server may be interrupted by virtual machine (VM) failure, VMM failure or VMM rejuvenation. The job interruption is categorized as either preemptive-repeat (prt), in which case the interrupted job needs to restart from the beginning, or preemptive-resume (prs), in which case the job resumes execution from the point of interruption. Using a semi-Markov process (SMP) to model the server behavior, the steady-state server availability is computed and the theory developed in Kulkarni et al. [1987] is used to obtain the Laplace-Stieltjes transform (LST) of the job completion time. In the numerical experiments, we introduce four types of aging behavior of VMM. The effectiveness of VMM rejuvenation on job completion time is discussed in association with the type of interruption it causes and the VMM aging type. With our parameter settings, VMM rejuvenation with prs job interruption improves the performance of job execution regardless of the aging type, with performance degradation is taken into account.', NULL);
INSERT INTO `list` VALUES (10754, '0000', 2017, 'article', 'Machida, Fumio and Xiang, Jianwen and Tadano, Kumiko and Maeno, Yoshiharu', 'Lifetime Extension of Software Execution Subject to Aging', 'Model-based&rej&other', NULL, '2017 IEEE Transactions on Reliability', 'Trans. Rel.', '66', '1', '123--134', NULL, '10.1109/TR.2016.2615880', 'Software Aging and Rejuvenation', 'Software aging is a phenomenon of progressive degradation of software execution environment caused by software faults. In this paper, we propose software life-extension as an operational countermeasure against software aging and present the mathematical foundations of software life-extension by means of stochastic modeling. A semi-Markov process is used to capture the behavior of a system with software life-extension and to analyze the system\'s availability and completion times of jobs running on it. The semi-Markov process can correctly model the time-based life-extension and allows us to derive the optimal trigger for starting life-extension in terms of system availability and mean job completion time. We also present an effective combination of software life-extension and software rejuvenation that can maximize the system availability compared with a system using either rejuvenation or software life-extension.', NULL);
INSERT INTO `list` VALUES (10755, '0000', 2010, 'inproceedings', 'Machida, Fumio and Kim, Dong Seong and Trivedi, Kishor S.', 'Modeling and analysis of software rejuvenation in a server virtualized system', 'Model-based&rej', NULL, '2010 IEEE Second International Workshop on Software Aging and Rejuvenation', 'IW-SAR', NULL, NULL, '1--6', NULL, '10.1109/WOSAR.2010.5722098', 'Software Aging and Rejuvenation', 'As server virtualization is used as an essential software infrastructure of various software services such as cloud computing, availability management of server virtualized system is becoming more significant. Although time-based software rejuvenation is useful to postpone/prevent failures due to software aging in a server virtualized system, the rejuvenation schedules for virtual machine (VM) and virtual machine monitor (VMM) need to be determined in a proper way for the VM availability, since VMM rejuvenation affects VMs running on the VMM. This paper presents analytic models using stochastic reward nets for three time-based rejuvenation techniques of VMM; (i) Cold-VM rejuvenation in which all VMs are shut down before the VMM rejuvenation, (ii) Warm-VM rejuvenation in which all VMs are suspended before the VMM rejuvenation and (iii) Migrate-VM rejuvenation in which all VMs are moved to the other host server during the VMM rejuvenation. We compare the three techniques in terms of steady-state availability and the number of transactions lost in a year. We find the optimal combination of rejuvenation trigger intervals for each rejuvenation technique by a gradient search method. The numerical analysis shows the interesting result that Warm-VM rejuvenation does not always outperform Cold-VM rejuvenation in terms of steady-state availability depending on rejuvenation trigger intervals. Migrate-VM rejuvenation is better than the other two as long as live VM migration rate is large enough and the other host server has a capacity to accept the migrated VM.', NULL);
INSERT INTO `list` VALUES (10756, '0000', 2013, 'article', 'Machida, Fumio and Kim, Dong Seong and Trivedi, Kishor S.', 'Modeling and analysis of software rejuvenation in a server virtualized system with live VM migration', 'Model-based&rej', NULL, '2013 Performance Evaluation', 'Perf. Eval', '70', '3', '212--230', NULL, '10.1016/j.peva.2012.09.003', 'Software Aging and Rejuvenation', 'As server virtualization is used in a number of IT systems, the unavailability of virtual machines (VM) on server virtualized systems becomes a significant concern. Software rejuvenation is a promising technique for improving the availability of server virtualized systems as it can postpone or prevent failures caused by software aging in both the VM and the underlying virtual machine monitor (VMM). In this paper, we study the effectiveness of a combination of VMM rejuvenation and live VM migration. When a VMM needs to be rejuvenated, the hosted VMs running on the VMM can be moved to another host using live VM migration and continue the execution even during the VMM rejuvenation. We call this technique Migrate-VM rejuvenation and construct an availability model in the stochastic reward net for evaluating it in comparison with the conventional approaches; Cold-VM rejuvenation and Warm-VM rejuvenation. The designed model enables us to find the optimum combinations of rejuvenation trigger intervals that maximize the availability of VM. In terms of the maximum VM availability, Migrate-VM rejuvenation is potentially the best approach. However, the advantage of Migrate-VM rejuvenation depends on the type of live VM migration (stop-and-copy or pre-copy) and the policy for migration back to the original host after VMM rejuvenation (return-back or stay-on). Through numerical examples, we show that “pre-copy” live VM migration is encouraged rather than pure “stop-and-copy” migration and it is better to return back VM to the original host soon after the VMM rejuvenation (i.e., “return-back” rather than “stay-on” policy) for high-availability. The effect of the VMM rejuvenation technique on the expected number of transactions lost is also studied by combining the availability model with an M/M/1/n queueing model.', NULL);
INSERT INTO `list` VALUES (10757, '0000', 2008, 'inproceedings', 'Machida, Fumio and Kim, Dong Seong and Park, Jong Sou and Trivedi, Kishor S.', 'Toward optimal virtual machine placement and rejuvenation scheduling in a virtualized data center', 'Model-based', NULL, '2008 IEEE International Conference on Software Reliability Engineering Workshops (ISSRE Wksp)', 'ISSREW', NULL, NULL, '1--3', NULL, '10.1109/ISSREW.2008.5355515', 'Software Aging and Rejuvenation', 'Virtualization enables data centers to consolidate servers to improve resource utilization and power consumption. This paper presents the issues of performability management in a virtualized data center that hosts multiple services using virtualization. One of main cause of performability degradation is software aging in both virtual machines (VMs) and virtual machine monitor (VMM) in virtualized data center (VDC). Software rejuvenation is a cost effective and a proactive method to counteract software aging. During software rejuvenation operations, there occurs down time, therefore, VM placement and the rejuvenation schedules for VMs and VMM need to be optimized so as to maximize the performability in a VDC. We introduce the state of the art technology on software aging and rejuvenation in virtualized data center and we formulate this problem and show our approach.', NULL);
INSERT INTO `list` VALUES (10758, '0000', 2010, 'inproceedings', 'Magalhães, João Paulo and Silva, Luis Moura', 'Prediction of performance anomalies in web-applications based-on software aging scenarios', 'Measurement-based（ML）', NULL, '2010 IEEE Second International Workshop on Software Aging and Rejuvenation', 'IW-SAR', NULL, NULL, '1--7', NULL, '10.1109/WOSAR.2010.5722095', 'Software Aging and Rejuvenation', 'The topic of this paper is about prediction of performance anomalies caused by software aging. We have developed a framework for detection of performance anomalies that is targeted to web and component-based applications. In this study, we selected some amount of historical data previously collected and we conducted a correlation analysis with this data. The resulting dataset was then submitted to some Machine-Learning (ML) classification algorithms. The best algorithms were selected according to the accuracy and precision. In a second step, we induced some synthetic aging scenarios (memory leaks and CPU contention) in the application and we tried to do estimation of the system parameters by using time-series analysis. With the estimated values we conducted a classification with the three previous ML algorithms. From the initial results we observed that combining the estimation of parameters supported by time-series models with ML classification techniques provides some good results on the prediction of performance anomalies. We also observed that there is no single ML algorithm that can be applied effectively to predict the response time for all the web-transactions.', NULL);
INSERT INTO `list` VALUES (10759, '0000', 1992, 'article', 'Marshall, Eliot', 'Fatal Error: How Patriot Overlooked a Scud', '现象分析', NULL, '1992 Science', 'Science', '255', '5050', '1347--1348', NULL, '10.1126/science.255.5050.1347', 'Software Aging and Rejuvenation', NULL, NULL);
INSERT INTO `list` VALUES (10760, '0000', 2010, 'article', 'Matias, Rivalino and Barbetta, Pedro Alberto and Trivedi, Kishor S. and Filho, Paulo J. Freitas', 'Accelerated Degradation Tests Applied to Software Aging Experiments', 'testing', NULL, '2010 IEEE Transactions on Reliability', 'Trans. Rel.', '59', '1', '102--114', NULL, '10.1109/TR.2009.2034292', 'Software Aging and Rejuvenation', 'In the past ten years, the software aging phenomenon has been systematically researched, and recognized by both academic, and industry communities as an important obstacle to achieving dependable software systems. One of its main effects is the depletion of operating system resources, causing system performance degradation or crash/hang failures in running applications. When conducting experimental studies to evaluate the operational reliability of systems suffering from software aging, long periods of runtime are required to observe system failures. Focusing on this problem, we present a systematic approach to accelerate the software aging manifestation to reduce the experimentation time, and to estimate the lifetime distribution of the investigated system. First, we introduce the concept of ¿aging factor¿ that offers a fine control of the aging effects at the experimental level. The aging factors are estimated via sensitivity analyses based on the statistical design of experiments. Aging factors are then used together with the method of accelerated degradation test to estimate the lifetime distribution of the system under test at various stress levels. This approach requires us to estimate a relationship model between stress levels and aging degradation. Such models are called stress-accelerated aging relationships. Finally, the estimated relationship models enable us to estimate the lifetime distribution under use condition. The proposed approach is used in estimating the lifetime distribution of a web server with software aging symptoms. The main result is the reduction of the experimental time by a factor close to 685 in comparison with experiments executed without the use of our technique.', NULL);
INSERT INTO `list` VALUES (10761, '0000', 2006, 'article', 'Matias, Rivalino and F. Filho, Paulo', 'An Experimental Study on Software Aging and Rejuvenation in Web Servers', '度量&rej', NULL, '2006 30th Annual International Computer Software and Applications Conference (COMPSAC\'06)', 'COMPSAC', NULL, NULL, '189--196', NULL, '10.1109/COMPSAC.2006.25', 'Software Aging and Rejuvenation', 'Several studies have been conducted in order to understand the \'software aging\' phenomenon. This paper presents the results of an experimental research work, which evaluated the software aging effects on a Web server as well as the performance of a rejuvenation agent. Its main contribution is the identification and analytical validation of the factors that contribute for the Web server aging. We adopted the design of experiment technique (DOE) to characterize the aging phenomenon. The results showed evidence that the \'page type\' and \'page size\' factors were responsible for over 99\\% of memory size variation in httpd processes. A \'rejuvenation agent\' was implemented and integrated into the server environment to mitigate the aging effects. As a result, the size of the httpd processes could be kept under control and a higher availability and performance of the Web server could be provided, as compared to the scenario without rejuvenation', NULL);
INSERT INTO `list` VALUES (10762, '0000', 2010, 'inproceedings', 'Matias Jr., Rivalino and Trivedi, Kishor S. and Maciel, Paulo R.M.', 'Using Accelerated Life Tests to Estimate Time to Software Aging Failure', 'testing', NULL, '2010 IEEE 21st International Symposium on Software Reliability Engineering', 'ISSRE', NULL, NULL, '211--219', NULL, '10.1109/ISSRE.2010.42', 'Software Aging and Rejuvenation', 'Software aging is a phenomenon defined as the continuing degradation of software systems during runtime, being particularly noticeable in long-running applications. Aging-related failures are very difficult to observe, because the accumulation of aging effects usually requires a long-term execution. Thus, collecting a statistically significant sample of times to aging-related failures so as to estimate the system’s lifetime distribution is a very hard task. This is an important problem that prevents many experimental and analytical studies, mainly those focused on modeling of software aging aspects, of using representative parameter values. In this paper we propose and evaluate the use of quantitative accelerated life tests (QALT) to reduce the time to obtain the lifetime distribution of systems that fail due to software aging. Since QALT was developed for hardware failures, in this paper, we adapt it to software aging experiments. We test the proposed approach experimentally, estimating the lifetime distribution of a real web server system. The accuracy of the estimated distribution is evaluated by comparing its reliability estimates with a sample of failure times observed from the real system under test. The mean time to failure calculated from the real sample falls inside the 90\\% confidence interval constructed from the estimated lifetime distribution, demonstrating the high accuracy of the estimated model. The proposed approach reduces the time required to obtain the failure times by a factor of seven, for the real system investigated.', NULL);
INSERT INTO `list` VALUES (10763, '0000', 2010, 'inproceedings', 'Matias, Rivalino and Beicker, Ibrahim and Leitão, Breno and Maciel, Paulo R. M.', 'Measuring software aging effects through OS kernel instrumentation', '现象分析&度量', NULL, '2010 IEEE Second International Workshop on Software Aging and Rejuvenation', 'IW-SAR', NULL, NULL, '1--6', NULL, '10.1109/WOSAR.2010.5722094', 'Software Aging and Rejuvenation', 'Software aging is a phenomenon defined as the continuing degradation of software systems during runtime, being particularly noticeable in long-running applications. Measuring aging effects is a very important step towards identifying the most significant causes of software aging, so rejuvenation mechanisms can be applied effectively. The literature has already discussed aging monitoring from a userspace perspective. In this paper we present an innovative study where we explore OS kernel instrumentation techniques to measure software aging effects. Kernel instrumentations are available in practically all modern operating systems and we show how this powerful mechanism can be used to monitor either application-specific or system-wide aging indicators. In addition to the theoretical study, we present numerical results obtained from controlled experiments.', NULL);
INSERT INTO `list` VALUES (10764, '0000', 2012, 'inproceedings', 'Matias, Rivalino and Costa, Bruno Evangelista and Macedo, Autran', 'Monitoring Memory-Related Software Aging: An Exploratory Study', '度量', NULL, '2012 IEEE 23rd International Symposium on Software Reliability Engineering Workshops', 'ISSREW', NULL, NULL, '247--252', NULL, '10.1109/ISSREW.2012.90', 'Software Aging and Rejuvenation', 'The accumulating effects of software aging have direct influence to the rate of aging-related failures. So far, the most investigated software aging effects are memory related, such as memory leak and memory fragmentation problems. In this work, we present a practical body of knowledge to support the solid understanding of the most important issues in monitoring memory-related software aging effects, focusing on memory leak problems. We discuss important drawbacks of using well known system-wide and application-specific aging indicators, as well as propose effective solutions for both cases.', NULL);
INSERT INTO `list` VALUES (10765, '0000', 2016, 'inproceedings', 'Matias, Rivalino and de Sena, Guilherme O. and Andrzejak, Artur and Trivedi, Kishor S.', 'Software Aging Detection Based on Differential Analysis: An Experimental Study', 'testing', NULL, '2016 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)', 'ISSREW', NULL, NULL, '71--77', NULL, '10.1109/ISSREW.2016.44', 'Software Aging and Rejuvenation', 'In this study we evaluate the applicability of the differential software analysis approach to detect memory leaks under a real workload. For this purpose, we used three different versions of a widely used software application, where one version was used as baseline (memory leak free) and the other two subsequent versions were our research subjects, one of them is confirmed to suffer from memory leaks and the other is memory leak free. The latter two versions were used to evaluate the accuracy of the proposed approach to detect aging, with respect to the number of true and false alarms. The results confirmed the previous findings obtained with synthetic workloads. The heap usage was a better metric than the resident set size, which has been extensively used for detecting software aging related to memory leakage. Also, the best data processing techniques to combine with the heap usage metric were Cumulative sum control chart and exponentially weighted moving average.', NULL);
INSERT INTO `list` VALUES (10766, '0000', 2014, 'inproceedings', 'Matias, Rivalino and Andrzejak, Artur and Machida, Fumio and Elias, Diego and Trivedi, Kishor', 'A Systematic Differential Analysis for Fast and Robust Detection of Software Aging', 'Measurement-based', NULL, '2014 IEEE 33rd International Symposium on Reliable Distributed Systems', 'SRDS', NULL, NULL, '311--320', NULL, '10.1109/SRDS.2014.38', 'Software Aging and Rejuvenation', 'Software systems running continuously for a long time often confront software aging, which is the phenomenon of progressive degradation of execution environment caused by latent software faults. Removal of such faults in software development process is a crucial issue for system reliability. A known major obstacle is typically the large latency to discover the existence of software aging. We propose a systematic approach to detect software aging which has in a shorter test time and higher accuracy compared to traditional aging detection via stress testing and trend detection with high confidence. The approach is based on a comparative differential analysis where a software version under test is compared with against a previous robust version by observing in terms of behavioral (signal) changes during system tests of resource metrics. A key instrument adopted is a divergence chart, which expresses time-dependent differences between two signals, allowing us to detect changes in the system metrics\' values which indicate the existence of software aging. In our experimental study, we focuses on memory-leak detection and the and evaluates divergence charts are computed using various multiple statistical techniques combined paired with different application-level memory related metrics (RSS and Heap Usage). The experimental results show that the statistical process control techniques used in our approach proposed method achieves good performance for memory-leak detection, when compared with other in comparison to techniques widely adopted in previous works (e.g., linear regression, moving average and median).', NULL);
INSERT INTO `list` VALUES (10767, '0000', 2012, 'article', 'Matos, Rubens and Araujo, Jean and Alves, Vandi and Maciel, Paulo', 'Characterization of Software Aging Effects in Elastic Storage Mechanisms for Private Clouds', '度量', NULL, '2012 IEEE 23rd International Symposium on Software Reliability Engineering Workshops', 'ISSREW', NULL, NULL, '293--298', NULL, '10.1109/ISSREW.2012.82', 'Software Aging and Rejuvenation', 'Cloud computing systems fundamentally provide access to large pools of data and computational resources. Eucalyptus is a software framework used to implement private and hybrid-style Infrastructure as a Service clouds. It implements the Amazon Web Service (AWS) API, allowing interoperability with other AWS-based services. Elastic block storage (EBS) is a technology which provides flexible allocation of remote storage volumes to the virtual machines running in a cloud computing environment. Eucalyptus interacts with many software components to provide EBS features to the virtual machines: KVM hypervisor and Eucalyptus Node Controller (NC) are among those components. This work investigates the software aging effects in a Eucalyptus environment, considering workloads composed of intensive requests for attaching remote storage volumes to virtual machines. The results evidenced that memory leaks in Node Controller and the high CPU utilization by the KVM process are strongly correlated. The experimental analysis also show how much the aging effects are related to the performance degradation of a virtualized web server running on this infrastructure.', NULL);
INSERT INTO `list` VALUES (10768, '0000', 2012, 'inproceedings', 'MATOS, Rubens', 'Software Rejuvenation in Eucalyptus Cloud Computing Infrastructure : A Hybrid Method Based on Multiple Thresholds and Time Series Prediction', NULL, NULL, '{2011 IEEE Third International Workshop on Software Aging and Rejuvenation', 'IW-SAR', NULL, NULL, NULL, NULL, 'https://www.semanticscholar.org/paper/Software-Rejuvenation-in-Eucalyptus-Cloud-Computing-Matos-Araujo/04634a09225d5e19579bc5fbabbf36256137ee03', 'Software Aging and Rejuvenation', NULL, NULL);
INSERT INTO `list` VALUES (10769, '0000', 2013, 'inproceedings', 'Melo, Matheus and Maciel, Paulo and Araujo, Jean and Matos, Rubens and Araújo, Carlos', 'Availability study on cloud computing environments: Live migration as a rejuvenation mechanism', 'Model-based&rej', NULL, '2013 43rd Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN)', 'DSN', NULL, NULL, '1--6', NULL, '10.1109/DSN.2013.6575322', 'Software Aging and Rejuvenation', 'With the increasing adoption of cloud computing environments, studies about high availability in those systems became more and more significant. Software rejuvenation is an important mechanism to improve system availability. This paper presents a comprehensive availability model to evaluate the utilization of the live migration mechanism to enable VMM rejuvenation with minimum service interruption. Live migrations are performed observing a time-based trigger. We evaluate five different scenarios, with distinct time intervals for triggering the rejuvenation. The results show that the live migration can significantly reduce the system downtime.', NULL);
INSERT INTO `list` VALUES (10770, '0000', 2013, 'inproceedings', 'Melo, Matheus and Araujo, Jean and Matos, Rubens and Menezes, Julian and Maciel, Paulo', 'Comparative Analysis of Migration-Based Rejuvenation Schedules on Cloud Availability', 'Model-based&rej', NULL, '2013 IEEE International Conference on Systems, Man, and Cybernetics', 'SMC', NULL, NULL, '4110--4115', NULL, '10.1109/SMC.2013.701', 'Software Aging and Rejuvenation', 'Software aging refers to performance degradation faced on long-running execution software. The software infrastructure supporting Cloud Computing systems may suffer from aging effects. Such a phenomenon was already reported for virtual infrastructure managers and virtual machine monitors. In this sense, software rejuvenation is a technique of proactive fault tolerance to deal with effects of software aging. This paper proposes a comprehensive availability model for two different types of rejuvenation scheduling based on live migration mechanism, one with a test before migration, and other without. We evaluate five different scenarios, with distinct time intervals for triggering the rejuvenation. The main goal is to explain the benefits gained from the use of this type of rejuvenation technique, as well as understand the differences between the two approaches analyzed. The results show that the utilization of a schedule with a checking mechanism before rejuvenation can bring a significant improvement on system availability.', NULL);
INSERT INTO `list` VALUES (10771, '0000', 2015, 'article', 'Meng, Haining and Liu, Jianjun and Hei, Xinhong', 'Modeling and optimizing periodically inspected software rejuvenation policy based on geometric sequences', 'Measurement-based（检查时间间隔）', NULL, '2015 Reliability Engineering System Safety', 'RESS', '133', NULL, '184--191', NULL, '10.1016/j.ress.2014.09.007', 'Software Aging and Rejuvenation', 'Semantic Scholar extracted view of \"Modeling and optimizing periodically inspected software rejuvenation policy based on geometric sequences\" by Haining Meng et al.', NULL);
INSERT INTO `list` VALUES (10772, '0000', 2015, 'inproceedings', 'Meng, Haining and Hei, Xinhong and Li, Yan and Du, Yanning and Xie, Guo', 'A Rejuvenation Model for Software System under Normal Attack', 'rej', NULL, '2015 IEEE Trustcom/BigDataSE/ISPA', 'ISPA', '1', NULL, '1160--1164', NULL, '10.1109/Trustcom.2015.498', 'Software Aging and Rejuvenation', 'Software aging is a crucial potential factor that affects software reliability. Software rejuvenation is a main effective method to counteract software aging. Aiming at software system suffering from security attack, a software rejuvenation model based on Markov regenerative stochastic Petri Nets is set up. Then the solution for the steady availability of the new model is derived via Markov regenerative theory. The numeric results show that, the optimal software rejuvenation schedule derived from the model can improve system availability, reduce downtime cost, and resist exterior attacks.', NULL);
INSERT INTO `list` VALUES (10773, '0000', 2022, 'inproceedings', 'Miranda, Leonardo and Lima, Cabral and Menasché, Daniel Sadoc and Domingues, Guilherme', 'Sequential Performance Analysis of Systems that Age and Rejuvenate', 'Model-based', NULL, '2022 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)', 'ISSREW', NULL, NULL, '146--153', NULL, '10.1109/ISSREW55968.2022.00061', 'Software Aging and Rejuvenation', 'Sequential performance analysis aims at evaluating performance indicators in an online fashion. The process stops in accordance with a pre-defined stopping rule, as soon as an anomaly that should produce an alarm is observed. Traditional sequential performance analysis techniques include CUSUM and sequential probability ratio test (SPRT). More recent techniques include the bucket algorithm, wherein tokens are accumulated into buckets when the system degrades, and removed when the system naturally recovers. If the number of tokens in the system reaches a threshold, an alarm is triggered. In this paper, we analyze sequential performance analysis algorithms applied to a system that is subject to rejuvenation. Among our results, we indicate how rejuvenation impacts the time until false alarms, and how to set the optimal rejuvenation rate accounting for the fact that systems can recover from transient performance degradation either naturally, as in standard sequential performance analysis models, or due to rejuvenation.', NULL);
INSERT INTO `list` VALUES (10774, '0000', 2010, 'inproceedings', 'Myint, May Tar Hla and Thein, Thandar', 'Availability Improvement in Virtualized Multiple Servers with Software Rejuvenation and Virtualization', 'Model-based', NULL, '2010 Fourth International Conference on Secure Software Integration and Reliability Improvement', 'SSIRI', NULL, NULL, '156--162', NULL, '10.1109/SSIRI.2010.19', 'Software Aging and Rejuvenation', 'Software aging often affects the performance of a software system and eventually causes it to fail. To highlight the aging problems in long running applications, we have conducted the study of software rejuvenation approach and virtualization technology in this paper. In order to reduce the downtime during rejuvenation interval, software rejuvenation and virtualization technology are combined in this paper. Virtualization allows multiple operating system instances to run concurrently on a single physical machine. In this paper, we map virtualization based software rejuvenation approach with Markov Chain process and get mathematical steady-state solutions of the chain. We model multiple physical servers which are used to host multiple virtual machines (VMs) using stochastic modeling and evaluate it through both numerical analysis and SHARPE (Symbolic Hierarchical Automated Reliability and Performance Evaluator) tool simulation. The numerical results show that software rejuvenation and virtualization can be used to prolong the availability of the services and reduce the downtime of the systems.', NULL);
INSERT INTO `list` VALUES (10775, '0000', 2016, 'inproceedings', 'Nagaraju, Vidhyashree and Basavaraj, Veeresh Varad and Fiondella, Lance', 'Software rejuvenation of a fault-tolerant server subject to correlated failure', 'Model-based', NULL, '2016 Annual Reliability and Maintainability Symposium (RAMS)', 'RAMS', NULL, NULL, '1--6', NULL, '10.1109/RAMS.2016.7448076', 'Software Aging and Rejuvenation', 'Society depends increasingly on software based services, necessitating that applications achieve a high level of reliability and availability to maintain customer satisfaction and preserve system safety. These service-oriented applications often operate continuously, which exposes the software to \"aging\" where resource deterioration such as memory leaks can lead resource exhaustion and ultimately system failure. To mitigate the impact of aging, software rejuvenation refreshes or restarts the system periodically to recover lost resources, thereby averting failures. Software rejuvenation may also employ fault tolerance to reduce the impact of individual failures on system availability. However, virtually all previous software rejuvenation studies assume that failures experienced by the individual servers comprising a fault tolerant system are statistically independent. This paper analyzes the impact of correlated failures on the optimality of rejuvenation schedules for a system composed of two parallel servers that can experience correlated failures. The examples illustrate the impact of correlation on the optimality of rejuvenation schedules to maximize availability and minimize down time cost. The results indicate that increasing the correlation between the failures of the servers increases the rejuvenation period when the objective is to maximize availability. However, the rejuvenation period decreases when the objective is to minimize down time cost. Thus, the proposed approach can objectively identify the optimal rejuvenation period that maximizes availability or minimizes down time cost.', NULL);
INSERT INTO `list` VALUES (10776, '0000', 2011, 'inproceedings', 'Ning, Gaorong and Trivedi, Kishor S. and Hu, Hai and Cai, Kai-Yuan', 'Multi-granularity Software Rejuvenation Policy Based on Continuous Time Markov Chain', 'Model-based&rej', NULL, '2011 IEEE Third International Workshop on Software Aging and Rejuvenation', 'IW-SAR', NULL, NULL, '32--37', NULL, '10.1109/WoSAR.2011.9', 'Software Aging and Rejuvenation', 'In this paper, a multi-granularity software rejuvenation policy isstudied. Four granularities of rejuvenation are proposed tomitigate the impact of four levels of software aging respectively.Continuous Time Markov Chain (CTMC) model is used to obtain theavailability and cost from its closed form solution. Moreover, therelations between availability, cost and parameters are studied and the optimal selection of parameters is obtained accordingly. Numerical examples show that the optimal inspection rates for maximizing availability and minimizing cost become larger if inspection delay rate becomes lower, and also the optimal inspection rates have the property of phase transitions when inspection delay rate changes.', NULL);
INSERT INTO `list` VALUES (10777, '0000', 2016, 'article', 'Ning, Gaorong and Zhao, Jing and Lou, Yunlong and Alonso, Javier and Matias, Rivalino and Trivedi, Kishor S. and Yin, Bei-Bei and Cai, Kai-Yuan', 'Optimization of Two-Granularity Software Rejuvenation Policy Based on the Markov Regenerative Process', 'Model-based&rej', NULL, '2016 IEEE Transactions on Reliability', 'Trans. Rel.', '65', '4', '1630--1646', NULL, '10.1109/TR.2016.2570539', 'Software Aging and Rejuvenation', 'Software rejuvenation is a proactive software control technique that is used to improve a computing system performance when it suffers from software aging. In this paper, a two-granularity inspection-based software rejuvenation policy, which works as a closed-loop control technique, is proposed. This policy mitigates the negative impact of two-level software aging. The two levels considered are the user-level applications and the operating system. A Markov regenerative process model is constructed based on the system condition. We obtain the degradation rate of the application software and operating system from fault injection experiments. The diagnostic accuracy of the adopted monitor and analysis system, which is applied to inspect the application software and operating system, is considered as we provide the optimal rejuvenation strategies. Finally, the availability and the overall loss probability with their corresponding optimal inspection time intervals are obtained numerically based on the parameter values estimated from the experiments. Experimental results show that two-granularity software rejuvenation is much more effective than traditional single-level software rejuvenation. In our experimental study, when two-granularity software rejuvenation is used, the unavailability and the overall loss probability of the system were reduced by 17.9\\% and 2.65\\%, respectively, in comparison with the single-level rejuvenation.', NULL);
INSERT INTO `list` VALUES (10778, '0000', 2013, 'inproceedings', 'Kalyan Vaidyanathan and Kenny C. Gross', 'MSET Performance Optimization for Detection of Software Aging', NULL, NULL, '2013 Proceedings of the IEEE Symposium on Computer-Based Medical Systems', 'CBMS', NULL, NULL, NULL, NULL, NULL, 'Software Aging and Rejuvenation', NULL, NULL);
INSERT INTO `list` VALUES (10779, '0000', 2008, 'inproceedings', 'Okamura, Hiroyuki and Tadashi Dohi', 'Availability optimization in operational software system with aperiodic time-based software rejuvenation scheme', 'Model-based&other', NULL, '2008 IEEE International Conference on Software Reliability Engineering Workshops (ISSRE Wksp)', 'ISSREW', NULL, NULL, '1--6', NULL, '10.1109/ISSREW.2008.5355516', 'Software Aging and Rejuvenation', 'This paper discusses an aperiodic time-based rejuvenation policy maximizing the steady-state system availability in operational software system. Under a fixed periodic checkpoint schedule, we develop an algorithm to derive the optimal aperiodic rejuvenation times based on dynamic programming. In numerical examples, the optimal rejuvenation time and its maximum availability are illustrated in the case where the system failure obeys the Weibull distribution.', NULL);
INSERT INTO `list` VALUES (10780, '0000', 2002, 'inproceedings', 'Okamura, Hiroyuki and Miyahara, Satoshi and Dohi, Tadashi', 'Dependability Analysis of a Client/Server Software System with Rejuvenation', 'Model-based', NULL, '2002 13th International Symposium on Software Reliability Engineering, 2002. Proceedings.', 'ISSRE', NULL, NULL, '171--171', 'IEEE Computer Society', '10.1109/ISSRE.2002.1173241', 'Software Aging and Rejuvenation', 'Long running software systems are known to experience  an aging phenomenon called software aging, one in which  the accumulation of errors during the execution of software  leads to performance degradation and eventually results in  failure. To counteract this phenomenon an active fault management  approach, called software rejuvenation, is particularly  useful. It essentially involves gracefully terminating  an application or a system and restarting it in a clean internal  state.  In this paper, we deal with dependability analysis of  a client/server software system with rejuvenation. Three  dependability measures in the server process, steady-state  availability, loss probability of requests and mean response  time on tasks, are derived from the well-known hidden  Markovian analysis under the time-based software rejuvenation  scheme. In numerical examples, we investigate the  sensitivity of some model parameters to the dependability  measures.', NULL);
INSERT INTO `list` VALUES (10781, '0000', 2012, 'inproceedings', 'Okamura, Hiroyuki and Dohi, Tadashi', 'Optimization of Opportunity-Based Software Rejuvenation Policy', 'Hybrid', NULL, '2012 IEEE 23rd International Symposium on Software Reliability Engineering Workshops', 'ISSREW', NULL, NULL, '283--286', NULL, '10.1109/ISSREW.2012.93', 'Software Aging and Rejuvenation', 'This paper deals with the optimization problem to determine the software rejuvenation time in the software system degraded by aging-related bugs. In particular, we discuss the opportunity-based policy where the execution of software rejuvenation is limited on a time sequence of opportunities, and the software rejuvenation is performed at the first opportunity after the rejuvenation time. Based on the semi-Markov model presented by Dohi et al. 2001, we derive a sufficient condition for the optimal rejuvenation time under the opportunity-based policy.', NULL);
INSERT INTO `list` VALUES (10782, '0000', 2010, 'inproceedings', 'Okamura, Hiroyuki and Dohi, Tadashi', 'Performance-aware software rejuvenation strategies in a queueing system', 'Model-based', NULL, '2010 IEEE Second International Workshop on Software Aging and Rejuvenation', 'IW-SAR', NULL, NULL, '1--6', NULL, '10.1109/WOSAR.2010.5722099', 'Software Aging and Rejuvenation', 'This paper deals with the performance analysis of a queueing system with rejuvenation controls. In particular, we describe the arrival process by the Markov-modulated Poisson process (MMPP) and consider a gradually degraded sever system. Under this situation, we discuss the system throughput of the queueing system and the optimal rejuvenation strategy maximizing the throughput based on the semi-Markov decision process in the case where the arrival and service rates are observable.', NULL);
INSERT INTO `list` VALUES (10783, '0000', 2011, 'inproceedings', 'Okamura, Hiroyuki and Dohi, Tadashi', 'A POMDP Formulation of Multistep Failure Model with Software Rejuvenation', 'Model-based', NULL, '2011 IEEE Third International Workshop on Software Aging and Rejuvenation', 'IW-SAR', NULL, NULL, '14--19', 'IEEE', '10.1109/WoSAR.2011.11', 'Software Aging and Rejuvenation', 'This paper derives a POMDP (partially observable Markov decision process) formulation for a software rejuvenation model. The POMDP is a generalized framework of MDP that handles the unobserved information. The POMDP gives qualitative insights for the effects of unobserved information based on their modeling. The main objective of this paper is to reveal the effect of system degradation information on rejuvenation strategies in a multistep failure model with rejuvenation. More specifically, we present a POMDP formulation and the optimality equations for the maximization of system availability in the multistep failure model. In a numerical example, we compare the maximum system availabilities when the system degradation is observable and unobservable and reveal the value of information on system degradation.', NULL);
INSERT INTO `list` VALUES (10784, '0000', 2017, 'inproceedings', 'Okamura, Hiroyuki and Zheng, Junjun and Dohi, Tadashi', 'A Statistical Framework on Software Aging Modeling with Continuous-Time Hidden Markov Model', 'Model-based', NULL, '2017 IEEE 36th Symposium on Reliable Distributed Systems (SRDS)', 'SRDS', NULL, NULL, '114--123', NULL, '10.1109/SRDS.2017.24', 'Software Aging and Rejuvenation', 'This paper considers the statistical approach to model software degradation process from time series data of system attributes. We first develop the continuous-time Markov chain (CTMC) model to represent the degradation level of system. By combining the CTMC with system attributes distributions, a continuous-time hidden Markov model (CT-HMM) is proposed as the basic model to represent the degradation level of system. To estimate model parameters, we develop the EM algorithm for CT-HMM. The advantage of this modeling is that the estimated model is directly applied to existing CTMC-based software aging and rejuvenation models. In numerical experiments, we exhibit the performance of our method by simulated data and also demonstrate estimating the software degradation process with experimental data in MySQL database system.', NULL);
INSERT INTO `list` VALUES (10785, '0000', 2014, 'article', 'Okamura, H. and Yamamoto, K. and Dohi, T.', 'Transient Analysis of Software Rejuvenation Policies in Virtualized System: Phase-Type Expansion Approach', 'Model-based', NULL, '2014 Quality Technology Quantitative Management', 'QTQM', NULL, NULL, NULL, NULL, '10.1080/16843703.2014.11673349', 'Software Aging and Rejuvenation', 'The phase-type expansion is applied to analyze the pointwise availability of virtual-machine (VM) based software rejuvenation with two policies; cold-VM and warm-VM rejuvenation policies. abstract HeThis paper presents a transient analysis of software rejuvenation with virtualization. In particular, we apply the phase-type expansion to analyze the pointwise availability of virtual-machine (VM) based software rejuvenation with two policies; cold-VM and warm-VM rejuvenation policies. The performance measures can be derived from the stochastic models described by labeled Markov regenerative stochastic Petri Nets (MRSPNs).', NULL);
INSERT INTO `list` VALUES (10786, '0000', 2021, 'inproceedings', 'Oliveira, Felipe and Araujo, Jean and Matos, Rubens and Maciel, Paulo', 'Software Aging in Container-based Virtualization:An Experimental Analysis on Docker Platform', 'Measurement-based', NULL, '2021 16th Iberian Conference on Information Systems and Technologies (CISTI)', 'CISTI', NULL, NULL, '1--7', NULL, '10.23919/CISTI52073.2021.9476625', 'Software Aging and Rejuvenation', 'Lightweight virtualization, and specifically containers, has become widespread in the information technology industry to provide an efficient operational environment for the execution of scalable services on the Internet. Containers rely on a set of technologies different from the features that enable hardware virtualization (i.e., hypervisor-based virtual machines). However, both types of virtualized environments are employed to host applications that will be accessible anytime, anywhere. Thus, they are prone to software aging, which usually affects systems that run for long time intervals. Researchers have identified software aging effects in distinct types of cloud computing environments and hypervisors over recent years. However, a few works have dealt with this phenomenon in container-based platforms. This paper presents an experimental analysis of the software aging effects observed on Docker platforms while also evaluating a time- series model\'s fitness to predict resource consumption\'s progress caused by software aging. We employ a stress test workload tailored for the scenario of containers arranged in a cluster managed by Docker Swarm. The obtained results indicate an increasing usage of resident memory, virtual memory, and CPU usage, as the system undergoes subsequent scale-up and scale-down operations. The quadratic trend model was the best fitting approach for predicting resident and virtual memory usage, with less than 5\\% of prediction error. The experimental approach presented here may help systems administrators detect evidence of software aging in container- based environments, allowing them to choose a proper method and time for deploying rejuvenation actions to mitigate the dependability issues raised in similar scenarios described here.', NULL);
INSERT INTO `list` VALUES (10787, '0000', 2020, 'article', 'P., Shruthi and Cholli, Nagaraj G.', 'An analysis of software aging in cloud environment', '综述', NULL, '2020 IJECE', 'IJECE', '10', '6', '5985', NULL, '10.11591/ijece.v10i6.pp5985-5991', 'Software Aging and Rejuvenation', 'Cloud computing is the environment in which several virtual machines (VM) run concurrently on physical machines. The cloud computing infrastructure hosts multiple cloud services that communicate with each other using the interfaces. During operation, the software systems accumulate errors or garbage that leads to system failure and other hazardous consequences. This status is called software aging. Software aging happens because of memory fragmentation, resource consumption in large scale and accumulation of numerical error. Software aging degrads the performance that may result in system failure. This happens because of premature resource exhaustion. The errors that cause software agings are of special types and target the response time and its environment. This issue is to be resolved only during run time as it occurs because of the dynamic nature of the problem. To alleviate the impact of software aging, software rejuvenation technique is being used. Rejuvenation process reboots the system or reinitiates the softwares. Software rejuvenation removes accumulated error conditions, frees up deadlocks and defragments operating system resources like memory. Software aging and rejuvenation has generated a lot of research interest recently. This work reviews some of the research works related to detection of software aging and identifies research gaps.', NULL);
INSERT INTO `list` VALUES (10788, '0000', 2021, 'article', 'Padhy, Neelamadhab and Panigrahi, Rasmita and Neeraja, K.', 'Threshold estimation from software metrics by using evolutionary techniques and its proposed algorithms, models', '度量', NULL, '2021 Evol. Intel.', 'Evol. Intel.', '14', '2', '315--329', NULL, '10.1007/s12065-019-00201-0', 'Software Aging and Rejuvenation', 'The software metrics play the important role in the software industry. As the software industry growing in size and complexity enhanced support is mandatory for computing and managing the software quality. Quality measurement is one of the key features of the manager in the software industry; where threshold plays the crucial role. Software measurement is necessary by means for evaluating different quality attributes and characteristics, such as size, complexity, maintainability, and usability. Instead of that effective and efficient software system is straightforward dependent on the meaning of suitable thresholds. The objective of this paper is to estimate the threshold values from software metrics by using novel evolutionary intelligence techniques. The threshold and aging software design optimization algorithms and models to prevent software aging by using machine learning (evolutionary algorithms). Apart from the above-mentioned techniques, this paper also proposed a novel threshold estimation, aging, and survivability aware (sensitive) reusability optimization model of an object-oriented software system. To expand firmness, aging and survivability aware (sensitive) optimization threshold scheme aging prediction and software rejuvenation model and algorithms proposed.', NULL);
INSERT INTO `list` VALUES (10789, '0000', 2020, 'inproceedings', 'Paing, Aye Myat Myat', 'Analysis of Availability Model Based on Software Aging in SDN Controllers with Rejuvenation', 'Model-based', NULL, '2020 IEEE Conference on Computer Applications(ICCA)', 'ICCA', NULL, NULL, '1--7', NULL, '10.1109/ICCA49400.2020.9022818', 'Software Aging and Rejuvenation', 'Deficiency of flexibility and programmability of legacy network architecture has been the concern of many networking admirers for some years. Software defined networking (SDN) is a new emerging concept to logically centralize the network control plane in order to automate the configuration of individual network elements. However, the failures of SDN controller are every large impact on the network performance and availability. There are different failure modes in SDN controller outages such as hardware and software. Unplanned downtime is mostly caused by software failure due to software aging rather than hardware failure. The aging related faults have a huge effect on the availability for software components, SDN controllers. For that reason, the work presented in this paper offers the availability model for software aging of SDN controllers by applying software rejuvenation. A stochastic reward net (SRN) is proposed to evaluate the availability assessment of a cluster of SDN controllers. And then how software rejuvenation can improve the performance of SDN controllers is studied. To evaluate the availability of proposed model, mathematical analysis is performed.', NULL);
INSERT INTO `list` VALUES (10790, '0000', 2002, 'article', 'Park, Kiejin and Kim, Sungsoo', 'Availability analysis and improvement of Active/Standby cluster systems using software rejuvenation', 'Model-based&rej', NULL, '2002 Journal of Systems and Software', 'JSS', '61', '2', '121--128', NULL, '10.1016/S0164-1212(01)00107-8', 'Software Aging and Rejuvenation', 'Semantic Scholar extracted view of \"Availability analysis and improvement of Active/Standby cluster systems using software rejuvenation\" by Kiejin Park et al.', NULL);
INSERT INTO `list` VALUES (10791, '0000', 1994, 'inproceedings', 'Parnas, D.L.', 'Software aging', '逻辑分析', NULL, '1994 Proceedings of 16th International Conference on Software Engineering', 'ICSE', NULL, NULL, '279--287', NULL, '10.1109/ICSE.1994.296790', 'Software Aging and Rejuvenation', 'Programs, like people, get old. We can\'t prevent aging, but we can understand its causes, take steps to limits its effects, temporarily reverse some of the damage it has caused, and prepare for the day when the software is no longer viable. A sign that the software engineering profession has matured will be that we lose our preoccupation with the first release and focus on the long-term health of our products. Researchers and practitioners must change their perception of the problems of software development. Only then will software engineering deserve to be called \"engineering\".\\&lt;\\&lt;ETX\\&gt;\\&gt;', NULL);
INSERT INTO `list` VALUES (10792, '0000', 2021, 'inproceedings', 'Parri, Jacopo and Sampietro, Samuele and Scommegna, Leonardo and Vicario, Enrico', 'Evaluation of software aging in component-based Web Applications subject to soft errors over time', 'testing', NULL, '2021 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)', 'ISSREW', NULL, NULL, '25--32', NULL, '10.1109/ISSREW53611.2021.00040', 'Software Aging and Rejuvenation', 'Modern Web Applications rely on architectures usually designed with modular software components whose be-haviour is shaped over fundamental principles and characteristics of the HTTP protocol. Dependency Injection frameworks support designers and developers in the automated management of components lifecycle, binding them to predefined scopes, thus delegating to an outer and independent participant the responsibility of creation, destruction and inter-dependencies definition of runtime instances. In this way, different scopes configurations implicitly act as different software micro-rejuvenation policies, emphasising the importance of choices in the assignment of component scopes; while supporting the stateful behaviour in data-retention mechanism, wider scopes may majorly expose inmemory components to software aging processes. We report a practical experience illustrating how the memory maintained in the business logic of a Web Application may give space to aging processes affecting the runtime behaviour of a stateful web application, and we show how this threat is contrasted by micro-rejuvenation at component level implemented by the container under different assignment strategies for components scopes. To this end, we propose an accelerated testing approach relying on a fault injection process that executes an event-driven simulation of arising soft errors over time. Experimentation on an exemplary web application implemented on the stack of Java Enterprise Edition show how manifestation, correction, and propagation of errors are conditioned by different scopes assigned to components by the software developer.', NULL);
INSERT INTO `list` VALUES (10793, '0000', 2018, 'inproceedings', 'Pereira, Paulo and Araujo, Jean and Matos, Rubens and Preguiça, Nuno and Maciel, Paulo', 'Software Rejuvenation in Computer Systems: An Automatic Forecasting Approach Based on Time Series', 'Measurement-based', NULL, '2018 IEEE 37th International Performance Computing and Communications Conference (IPCCC)', 'IPCCC', NULL, NULL, '1--8', NULL, '10.1109/PCCC.2018.8711347', 'Software Aging and Rejuvenation', 'Distributed computing is bringing many advantages in cost, flexibility and availability. However, it increases the demand for performance and reliability. Resources such as CPU, memory, storage and network bandwidth, are very susceptible of presenting software aging issues. Therefore, proactive actions, also known as software rejuvenation must be performed to avoid these issues. The identification of the best moment to perform software rejuvenation is not a simple task, mostly because it may affect the system\'s availability and reliability. To overcome this problem, we propose an automatic forecasting strategy to support the system administrators to choose the best moment to perform software rejuvenation. Our strategy uses six time series techniques: Drift, Simple Exponential Smoothing, Holt, Holt-Winters, Linear Regression, and ARIMA. In our proposal, the most suitable one is chosen automatically as the best fit for a particular scenario. Three case studies were performed to evaluate the efficiency of our automatic strategy. Our proposal aims to increase the system\'s availability while decreasing the QoS violation probability. In one of our experiments, we can observe a reduction of 92.3\\% in the system\'s downtime. This research supports decision making activities and opens possibilities to foster the usage of forecasting strategies when dealing with software aging phenomenon.', NULL);
INSERT INTO `list` VALUES (10794, '0000', 1996, 'article', 'Pfening, A. and Garg, S. and Puliafito, A. and Telek, M. and Trivedi, Kishor S.', 'Optimal Software Rejuvenation for Tolerating Soft Failures', 'Model-based', NULL, '1996 Perform. Evaluation（PEVA）', 'PEVA', NULL, NULL, NULL, NULL, '10.1016/0166-5316(96)00038-7', 'Software Aging and Rejuvenation', 'Semantic Scholar extracted view of \"Optimal Software Rejuvenation for Tolerating Soft Failures\" by A. Pfening et al.', NULL);
INSERT INTO `list` VALUES (10795, '0000', 2020, 'article', 'Pietrantuono, Roberto and Russo, Stefano', 'A survey on software aging and rejuvenation in the cloud', '综述', NULL, '2020 Software Qual J', 'Software Qual J', '28', '1', '7--38', NULL, '10.1007/s11219-019-09448-3', 'Software Aging and Rejuvenation', 'The adoption of cloud computing for providing resource and delivering services is an irreversible trend. For most IT companies, the quality of provided services is strongly dependent on reliability and performance of the underlying cloud technologies. A widely studied problem that can greatly affect the user experience is runtime software aging, whose main countermeasure is a proactive maintenance action known as rejuvenation. This article reviews the effort conducted so far by the software aging and rejuvenation (SAR) community in the cloud domain. A set of 105 papers has been examined from three source digital libraries in order to have a clear view of the state of the art. The paper characterizes the cloud-related SAR literature according to four dimensions: the publication trends, the aging analysis methods and metrics, the rejuvenation solutions, the validation approach. Results witness an increasing interest in this area (with 58\\% of the studies published in the last 5 years), an equivalent role of measurement-based and model-based solutions for aging analysis (42 and 40 studies, respectively) and a prevalent interest for rejuvenation (76/105 of the studies deals with rejuvenation).', NULL);
INSERT INTO `list` VALUES (10796, '0000', 2016, 'inproceedings', 'Qiao, Yu and Zheng, Zheng and Qin, Fangyun', 'An Empirical Study of Software Aging Manifestations in Android', 'Measurement-based&度量', NULL, '2016 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)', 'ISSREW', NULL, NULL, '84--90', NULL, '10.1109/ISSREW.2016.19', 'Software Aging and Rejuvenation', 'Software aging phenomenon has been widely observed in Android mobile operating system, which will make a great influence on people\'s life. In this paper we present an empirical study on the manifestations of aging-related bugs in Android operating system. By conducting a set of experiments through building various aging conditions in Android, we clarify the fact that the aging-related bugs injected in Android are with several manifestation patterns from two angles of view (Users\' and System\'s viewpoints), depending on their location (Dalvik Heap or Native Heap), process priorities (cached, persistent, background, foreground and etc.). To show the new features of software aging in Android, the differences of software aging manifestations between Android and Linux are further explored in this work.', NULL);
INSERT INTO `list` VALUES (10797, '0000', 2018, 'inproceedings', 'Qiao, Yu and Zheng, Zheng and Fang, YunYu', 'An Empirical Study on Software Aging Indicators Prediction in Android Mobile', 'Measurement-based（ML）', NULL, '2018 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)', 'ISSREW', NULL, NULL, '271--277', NULL, '10.1109/ISSREW.2018.00018', 'Software Aging and Rejuvenation', 'The requirements for high reliability, availability, and performance of mobile devices have increased significantly. Android is the most widely used mobile operating system in the world, and it is affected by software aging, resulting in poor responsiveness. This paper investigates the software aging indicators prediction in Android, focusing on aging indicators such as system\'s free physical memory and application\'s heap memory. Due to the various user behavior sequences for Android applications and system, we utilize Long Short-Term Memory Neural Network (LSTM NN), which could capture the hidden long-term dependence in a time series to predict these aging indicators. We analyze the prediction results with traditional evaluation metrics like MAPE/MSE for evaluating the whole prediction performance, and with our proposed evaluation metrics TA, FA, SVA for evaluating the trend, fluctuation, and small variation of aging indicators respectively. The results show that LSTM NN has superior performance compared with other prediction methods in the history of software aging researches. Based on the results, proactive management techniques like software rejuvenation could be scheduled by predicting the proper moment to alleviate software aging effects and increase the availability of Android mobile.', NULL);
INSERT INTO `list` VALUES (10798, '0000', 2019, 'article', 'Qiao, Yu and Zheng, Zheng and Fang, Yunyu and Qin, Fangyun and Trivedi, Kishor S. and Cai, Kai-Yuan', 'Two-Level Rejuvenation for Android Smartphones and Its Optimization', 'Hybrid&rej', NULL, '2019 IEEE Transactions on Reliability', 'Trans. Rel.', '68', '2', '633--652', NULL, '10.1109/TR.2018.2881306', 'Software Aging and Rejuvenation', 'The Android operating system (OS) is a sophisticated man-made system and is the dominant OS in the current smartphone market. Due to the accumulation of errors in the system internal state and the incremental consumption of resources, such as the Dalvik heap memory of software applications and the physical memory, software aging is observed frequently and recognized as a chronic problem of Android smartphones. To mitigate this problem, we propose a two-level software rejuvenation, with the two levels referring to software applications and the OS, in this paper. Based on this strategy, a Markov regenerative process model is constructed to evaluate the steady-state availability and to optimize the time required to trigger rejuvenation for Android smartphones. The parameters of the model, such as the degradation rate and failure rate of software applications and the Android OS, are obtained via our testing platform. Experiments on two real Android applications show that the availability of an Android smartphone increases by 10.81\\% and 10.18\\% for the two subjects in our experiments, respectively. An empirical study comparing our two-level strategy with one-level strategies (single application-level and system-level rejuvenation) further verifies the effectiveness of our approach.', NULL);
INSERT INTO `list` VALUES (10799, '0000', 2015, 'inproceedings', 'Qin, Fangyun and Zheng, Zheng and Bai, Chenggang and Qiao, Yu and Zhang, Zhenyu and Chen, Cheng', 'Cross-Project Aging Related Bug Prediction', 'testing', NULL, '2015 IEEE International Conference on Software Quality, Reliability and Security', 'QRS', NULL, NULL, '43--48', NULL, '10.1109/QRS.2015.17', 'Software Aging and Rejuvenation', 'In a long running system, software tends to encounter performance degradation and increasing failure rate during execution, which is called software aging. The bugs contributing to the phenomenon of software aging are defined as Aging Related Bugs (ARBs). Lots of manpower and economic costs will be saved if ARBs can be found in the testing phase. However, due to the low presence probability and reproducing difficulty of ARBs, it is usually hard to predict ARBs within a project. In this paper, we study whether and how ARBs can be located through cross-project prediction. We propose a transfer learning based aging related bug prediction approach (TLAP), which takes advantage of transfer learning to reduce the distribution difference between training sets and testing sets while preserving their data variance. Furthermore, in order to mitigate the severe class imbalance, class imbalance learning is conducted on the transferred latent space. Finally, we employ machine learning methods to handle the bug prediction tasks. The effectiveness of our approach is validated and evaluated by experiments on two real software systems. It indicates that after the processing of TLAP, the performance of ARB bug prediction can be dramatically improved.', NULL);
INSERT INTO `list` VALUES (10800, '0000', 2017, 'inproceedings', 'Qin, Fangyun and Zheng, Zheng and Li, Xiaodan and Qiao, Yu and Trivedi, Kishor S.', 'An Empirical Investigation of Fault Triggers in Android Operating System', '分析bug报告&Classification', NULL, '2017 IEEE 22nd Pacific Rim International Symposium on Dependable Computing (PRDC)', 'PRDC', NULL, NULL, '135--144', NULL, '10.1109/PRDC.2017.27', 'Software Aging and Rejuvenation', 'The growing popularity and complexity of Android operating system makes it prone to suffer failures during usage, which increases difficulties of fixing bugs. Different strategies and mitigation methods can be developed and applied based on different types of bugs, which gives rise to the necessity to have a deep understanding of the nature of bugs in this system. In this paper, an empirical study is taken on 513 bug reports from Android operating system. A bug classification is conducted according to fault triggering conditions, followed by the analysis of bug types and bug attributes. Moreover, the comparison of bug types between Android and Linux is carried out. This paper reveals ten interesting findings based on the empirical results from these three aspects and further provides guidance for developers and users based on these findings.', NULL);
INSERT INTO `list` VALUES (10801, '0000', 2020, 'article', 'Qin, Fangyun and Wan, Xiaohui and Yin, Beibei', 'An empirical study of factors affecting cross-project aging-related bug prediction with TLAP', 'other', NULL, '2020 Software Qual J', 'Software Qual J', '28', '1', '107--134', NULL, '10.1007/s11219-019-09460-7', 'Software Aging and Rejuvenation', 'Software aging is a phenomenon in which long-running software systems show an increasing failure rate and/or progressive performance degradation. Due to their nature, Aging-Related Bugs (ARBs) are hard to discover during software testing and are also challenging to reproduce. Therefore, automatically predicting ARBs before software release can help developers reduce ARB impact or avoid ARBs. Many bug prediction approaches have been proposed, and most of them show effectiveness in within-project prediction settings. However, due to the low presence and reproducing difficulty of ARBs, it is usually hard to collect sufficient training data to build an accurate prediction model. A recent work proposed a method named Transfer Learning based Aging-related bug Prediction (TLAP) for performing cross-project ARB prediction. Although this method considerably improves cross-project ARB prediction performance, it has been observed that its prediction result is affected by several key factors, such as the normalization methods, kernel functions, and machine learning classifiers. Therefore, this paper presents the first empirical study to examine the impact of these factors on the effectiveness of cross-project ARB prediction in terms of single-factor pattern, bigram pattern, and triplet pattern and validates the results with the Scott-Knott test technique. We find that kernel functions and classifiers are key factors affecting the effectiveness of cross-project ARB prediction, while normalization methods do not show statistical influence. In addition, the order of values in three single-factor patterns is maintained in three bigram patterns and one triplet pattern to a large extent. Similarly, the order of values in the three bigram patterns is also maintained in the triplet pattern.', NULL);
INSERT INTO `list` VALUES (10802, '0000', 2019, 'article', 'Qin, Fangyun and Zheng, Zheng and Qiao, Yu and Trivedi, Kishor S.', 'Studying Aging-Related Bug Prediction Using Cross-Project Models', 'other', NULL, '2019 IEEE Trans. Rel.', 'Trans. Rel.', '68', '3', '1134--1153', NULL, '10.1109/TR.2018.2864960', 'Software Aging and Rejuvenation', 'In long running systems, software tends to encounter performance degradation and increasing failure rate during execution. This phenomenon has been named software aging, which is caused by aging-related bugs (ARBs). Testing resource allocation can be optimized by identifying ARB-prone modules with ARB prediction. However, due to the low presence and reproducing difficulty of ARBs, it is usually hard to collect sufficient training data to carry out within-project ARB prediction. In this paper, we propose an approach named transfer learning based aging-related bug prediction (TLAP) to perform cross-project ARB prediction. TLAP first takes advantage of transfer learning to reduce distribution difference between training and testing project. Then, class imbalance learning is conducted to mitigate the severe class imbalance between ARB-prone and ARB-free modules. Finally, machine learning methods are used to handle bug prediction tasks. The effectiveness of this approach is validated and evaluated by nine groups of experiments on real software systems. Major conclusions from the experiments include the following: first, TLAP improves cross-project ARB prediction on average compared with traditional machine learning methods; second, utilizing information from multiple-projects can further improve the prediction performance on average. In the best case, it outperforms within-project prediction; third, the number of ARB-prone files and distribution similarity can influence TLAP performance.', NULL);
INSERT INTO `list` VALUES (10803, '0000', 2022, 'article', 'Rahman, Tajmilur and Nwokeji, Joshua C. and Manjunath, Tejas', 'Analysis of Current Trends in Software Aging: A Literature Survey', NULL, NULL, '2022 Computer and Information Science', 'CIS', NULL, NULL, NULL, NULL, 'https://www.semanticscholar.org/paper/Analysis-of-Current-Trends-in-Software-Aging%3A-A-Rahman-Nwokeji/60724d754e1939e6d26236de803ea84610b16e8a', 'Software Aging and Rejuvenation', 'Using recursive literature review (RLR) and Bootstrapping techniques, this research identifies and analyzes the causes of software aging and architecture degradation in software systems and found that architectural degradation is one of the key reasons that causeSoftware aging and acts as a barrier to the sustainability of software architecture. Software aging and architecture degradation are important areas in software quality assurance. Existing research in these areas has developed mitigation strategies for software aging, other researchers have analyzed strategies for identifying software aging. Regarding architectural degradation, current studies have designed techniques for reducing degradation. However, there appears to be a paucity of studies on the causes of software aging and architectural degradation. Insight into the causes of software aging and architectural degradation can provide a critical perspective and further strengthen the research endeavors on prevention techniques. Using recursive literature review (RLR) and Bootstrapping techniques, this research identifies and analyzes the causes of software aging and architecture degradation in software systems. We found that besides many other causes, architectural degradation is one of the key reasons that cause software aging and acts as a barrier to the sustainability of software architecture.', NULL);
INSERT INTO `list` VALUES (10804, '0000', 2015, 'article', 'Rahme, Jean and Xu, Haiping', 'A Software Reliability Model for Cloud-Based Software Rejuvenation Using Dynamic Fault Trees', 'Model-based', NULL, '2015 Int. J. Softw. Eng. Knowl. Eng.', 'Int. J. Softw. Eng. Knowl. Eng.', NULL, NULL, NULL, NULL, '10.1142/S021819401540029X', 'Software Aging and Rejuvenation', 'The dynamic fault tree (DFT) formalism is adopted and it is shown how cost-effective software rejuvenation schedules can be created to keep the system reliability consistently staying above a predefined critical level. Correctly measuring the reliability and availability of a cloud-based system is critical for evaluating its system performance. Due to the promised high reliability of physical facilities provided for cloud services, software faults have become one of the major factors for the failures of cloud-based systems. In this paper, we focus on the software aging phenomenon where system performance may be progressively degraded due to exhaustion of system resources, fragmentation and accumulation of errors. We use a proactive technique, called software rejuvenation, to counteract the software aging problem. The dynamic fault tree (DFT) formalism is adopted to model the system reliability before and during a software rejuvenation process in an aging cloud-based system. A novel analytical approach is presented to derive the reliability function of a cloud-based Hot SPare (HSP) gate, which is further verified using Continuous Time Markov Chains (CTMC) for its correctness. We use a case study of a cloud-based system to illustrate the validity of our approach. Based on the reliability analytical results, we show how cost-effective software rejuvenation schedules can be created to keep the system reliability consistently staying above a predefined critical level.', NULL);
INSERT INTO `list` VALUES (10805, '0000', 2010, 'inproceedings', 'Reinecke, Philipp and Wolter, Katinka', 'A simulation study on the effectiveness of restart and rejuvenation to mitigate the effects of software ageing', 'rej', NULL, '2010 IEEE Second International Workshop on Software Aging and Rejuvenation', 'IW-SAR', NULL, NULL, '1--6', NULL, '10.1109/WOSAR.2010.5722100', 'Software Aging and Rejuvenation', 'We study the effectiveness of client-side restart and server-side rejuvenation on a system that suffers from software ageing due to memory leaks. An implicit and an explicit model for software ageing are studied. We consider system and service unavailability as measures for the availability of the server.', NULL);
INSERT INTO `list` VALUES (10806, '0000', 2010, 'inproceedings', 'Rezaei, Arash and Sharifi, Mohsen', 'Rejuvenating High Available Virtualized Systems', 'Model-based', NULL, '2010 International Conference on Availability, Reliability and Security', 'ARES', NULL, NULL, '289--294', NULL, '10.1109/ARES.2010.69', 'Software Aging and Rejuvenation', 'Virtualization technology in the form of server consolidation makes running of hot-standby replicas on one system possible, while software rejuvenation provides proactive recovery of failure. Both technologies have been used to make systems more dependable. However, the deployment of rejuvenation in virtualized systems had been limited only to virtual machines (VMs) or only to virtual machine monitors (VMMs), requiring changes to applications too. We propose a new rejuvenation technique for high available virtualized systems that is applied at both VM and VMM levels and yet it does not require any modifications to applications. Our proposition leverages the encapsulation of an application into a VM using this new combinatory rejuvenation technique that uses a time-based policy for VMM and a prediction-based policy for VMs. To demonstrate how much it can improve system availability, the stochastic reward net-based models of a typical virtualized consolidated server in cases of using a prediction-based policy, using a time-based policy, and using the proposed rejuvenation technique are presented and compared. We show that our method has higher system availability and lower downtime cost.', NULL);
INSERT INTO `list` VALUES (10807, '0000', 2010, 'article', 'Salfner, F. and Wolter, K.', 'Analysis of service availability for time-triggered rejuvenation policies', 'Model-based', NULL, '2010 Journal of Systems and Software', 'JSS', '83', '9', '1579--1590', NULL, '10.1016/j.jss.2010.05.022', 'Software Aging and Rejuvenation', 'In this paper we investigate the effect of three time-triggered system rejuvenation policies on service availability using a queuing model. The model is formulated as an extended stochastic Petri net using a variety of distributions for times between state changes. We define a metric for steady-state service availability and derive how it can be estimated from the models in a hybrid approach combining simulation and analytical reasoning. We further analyze time-to-failure of systems with rejuvenation. Experiments show that the optimal rejuvenation interval as well as the achievable service availability improvement depend significantly on system utilization. The experiments also show that service availability can deviate significantly from steady-state system availability. For low utilization all rejuvenation policies perform well. For medium utilization, one policy is significantly inferior to the other two, while for high utilization, no rejuvenation should be performed at all.', NULL);
INSERT INTO `list` VALUES (10808, '0000', 2017, 'inproceedings', 'Umesh, I. M. and Srinivasan, G N.', 'Dynamic Software Aging Detection-Based Fault Tolerant Software Rejuvenation Model for Virtualized Environment', 'Model-based&other', NULL, '2017 Proceedings of the International Conference on Data Engineering and Communication Technology', 'ICDECT', '469', NULL, '779--787', 'Springer Singapore', '10.1007/978-981-10-1678-3_75', 'Software Aging and Rejuvenation', 'Cloud computing has emerged as one of the most inevitable technologies that encompasses huge software components and functional entities, which during operation accumulates errors or garbage, thus causing software aging. Software aging can cause system failure and hazardous consequences, and therefore to deal with it, a technique called software rejuvenation is proposed that reboots or re-initiates the software to avoid fault or failure. Conventional approaches still suffer from higher downtime resulting in decreased performance and unavailability. In this paper, a controller based dynamic software aging detection and fault tolerant rejuvenation model has been proposed. This model has been implemented in a live virtual migration environment to ensure resource security during virtualization. In addition, the proposed checkpoint and log detail based migration has eliminated the probability of downtime which is highly significant for realistic applications.', NULL);
INSERT INTO `list` VALUES (10809, '0000', 2003, 'inproceedings', 'Shereshevsky, M. and Crowell, J. and Cukic, B. and Gandikota, V. and Yan Liu', 'Software aging and multifractality of memory resources', 'Measurement-based', NULL, '2003 International Conference on Dependable Systems and Networks, 2003. Proceedings.', 'DSN', NULL, NULL, '721--730', NULL, '10.1109/DSN.2003.1209987', 'Software Aging and Rejuvenation', 'We investigate the dynamics of monitored memory resource utilizations in an operating system under stress using quantitative methods of fractal analysis. In the experiments, we recorded the time series representing various memory related parameters of the operating system. We observed that parameters demonstrate clear multifractal behavior. The degree of fractality of these time series tends to increase as the system workload increases. We conjecture that the H¨ older exponent that measures the local rate of fractality may be used as a quantitative measure of software aging. We propose a simple proactive computer crash avoidance strategy based on the online fractal analysis of system memory resource observations.', NULL);
INSERT INTO `list` VALUES (10810, '0000', 2008, 'inproceedings', 'Shetty, Hitesh and Nambiar, Manoj and Kalita, Hemanta', 'Analysis and application of conditional software rejuvenation — A new approach', 'Measurement-based（阈值）', NULL, '2008 IEEE International Conference on Software Reliability Engineering Workshops (ISSRE Wksp)', 'ISSREW', NULL, NULL, '1--5', NULL, '10.1109/ISSREW.2008.5355522', 'Software Aging and Rejuvenation', 'Software aging effects if left uncontrolled are known to cause availability issues. When an application is serving live in production, fixing such issues is close to impossible. Software rejuvenation techniques can be used effectively to avoid failure, but will incur some downtime if a single instance of the application is running. With two instances the system can be engineered in such a way that there is at least one instance running at any time. There may be further reduction in operating expenses if an intelligent program can take charge of executing rejuvenation tasks as required. This paper describes the implementation of such closed loop software rejuvenation in a real world application and the resulting improvement in availability thereof.', NULL);
INSERT INTO `list` VALUES (10811, '0000', 2006, 'inproceedings', 'Silva, L. and Madeira, H. and Silva, J.G.', 'Software Aging and Rejuvenation in a SOAP-based Server', 'Measurement-based（阈值）', NULL, '2006 Fifth IEEE International Symposium on Network Computing and Applications (NCA\'06)', 'NCA', NULL, NULL, '56--65', NULL, '10.1109/NCA.2006.51', 'Software Aging and Rejuvenation', 'Web-services and service-oriented architectures are gaining momentum in the area of distributed systems and Internet applications. However, as we increase the abstraction level of the applications we are also increasing the complexity of the underlying middleware. In this paper, we present a dependability benchmarking study to evaluate and compare the robustness of some of the most popular SOAP-RPC implementations that are intensively used in the industry. The study was focused on Apache Axis where we have observed a high susceptibility of software aging. Building on these results we propose a new SLA-oriented software rejuvenation technique that proved to be a simple way to increase the dependability of the SOAP-server, the degree of self-healing and to maintain a sustained level of performance in the applications', NULL);
INSERT INTO `list` VALUES (10812, '0000', 2009, 'article', 'Silva, Luis Moura and Alonso, Javier and Torres, Jordi', 'Using Virtualization to Improve Software Rejuvenation', 'rej', NULL, '2009 IEEE Transactions on Computers', 'TC', '58', NULL, '1525--1538', NULL, '10.1109/TC.2009.119', 'Software Aging and Rejuvenation', 'In this paper, we present an approach for software rejuvenation based on automated self-healing techniques that can be easily applied to off-the-shelf application servers. Software aging and transient failures are detected through continuous monitoring of system data and performability metrics of the application server. If some anomalous behavior is identified, the system triggers an automatic rejuvenation action. This self-healing scheme is meant to disrupt the running service for a minimal amount of time, achieving zero downtime in most cases. In our scheme, we exploit the usage of virtualization to optimize the self-recovery actions. The techniques described in this paper have been tested with a set of open-source Linux tools and the XEN virtualization middleware. We conducted an experimental study with two application benchmarks (Tomcat/Axis and TPC-W). Our results demonstrate that virtualization can be extremely helpful for failover and software rejuvenation in the occurrence of transient failures and software aging.', NULL);
INSERT INTO `list` VALUES (10813, '0000', 2017, 'inproceedings', 'Sukhwani, Harish and Matias, Rivalino and Trivedi, Kishor S. and Rindos, Andy', 'Monitoring and Mitigating Software Aging on IBM Cloud Controller System', 'Measurement-based', NULL, '2017 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)', 'ISSREW', NULL, NULL, '266--272', NULL, '10.1109/ISSREW.2017.65', 'Software Aging and Rejuvenation', 'As enterprises continue to move their workloads from traditional server-room environments to private cloud-based systems, there is an increasing desire and ability for companies like IBM to centrally monitor the systems on behalf of their customers to proactively help to mitigate any potential failure scenarios. In this paper, we investigate failures caused by software aging affecting an enterprise-class cloud controller system. We describe a service developed to continuously analyze the key system/application metrics from customer systems, identifies potential aging-related failure scenarios within the next two days, and generates a list of tasks for the development-operations team at IBM to mitigate the potential failures. To help the team prioritize the tasks, we propose a prioritization scheme to assign severity to such tasks. From our analysis of two months of offline data, we find that the tasks generated have a precision of around 0.80 and recall of 1, which means that our approach did not miss any aging-related failure event, with around 80\\% of the failure events being true.', NULL);
INSERT INTO `list` VALUES (10814, '0000', 2007, 'inproceedings', 'Sundaram, Vinaitheerthan and HomChaudhuri, Sandip and Garg, Sachin and Kintala, Chandra and Bagchi, Saurabh', 'Improving Dependability Using Shared Supplementary Memory and Opportunistic Micro Rejuvenation in Multi-tasking Embedded Systems', 'rej', NULL, '2007 13th Pacific Rim International Symposium on Dependable Computing (PRDC 2007)', 'PRDC', NULL, NULL, '240--247', NULL, '10.1109/PRDC.2007.54', 'Software Aging and Rejuvenation', 'We propose a comprehensive solution to handle memory-overflow problems in multitasking embedded systems thereby improving their reliability and availability. In particular, we propose two complementary techniques to address two significant causes of memory-overflow problems. The first cause is errors in estimating appropriate stack and heap memory requirement. Our first technique, called shared supplementary memory (SSM), exploits the fact that the probability of multiple tasks requiring more than their estimated amount of memory concurrently is low. Using analytical model and simulations, we show that reliability can be considerably improved when SSM is employed. Furthermore, for the same reliability, SSM reduces total memory requirement by as much as 29.31\\% The second cause is the presence of coding Mandelbugs, which can cause abnormal memory requirement. To address this, we propose a novel technique, called opportunistic micro-rejuvenation, which when combined with SSM, provide several advantages: preventing critical-time outage, resource frugality and dependability enhancement.', NULL);
INSERT INTO `list` VALUES (10815, '0000', 2010, 'article', 'Sundararaman, Swaminathan and Subramanian, Sriram and Rajimwale, Abhishek and Arpaci-Dusseau, Andrea C. and Arpaci-Dusseau, Remzi H. and Swift, Michael M.', 'Membrane: Operating system support for restartable file systems', 'rej', NULL, '2010 ACM Trans. Storage', 'ACM Trans. Storage', '6', '3', '1--30', NULL, '10.1145/1837915.1837919', 'Software Aging and Rejuvenation', 'We introduce Membrane, a set of changes to the operating system to support restartable file systems. Membrane allows an operating system to tolerate a broad class of file system failures, and does so while remaining transparent to running applications; upon failure, the file system restarts, its state is restored, and pending application requests are serviced as if no failure had occurred. Membrane provides transparent recovery through a lightweight logging and checkpoint infrastructure, and includes novel techniques to improve performance and correctness of its fault-anticipation and recovery machinery. We tested Membrane with ext2, ext3, and VFAT. Through experimentation, we show that Membrane induces little performance overhead and can tolerate a wide range of file system crashes. More critically, Membrane does so with little or no change to existing file systems, thus improving robustness to crashes without mandating intrusive changes to existing file-system code.', NULL);
INSERT INTO `list` VALUES (10816, '0000', 2003, 'inproceedings', 'Suzuki, H. and Dohi, T. and Kaio, N. and Trivedi, K.S.', 'Maximizing interval reliability in operational software system with rejuvenation', 'Model-based', NULL, '2003 14th International Symposium on Software Reliability Engineering, 2003. ISSRE 2003.', 'ISSRE', NULL, NULL, '479--490', NULL, '10.1109/ISSRE.2003.1251068', 'Software Aging and Rejuvenation', 'Software aging often affects the performance of a software system and eventually causes it to fail. A novel approach to handle transient software failures is called software rejuvenation which can be regarded as a preventive and proactive solution that is particularly useful for counteracting the phenomenon of software aging. In this paper, we consider the optimal software rejuvenation policy maximizing the interval reliability in the general semi-Markov framework. We derive analytically the optimal software rejuvenation timing which maximizes the limiting interval reliability or the interval reliability with exponentially distributed operation times. Further, we examine numerically the transient behavior of the interval reliability at an arbitrary operation time. Our results under the interval reliability criteria are extentions of some earlier work, since the interval reliability can be specialized to the pointwise availability and the common reliability function.', NULL);
INSERT INTO `list` VALUES (10817, '0000', 2006, 'article', 'Swift, Michael M. and Annamalai, Muthukaruppan and Bershad, Brian N. and Levy, Henry M.', 'Recovering device drivers', 'rej', NULL, '2006 ACM Trans. Comput. Syst.', 'ACM Trans. Comput. Syst.', '24', '4', '333--360', NULL, '10.1145/1189256.1189257', 'Software Aging and Rejuvenation', 'This article presents a new mechanism that enables applications to run correctly when device drivers fail. Because device drivers are the principal failing component in most systems, reducing driver-induced failures greatly improves overall reliability. Earlier work has shown that an operating system can survive driver failures [Swift et al. 2005], but the applications that depend on them cannot. Thus, while operating system reliability was greatly improved, application reliability generally was not.To remedy this situation, we introduce a new operating system mechanism called a\r\nshadow driver\r\n. A shadow driver monitors device drivers and transparently recovers from driver failures. Moreover, it assumes the role of the failed driver during recovery. In this way, applications using the failed driver, as well as the kernel itself, continue to function as expected.We implemented shadow drivers for the Linux operating system and tested them on over a dozen device drivers. Our results show that applications and the OS can indeed survive the failure of a variety of device drivers. Moreover, shadow drivers impose minimal performance overhead. Lastly, they can be introduced with only modest changes to the OS kernel and with no changes at all to existing device drivers.', NULL);
INSERT INTO `list` VALUES (10818, '0000', 1997, 'inproceedings', 'Tai, A.T. and Chau, S.N. and Alkalaj, L. and Hecht, H.', 'On-board preventive maintenance: analysis of effectiveness and optimal duty period', 'Model-based', NULL, '1997 Proceedings Third International Workshop on Object-Oriented Real-Time Dependable Systems', 'WORDS', NULL, NULL, '40--47', NULL, '10.1109/WORDS.1997.609924', 'Software Aging and Rejuvenation', 'To maximize the reliability of a spacecraft which performs a long-life (over 10-year) deep-space mission (to an outer planet), a fault-tolerant environment incorporating on-board preventive maintenance is highly desirable. In this paper, we present an initial model-based study which identifies the key factors for the reliability gained from on-board preventive maintenance and demonstrates the capability of analytic modeling in determining the optimal interval between maintenance (duty period).', NULL);
INSERT INTO `list` VALUES (10819, '0000', 2005, 'inproceedings', 'Tai, A.T. and Tso, K.S. and Sanders, W.H. and Chau, S.N.', 'A performability-oriented software rejuvenation framework for distributed applications', 'Hybrid', NULL, '2005 International Conference on Dependable Systems and Networks (DSN\'05)', 'DSN', NULL, NULL, '570--579', NULL, '10.1109/DSN.2005.12', 'Software Aging and Rejuvenation', 'While inherent resource redundancies in distributed applications facilitate gracefully degradable services, methods to enhance their dependability may have subtle, yet significant, performance implications, especially when such applications are stateful in nature. In this paper, we present a performability-oriented framework that enables the realization of software rejuvenation in stateful distributed applications. The framework is constructed based on three building blocks, namely, a rejuvenation algorithm, a set of performability metrics, and a performability model. We demonstrate via model-based evaluation that this framework enables error-accumulation-prone distributed applications to deliver services at the best possible performance level, even in environments in which a system is highly vulnerable to failures.', NULL);
INSERT INTO `list` VALUES (10820, '0000', 2021, 'inproceedings', 'Tan, Xueyong and Liu, Jing', 'ACLM:Software Aging Prediction of Virtual Machine Monitor Based on Attention Mechanism of CNN-LSTM Model', 'Measurement-based（ML）', NULL, '2021 IEEE 21st International Conference on Software Quality, Reliability and Security (QRS)', 'QRS', NULL, NULL, '759--767', NULL, '10.1109/QRS54544.2021.00085', 'Software Aging and Rejuvenation', 'Because Virtual Machine Monitor (VMM) runs continuously with high load for a long time, the accumulated errors in the system can easily lead to software aging problems such as performance degradation, so that it can not provide high-quality software services. However, software rejuvenation techniques can improve the performance of software systems by cleaning up the aging factor. Therefore, how to accurately predict the occurrence time of software aging in VMM system is a crucial and valuable problem. This paper proposes a novel software aging prediction model, called the ACLM model, which integrates the Attention mechanism, the Convolutional Neural Network (CNN) and the Long Short-term Memory (LSTM) model. It can extract the temporal and spatial features of the time series more quickly and effectively. The experimental results show that compared with other models, the ACLM model has improved by 0.97\\% to 9.33 \\% and 1.48 \\% to 5.49 \\% on the MAE and the RMSE, which demonstrates that the ACLM model has higher accuracy in predicting software aging of the VMM.', NULL);
INSERT INTO `list` VALUES (10821, '0000', 2020, 'inproceedings', 'Tang, Minghao and Zhang, Peng and Sun, Haoqi and Zhang, Lei', 'A Task Execution Framework Based on Aging Indicator and SARIMI', 'Measurement-based', NULL, '2020 IEEE Intl Conf on Parallel Distributed Processing with Applications, Big Data Cloud Computing, Sustainable Computing Communications, Social Computing Networking (ISPA/BDCloud/SocialCom/SustainCom)', 'ISPA', NULL, NULL, '18--25', NULL, '10.1109/ISPA-BDCloud-SocialCom-SustainCom51426.2020.00029', 'Software Aging and Rejuvenation', 'The long-term running characteristics of spatiotemporal related tasks increase the risk of software aging of the basic supporting software of cloud platform, such as operating system, virtual machine and virtual machine monitor, and reduce the stability of platform services. In addition, software aging, as a process that accumulates over time, does not immediately cause system function failure. Moreover, the existing time series analysis methods do not give enough consideration to the seasonality of load characteristics, which makes it difficult to accurately determine the degree of software aging and the time of software rejuvenation. Therefore, this paper proposes a task execution method integrated with software rejuvenation means. Through the detection and evaluation of software aging, when the virtual machine aging reaches a certain extent, the rejuvenation module will be started to restore the service capacity of the virtual machine in time, so as to improve the task execution efficiency. And through the use of aging indicator and the software aging evaluation method based on Multiplicative Seasonal Autoregressive Integrated Moving Average (SARIMA), the current software aging situation and the periodicity of the system load are considered. At the same time, the dynamic trend of software aging is evaluated, and the software is rejuvenated near the optimal rejuvenation time point, which improves the applicability of resource aging evaluation and task execution efficiency in the cloud platform. Experimental results show that our method is effective in the aging of cloud platform software.', NULL);
INSERT INTO `list` VALUES (10822, '0000', 2014, 'phdthesis', 'Tenkanen, Sayed', 'User experienced software aging: test environment, testing and improvement suggestions', 'Measurement-based', NULL, 'not found', 'Phd', NULL, NULL, NULL, NULL, 'https://trepo.tuni.fi/handle/10024/96592', 'Software Aging and Rejuvenation', 'Software aging is empirically observed in software systems in a variety of manifestations ranging from slower performance to various failures as reported by users. Unlike hardware aging, where in its lifetime hardware goes through wear and tear resulting in an increased rate of failure after certain stable use conditions, software aging is a result of software bugs. Such bugs are always present in the software but may not make themselves known unless a set of preconditions are met. When activated, software bugs may result in slower performance and contribute to user dissatisfaction. However, the impact of software bugs on PCs and mobile phones is different as their uses are different. A PC is often turned off or rebooted on an average of every seven days, but a mobile device may continue to be used without a reboot for much longer. The prolonged operation period of mobile devices thus opens up opportunities for software bugs to be activated more often compared to PCs. Therefore, software aging in mobile devices, a considerable challenge to the ultimate user experience, is the focus of this thesis. The study was done in three consecutive phases: firstly, a test environment was set up; secondly, mobile device was tested as a human user would use under ordinary-use circumstances and finally, suggestions were made on future testing implementations. To this end, a LG Nexus 4 was setup in an automated test environment that simulates a regular user s use conditions and executes a set of human user use cases, and gathers data on consumption of power as well as reaction and response times in the various interactions. The results showed that an operating system agnostic test environment can be constructed with a limited number of equipment that is capable of simulating a regular user s use cases as a user would interact with a mobile device to measure user experienced software aging.', NULL);
INSERT INTO `list` VALUES (10823, '0000', 2017, 'inproceedings', 'Torquato, Matheus and Maciel, Paulo and Araujo, Jean and Umesh, I. M.', 'An approach to investigate aging symptoms and rejuvenation effectiveness on software systems', 'Measurement-based', NULL, '2017 12th Iberian Conference on Information Systems and Technologies (CISTI)', 'CISTI', NULL, NULL, '1--6', NULL, '10.23919/CISTI.2017.7975806', 'Software Aging and Rejuvenation', 'Software aging is a cumulative process which can lead long-running systems to failures. Software rejuvenation is the countermeasure of software aging. Rejuvenation actions usually comprise system reboot or application restart. Software aging appears as a significant concern for the reliability of software systems. Therefore, techniques and methods to analyze software aging and rejuvenation are of utmost importance. This paper proposes an approach based on experiments and empirical observation to investigate aging and rejuvenation on software systems. The approach has three phases: (i) Stress Phase - stress environment with the accelerated workload to induce bugs activation; (ii) Wait - stop workload submission to observe impact caused in software status; (iii) Rejuvenation Phase - submit rejuvenation action to perceive changes in the software internal state. To validate the proposed approach this paper presents a case study. This case study consists of an experiment of VM Live Migration as rejuvenation mechanism for VMM software aging. The considered testbed is a private Cloud with OpenNebula and KVM 1.0. The obtained results show that VM live migration is effective as rejuvenation for VMM software aging.', NULL);
INSERT INTO `list` VALUES (10824, '0000', 2019, 'inproceedings', 'Torquato, Matheus and Vieira, Marco', 'An Experimental Study of Software Aging and Rejuvenation in Dockerd', 'Measurement-based', NULL, '2019 15th European Dependable Computing Conference (EDCC)', 'EDCC', NULL, NULL, '1--6', NULL, '10.1109/EDCC.2019.00014', 'Software Aging and Rejuvenation', 'Virtualized containers are being extensively used to host applications as they substantially reduce the overhead caused by conventional virtualization techniques. Therefore, as containers adoption grows, the need for dependability also increases. Dockerd, the process that is in charge of Docker containers management, is supposed to support long-running systems, which makes it prone to the well-known problem of software aging. This paper presents an experimental study of software aging and rejuvenation targeting the dockerd daemon. We used the SWARE approach to conduct the experimentation, which encompasses three phases: i) stress - stress environment with the accelerated workload to induce bugs activation; ii) wait - stop the workload submission to observe possible accumulated effects and; iii) rejuvenation - submit a rejuvenation action to perceive changes in the internal software state. The experiment runs for 26 days, and results show that dockerd suffers from software aging effects after the stress phase. The accumulated effects remain in the system until a complete cleanup, comprising removing all the containers and rebooting the operating system.', NULL);
INSERT INTO `list` VALUES (10825, '0000', 2018, 'article', 'Torquato, Matheus and Araujo, Jean and Umesh, I. M. and Maciel, Paulo', 'SWARE: A Methodology for Software Aging and Rejuvenation Experiments', 'Measurement-based', NULL, '2018 Journal of Information Systems Engineering Management', 'JISEM', '3', '2', NULL, NULL, '10.20897/jisem.201815', 'Software Aging and Rejuvenation', 'Reliability and availability are mandatory requirements for numerous applications. Technical apparatus to study system dependability is essential to support software deployment and maintenance. Software aging is a related issue in this context. Software aging is a cumulative process which leads systems with long-running execution to hangs or failures. Software rejuvenation is used to prevent software aging problems. Software rejuvenation actions comprise system reboot or application restart to bringing software to a stable fresh state. This paper proposes a methodology to conduct software aging and software rejuvenation experiments. The approach has three phases: (i) Stress Phase - stress environment with the accelerated workload to induce bugs activation; (ii) Wait Phase - stop workload submission to observe the system state after workload submission; (iii) Rejuvenation Phase - find the impacts caused by the software rejuvenation. We named our methodology as SWARE (Stress-Wait-Rejuvenation). To validate the SWARE methodology, we present a case study. This case study consists of an experiment of VM Live Migration as rejuvenation mechanism for VMM software aging. The considered testbed is a Private Cloud with OpenNebula and KVM 1.0. The obtained results show that VM live migration is useful as rejuvenation for VMM software aging.', NULL);
INSERT INTO `list` VALUES (10826, '0000', 2000, 'article', 'Trivedi, K.S. and Vaidyanathan, K. and Goseva-Popstojanova, K.', 'Modeling and analysis of software aging and rejuvenation', 'Model-based', NULL, '2000 Proceedings 33rd Annual Simulation Symposium (SS 2000)', 'SS', NULL, NULL, '270--279', NULL, '10.1109/SIMSYM.2000.844925', 'Software Aging and Rejuvenation', 'Software systems are known to suffer from outages due to transient errors. Recently, the phenomenon of \"software aging\", one in which the state of the software system degrades with time, has been reported. To counteract this phenomenon, a proactive approach of fault management, called \"software rejuvenation\", has been proposed. This essentially involves gracefully terminating an application or a system and restarting it in a clean internal state. We discuss stochastic models to evaluate the effectiveness of proactive fault management in operational software systems and determine optimal times to perform rejuvenation, for different scenarios. The latter part of the paper deals with measurement-based methodologies to detect software aging and estimate its effect on various system resources. Models are constructed using workload and resource usage data collected from the UNIX operating system over a period of time. The measurement-based models are intended to help development of strategies for software rejuvenation triggered by actual measurements.', NULL);
INSERT INTO `list` VALUES (10827, '0000', 2017, 'article', 'Umesh, I M and Srinivasan, G N and Torquato, Matheus', 'Software Aging Forecasting Using Time Series Model', 'Measurement-based', NULL, '2017 IJEECS', 'IJEECS', '7', '3', '839', NULL, '10.11591/ijeecs.v7.i3.pp839-845', 'Software Aging and Rejuvenation', '{\\textless}p class=\"Normal1\"{\\textgreater}With the emergence of virtualization and cloud computing technologies, several services are housed on virtualization platform. Virtualization is the technology that many cloud service providers rely on for efficient management and coordination of the resource pool. As essential services are also housed on cloud platform, it is necessary to ensure continuous availability by implementing all necessary measures.  Windows Active Directory is one such service that Microsoft developed for Windows domain networks. It is included in Windows Server  operating systems as a set of processes and services for authentication and authorization of users and computers in a Windows domain type network. The service is required to run continuously without downtime. As a result, there are chances of accumulation of errors or garbage leading to software aging which in turn may lead to system failure and associated consequences. This results in software aging. In this work, software aging patterns of Windows active directory service is studied. Software aging of active directory needs to be predicted properly so that rejuvenation can be triggered to ensure continuous service delivery. In order to predict the accurate time, a model that uses time series forecasting technique is built.{\\textless}/p{\\textgreater}', NULL);
INSERT INTO `list` VALUES (10828, '0000', 2017, 'inproceedings', 'Umesh, I. and Torquato, Matheus', 'Software Rejuvenation Model for Cloud Computing Platform', NULL, NULL, '2017 International Journal of Applied Engineering Research', 'IJAER', NULL, NULL, NULL, NULL, 'https://www.semanticscholar.org/paper/Software-Rejuvenation-Model-for-Cloud-Computing-Umesh-Torquato/d715180d3cd6ee2337657929f1209892578d65d2', 'Software Aging and Rejuvenation', 'Cloud computing has emerged as one of the most needed technologies that houses software systems and relevant functional entities resulting in complex, multiuser, multitasking and virtualized environments. However, reliability of such high performance computing systems depends both on hardware and software. Virtualization is the technology that many cloud service providers rely on for efficient management and coordination of the resource pool. The software systems, during operation accumulate errors or garbage leading to software aging which may lead to system failure and associated consequences. Software aging needs to be dealt with specialized techniques to facilitate continuous service delivery. To deal with software aging, a technique called software rejuvenation exists that reboots or re-initiates the software to avoid fault or failure. As cloud service run on virtual environments, impacts of aging in virtual environments needs to be addressed. The VMs run on a Virtual Machine Monitor (VMM) also called as hypervisor which is liable to suffer failures or hangs due to software aging. This paper explores how the aging of Virtual Machine monitors can be addressed. Once the aging patterns of VMM are detected, the Virtual Machines running on it are migrated to healthy VMM; aged VMM is rejuvenated and VMs are migrated back. After rejuvenation, the hypervisor supports the operation of VMs in an improved state.', NULL);
INSERT INTO `list` VALUES (10829, '0000', 2001, 'inproceedings', 'Vaidyanathan, Kalyanaraman and Harper, Richard E. and Hunter, Steven W. and Trivedi, Kishor S.', 'Analysis and implementation of software rejuvenation in cluster systems', 'Model-based', NULL, '2001 Proceedings of the 2001 ACM SIGMETRICS international conference on Measurement and modeling of computer systems', 'SIGMETRICS ', NULL, NULL, '62--71', NULL, '10.1145/378420.378434', 'Software Aging and Rejuvenation', NULL, NULL);
INSERT INTO `list` VALUES (10830, '0000', 2002, 'article', 'Vaidyanathan, K. and Selvamuthu, D. and Trivedi, K.S.', 'Analysis of inspection-based preventive maintenance in operational software systems', 'Model-based', NULL, '2002 21st IEEE Symposium on Reliable Distributed Systems, 2002. Proceedings.', 'SRDS', NULL, NULL, '286--295', NULL, '10.1109/RELDIS.2002.1180199', 'Software Aging and Rejuvenation', 'Recently, the phenomenon of \"software aging\", one in which the state of a software system gradually degrades with time and eventually leads to performance degradation or crash/hang failure, has been reported. Preventive maintenance of operational software systems is used specifically to counteract this phenomenon. However preventive maintenance incurs an overhead in terms of downtime and cost and this must be traded off with the cost of failures to obtain maximum benefits. We present an analytical model of a software system employing inspection-based preventive maintenance, through a Markov Regenerative Process (MRGP) with a subordinated semi-Markov reward process. Furthermore, we consider preemptive-resume type transitions. The model is solved for steady state as well as transient conditions and expressions for expected downtime and expected cost are derived. Numerical examples are presented to illustrate the applicability of the models. With the help of these models, optimal strategies for preventive maintenance techniques such as \"software rejuvenation\" could be formulated.', NULL);
INSERT INTO `list` VALUES (10831, '0000', 2005, 'article', 'Vaidyanathan, K. and Trivedi, K.S.', 'A Comprehensive Model for Software Rejuvenation', 'Hybrid', NULL, '2005 IEEE Trans. Dependable and Secure Comput.', 'Trans. Dependable and Secure Comput.', '2', '2', '124--137', NULL, '10.1109/TDSC.2005.15', 'Software Aging and Rejuvenation', 'Recently, the phenomenon of software aging, one in which the state of the software system degrades with time, has been reported. This phenomenon, which may eventually lead to system performance degradation and/or crash/hang failure, is the result of exhaustion of operating system resources, data corruption, and numerical error accumulation. To counteract software aging, a technique called software rejuvenation has been proposed, which essentially involves occasionally terminating an application or a system, cleaning its internal state and/or its environment, and restarting it. Since rejuvenation incurs an overhead, an important research issue is to determine optimal times to initiate this action. In this paper, we first describe how to include faults attributed to software aging in the framework of Gray’s software fault classification (deterministic and transient), and study the treatment and recovery strategies for each of the fault classes. We then construct a semi-Markov reward model based on workload and resource usage data collected from the UNIX operating system. We identify different workload states using statistical cluster analysis, estimate transition probabilities, and sojourn time distributions from the data. Corresponding to each resource, a reward function is then defined for the model based on the rate of resource depletion in each state. The model is then solved to obtain estimated times to exhaustion for each resource. The result from the semi-Markov reward model are then fed into a higher-level availability model that accounts for failure followed by reactive recovery, as well as proactive recovery. This comprehensive model is then used to derive optimal rejuvenation schedules that maximize availability or minimize downtime cost.', NULL);
INSERT INTO `list` VALUES (10832, '0000', 2001, 'inproceedings', 'Vaidyanathan, K. and Trivedi, Kishor S.', 'Extended Classification of Software Faults Based on Aging', NULL, NULL, '2001 Fast Abstract, Int. Symp. Software Reliability Eng., Hong Kong', 'Int. Symp. Software Reliability Eng.', NULL, NULL, NULL, NULL, 'https://www.semanticscholar.org/paper/Extended-Classification-of-Software-Faults-Based-on-Vaidyanathan-Trivedi/d4c1b5f5e0edf163db313e3afdd222a800558948', 'Software Aging and Rejuvenation', 'Jim Gray classifies software faults into Bohrbugs and Heisenbugs. Bohrbugs are essentially permanent design faults and hence almost deterministic in nature. They can be identified easily and weeded out during the testing and debugging phase (or early deployment phase) of the software life cycle. Heisenbugs, on the other hand, belong to the class of temporary internal faults and are intermittent. They are essentially permanent faults whose conditions of activation occur rarely or are not easily reproducible. Hence these faults result in transient failures, i.e., failures which may not recur if the software is restarted. Some typical situations in which Heisenbugs might surface are boundaries between various software components, improper or insufficient exception handling and interdependent timing of various events. It is for this reason that Heisenbugs are extremely difficult to identify through testing. Most recent studies on failure data have reported that a large proportion of software failures are transient in nature caused by phenomena such as overloads or timing and exception errors. In this paper, we extend Gray’s classification of software faults based on the phenomenon of software aging which has recently gained recognition and importance.', NULL);
INSERT INTO `list` VALUES (10833, '0000', 1999, 'inproceedings', 'Vaidyanathan, K. and Trivedi, K.S.', 'A measurement-based model for estimation of resource exhaustion in operational software systems', 'Hybrid', NULL, '1999 Proceedings 10th International Symposium on Software Reliability Engineering (Cat. No.PR00443)', 'ISSRE', NULL, NULL, '84--93', NULL, '10.1109/ISSRE.1999.809313', 'Software Aging and Rejuvenation', 'Software systems are known to suffer from outages due to transient errors. Recently, the phenomenon of \"software aging\", in which the state of the software system degrades with time, has been reported (S. Garg et al., 1998). The primary causes of this degradation are the exhaustion of operating system resources, data corruption and numerical error accumulation. This may eventually lead to performance degradation of the software or crash/hang failure, or both. Earlier work in this area to detect aging and to estimate its effect on system resources did not take into account the system workload. In this paper, we propose a measurement-based model to estimate the rate of exhaustion of operating system resources both as a function of time and the system workload state. A semi-Markov reward model is constructed based on workload and resource usage data collected from the UNIX operating system. We first identify different workload states using statistical cluster analysis and build a state-space model. Corresponding to each resource, a reward function is then defined for the model based on the rate of resource exhaustion in the different states. The model is then solved to obtain trends and the estimated exhaustion rates and the time-to-exhaustion for the resources. With the help of this measure, proactive fault management techniques such as \"software rejuvenation\" (Y. Huang et al., 1995) may be employed to prevent unexpected outages.', NULL);
INSERT INTO `list` VALUES (10834, '0000', 2016, 'inproceedings', 'Valentim, Nathalia Assis and Macedo, Autran and Matias, Rivalino', 'A Systematic Mapping Review of the First 20 Years of Software Aging and Rejuvenation Research', '综述', NULL, '2016 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)', 'ISSREW', NULL, NULL, '57--63', NULL, '10.1109/ISSREW.2016.42', 'Software Aging and Rejuvenation', 'Although software aging and rejuvenation (SAR) is a young research field, in its first 20 years a lot of knowledge has been produced. Nowadays, important scientific booktitles and conferences include SAR-related topics in their scope of interest. This fast growing and wide range of dissemination venues pose a challenge to researchers to keep tracking of the new findings and trends in this area. In this work, we collected and analyzed SAR research data using analytics to detect trends, patterns, and thematic gaps, in order to provide a comprehensive view of this research field over its first 20 years. We adopted the systematic mapping approach to answer research questions such as: How the main topics investigated in SAR have evolved over time? Which are the most investigated aging effects? Which rejuvenation techniques and strategies are more frequently used?', NULL);
INSERT INTO `list` VALUES (10835, '0000', 2021, 'article', 'Vizarreta, Petra and Sieber, Christian and Blenk, Andreas and Van Bemten, Amaury and Ramachandra, Vinod and Kellerer, Wolfgang and Mas-Machuca, Carmen and Trivedi, Kishor', 'ARES: A Framework for Management of Aging and Rejuvenation in Softwarized Networks', 'Measurement-based（阈值）', NULL, '2021 IEEE Transactions on Network and Service Management', 'IEEE Trans. Netw. Serv. Manag.', '18', '2', '1389--1400', NULL, '10.1109/TNSM.2020.3030589', 'Software Aging and Rejuvenation', 'The recent trend of network softwarization suggests a radical shift in the implementation of traditional network intelligence. In Software Defined Networking (SDN), for instance, the control plane functions of forwarding devices are outsourced to the controller. Softwarized network components are expected to provide uninterrupted service during long periods of time, which makes them prone to the effects of software aging, a phenomena that has been observed in operational software systems where the failure rate increases or the performance of the software degrades with the elapsed time since the last restart. The effects of software aging in operational networks are typically mitigated by software rejuvenation, i.e., planned restarts cleaning the internal system state in order to prevent or postpone aging-related failures. This article presents ARES, a three-step methodological framework for the management of the effects of software aging in softwarized networks, applied to the case study of open source SDN orchestration platforms. Using ARES, we demonstrate that software aging is a systematic problem that cannot be neglected in network orchestration systems. It stems not only from aging-related bugs and natural aging due to fragmentation, but also from design choices, e.g., when implementing distributed systems. Measurements for Open Network Operating System (ONOS) and OpenDaylight (ODL) demonstrate how “simple” and common networking tasks let network performance degrade rapidly and even lead to crashes: for instance, adding and removing 300 intents per second in ONOS significantly increases the response time by 50\\% per day and depletes the memory at the rate of 18GB per day. Moreover, we demonstrate a first rejuvenation approach that can mitigate the effects of aging in ONOS.', NULL);
INSERT INTO `list` VALUES (10836, '0000', 2019, 'article', 'Wan, Xiaohui and Zheng, Zheng and Qin, Fangyun and Qiao, Yu and Trivedi, Kishor S.', 'Supervised Representation Learning Approach for Cross-Project Aging-Related Bug Prediction', 'other', NULL, '2019 IEEE 30th International Symposium on Software Reliability Engineering (ISSRE)', 'ISSRE', NULL, NULL, NULL, NULL, '10.1109/ISSRE.2019.00025', 'Software Aging and Rejuvenation', 'A Supervised Representation Learning Approach (SRLA), which is based on double encoding-layer autoencoder, is proposed to perform cross-project ARB prediction and a transfer cross-validation framework to select the hyper-parameters of cross- project models is presented. Software aging, which is caused by Aging-Related Bugs (ARBs), tends to occur in long-running systems and may lead to performance degradation and increasing failure rate during software execution. ARB prediction can help developers discover and remove ARBs, thus alleviating the impact of software aging. However, ARB-prone files occupy a small percentage of all the analyzed files. It is usually difficult to gather sufficient ARB data within a project. To overcome the limited availability of training data, several researchers have recently developed cross-project models for ARB prediction. A key point for cross-project models is to learn a good representation for instances in different projects. Nevertheless, most of the previous approaches neither consider the reconstruction property of new representation nor encode source samples\' label information in learning representation. To address these shortcomings, we propose a Supervised Representation Learning Approach (SRLA), which is based on double encoding-layer autoencoder, to perform cross-project ARB prediction. Moreover, we present a transfer cross-validation framework to select the hyper-parameters of cross-project models. Experiments on three large open-source projects demonstrate the effectiveness and superiority of our approach compared with the state-of-the-art approach TLAP.', NULL);
INSERT INTO `list` VALUES (10837, '0000', 2020, 'article', 'Wang, Shuguang and Lu, Minyan and Kong, Shiyi and Ai, J.', 'A Dynamic Anomaly Detection Approach Based on Permutation Entropy for Predicting Aging-Related Failures', 'Measurement-based', NULL, '2020 Entropy', 'Entropy', NULL, NULL, NULL, NULL, '10.3390/e22111225', 'Software Aging and Rejuvenation', 'Perutation entropy is modified to Multidimensional Multi-scale Permutation Entropy (MMPE) as a novel aging indicator to detect performance anomalies, since MMPE is sensitive to dynamic state changes. Software aging is a phenomenon referring to the performance degradation of a long-running software system. This phenomenon is an accumulative process during execution, which will gradually lead the system from a normal state to a failure-prone state. It is a crucial challenge for system reliability to predict the Aging-Related Failures (ARFs) accurately. In this paper, permutation entropy (PE) is modified to Multidimensional Multi-scale Permutation Entropy (MMPE) as a novel aging indicator to detect performance anomalies, since MMPE is sensitive to dynamic state changes. An experiment is set on the distributed database system Voldemort, and MMPE is calculated based on the collected performance metrics during execution. Finally, based on MMPE, a failure prediction model using the machine learning method to reveal the anomalies is presented, which can predict failures with high accuracy.', NULL);
INSERT INTO `list` VALUES (10838, '0000', 2020, 'inproceedings', 'Wang, Sihang and Liu, Jing', 'HARRD: Real-time Software Rejuvenation Decision Based on Hierarchical Analysis under Weibull Distribution', 'Model-based', NULL, '2020 IEEE 20th International Conference on Software Quality, Reliability and Security (QRS)', 'QRS', NULL, NULL, '83--90', 'IEEE', '10.1109/QRS51102.2020.00023', 'Software Aging and Rejuvenation', 'Software rejuvenation are developed to mitigate serious consequences caused by software aging mainly through restarting software systems. As such restart actions will temporarily stop the software service, how to select the restart time precisely becomes the core research issue. Current mainstream machine learning based software rejuvenation methods predict the trend of resource usage of hardware parameters to determine the restart time. However the actual aging status in many software systems are not strongly related to the resource usage of hardware parameters, it is not rigorous to deﬁne the aging status with single hardware parameters. In this paper, we propose a novel real-time software rejuvenation decision method, named HARRD, where classic Weibull distribution in the ﬁeld of reliability analysis is well utilized to simulate and model the state transition process of software aging. Then, based on this model with real-time resource usage of hardware monitoring parameters, and together integrating three model indicators, we construct the rejuvenation decision function using the analytic hierarchy process(AHP) to weight above parameters, which could ﬁnally be used as the rejuvenation decision basis for aging software systems. Our rejuvenation decision method could balance the unpredictable factors in software aging process by using accurate simulation models, and consider more indicators for rejuvenation time decision. The experimental results show that the software system based on our proposed method could achieve better software rejuvenation effects in terms of time consumption performance, average task processing speed and system stability.', NULL);
INSERT INTO `list` VALUES (10839, '0000', 2007, 'article', 'Wang, Dazhi and Xie, Wei and Trivedi, Kishor S.', 'Performability analysis of clustered systems with rejuvenation under varying workload', 'Model-based', NULL, '2007 Performance Evaluation', 'Perf. Eval', '64', '3', '247--265', NULL, '10.1016/j.peva.2006.04.002', 'Software Aging and Rejuvenation', 'This paper develops time-based rejuvenation policies to improve the performability measures of a cluster system. Three rejuvenation policies, namely standard rejuvenation, delayed rejuvenation and mixed rejuvenation, are designed to improve the cluster’s performability under varying workload. Analytic models are built to evaluate these three policies. Since deterministic transitions are used in this paper and analytical models based on homogeneous continuous-time Markov chains (CTMC) do not allow non-exponential distributions, we utilize deterministic and stochastic Petri nets (DSPN), in which the underlying stochastic process is a Markov regenerative process (MRGP), to capture both exponential and deterministic distributions. System performability measures under these three rejuvenation policies are derived based on the DSPN models. We show that the mixed rejuvenation policy achieves the maximum performability among the three policies, which results in 12\\% improvement on the system throughput in the example shown in this paper. The delayed rejuvenation is better than the standard rejuvenation with respect to the optimal job blocking probability and system throughput. For longer rejuvenation-triggering intervals, the standard rejuvenation yields a better result than delayed rejuvenation, while for shorter rejuvenation-triggering intervals the delayed rejuvenation policy outperforms standard rejuvenation policy.', NULL);
INSERT INTO `list` VALUES (10840, '0000', 2022, 'inproceedings', 'Watanabe, Kengo and Machida, Fumio', 'Availability Analysis of a Drone System with Proactive Offloading for Software Life-extension', 'Model-based&rej&other', NULL, '2022 IEEE International Conference on Omni-layer Intelligent Systems (COINS)', 'COINS', NULL, NULL, '1--6', NULL, '10.1109/COINS54846.2022.9854966', 'Software Aging and Rejuvenation', 'Real-time image processing on a drone to recognize the real-world environment has become popular recently in many applications. However, continuous image processing on a drone may entail the degradation of performance and reliability over the long-time operation, also known as software aging. Since the degradation due to software aging progresses with the amount of the workload to process, offloading the image processing tasks to other computers can mitigate the progression of the software aging. In this paper, we propose a new software life-extension method to counteract software aging on a drone image processing system by means of proactive task offloading. To evaluate the effectiveness of the proposed method, we develop continuous-time Markov chains (CTMCs) to analyze the stochastic behaviors of the system. Through numerical experiments, we show that proactive offloading improves the steady-state availability, the mean time to down (MTTD), and the average throughput by 1.85\\%, 1.57x, 1.48x, respectively. We also show that the combination of offloading and software rejuvenating further improves the steady-state availability and the average throughput.', NULL);
INSERT INTO `list` VALUES (10841, '0000', 2004, 'inproceedings', 'Wei Xie and Yiguang Hong and Trivedi, K.S.', 'Software rejuvenation policies for cluster systems under varying workload', 'Model-based', NULL, '2004 10th IEEE Pacific Rim International Symposium on Dependable Computing, 2004. Proceedings.', 'PRDC', NULL, NULL, '122--129', NULL, '10.1109/PRDC.2004.1276563', 'Software Aging and Rejuvenation', 'We analyze two software rejuvenation policies of cluster server systems under varying workload, called fixed rejuvenation and delayed rejuvenation. In order to achieve a higher average throughput, we propose the delayed rejuvenation policy, which postpones the rejuvenation of individual nodes until off-peak hours. Analytic models using the well known paradigm of Markov chains are used. Since the size of the Markov model is nontrivial, automated specification generation, and the solution via stochastic Petri nets is utilized. Deterministic time to trigger rejuvenation is approximated by a 20-stage Erlangian distribution. Based on the numerical solutions of the models, we find that under the given context, although the fixed rejuvenation occasionally yields a higher throughput, the delayed rejuvenation policy seems to outperform fixed rejuvenation policy by up to 11\\%. We also compare the steady-state system availabilities of these two rejuvenation policies.', NULL);
INSERT INTO `list` VALUES (10842, '0000', 2016, 'inproceedings', 'Weng, Caisheng and Xiang, Jianwen and Xiong, Shengwu and Zhao, Dongdong and Yang, Chunhui', 'Analysis of Software Aging in Android', 'Model-based', NULL, '2016 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)', 'ISSREW', NULL, NULL, '78--83', NULL, '10.1109/ISSREW.2016.20', 'Software Aging and Rejuvenation', 'There are a number of researches on software aging in different systems, but few researches have been done in Android system. At the same time, due to the complexity of Android memory management mechanisms and lack of comprehensive documents, it is difficult to analyze corresponding memory management mechanisms to determine whether there is aging. Based on these, we focus on some aging-related phenomena by observing available memory of Android, and use experiments to progressively verify some hypotheses about aging in Android. Then, we carry out mathematical modeling of aging and predictive analysis with Markov chains. Through our experiments and modeling analysis, we observe the existence of Android aging, and find that aging is generally irreversible and that the warm rejuvenation (application restart) has little effect on the recovery or mitigation of aging problem. The current experiments are preliminary and limited to specific version of Android OS, smartphone, and applications, but the results and observations may provide a new perspective for further study on aging and rejuvenation in Android with more statistically robust experiments.', NULL);
INSERT INTO `list` VALUES (10843, '0000', 2017, 'inproceedings', 'Weng, Caisheng and Zhao, Dongdong and Lu, Liping and Xiang, Jianwen and Yang, Chunhui and Li, Dong', 'A Rejuvenation Strategy in Android', 'Measurement-based（ML）', NULL, '2017 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)', 'ISSREW', NULL, NULL, '273--279', NULL, '10.1109/ISSREW.2017.50', 'Software Aging and Rejuvenation', 'Compared to critical systems, the user of Android is more concerned about the application launch time. It needs to perform rejuvenation to improve the user experience when the Android suffers from software aging that would lead to an increase of the launch time. Also, rejuvenation can incur in some costs. So it is important to make an optimal rejuvenation strategy to minimize these costs and improve the user experience. At the same time, different workloads on Android have different aging phenomena, which may influence the validation of system state. Based on these, we carried out experiments to simulate user behavior on Android and find software aging phenomena in Android. Then we used active learning based on random forest and four states to build model and constructed software aging rejuvenation strategy on Android. Comparing the experiments without rejuvenation, there is an obvious decrease of the average of application launch time after using the rejuvenation strategy, and the running time of experiments with rejuvenation is longer than that without rejuvenation, which improves the user experience and reduces the probability of unexpected errors.', NULL);
INSERT INTO `list` VALUES (10844, '0000', 2010, 'inproceedings', 'Woehrle, Matthias and Meier, Andreas and Langendoen, Koen', 'On the potential of software rejuvenation for long-running sensor network deployments', 'rej', NULL, '2010 Proceedings of the 2010 ICSE Workshop on Software Engineering for Sensor Network Applications', 'SESENA', NULL, NULL, '44--48', 'Association for Computing Machinery', '10.1145/1809111.1809124', 'Software Aging and Rejuvenation', 'Many sensor network systems encounter considerable problems after deployment despite extensive simulation and testing during the development. A fundamental issue is unforeseen problems that rarely occur, which makes them hard to reproduce. This work focuses on a class of problems that occur due to so-called software aging: The classical software engineering approach to handle software aging effects is software rejuvenation, i. e., the proactive reset of software components. In this positioning paper we discuss whether software rejuvenation can be applied to resource scarce sensor nodes, which are tightly coupled distributed system. We detail why and how software rejuvenation techniques are applicable to sensor networks and presents the basic building blocks required.', NULL);
INSERT INTO `list` VALUES (10845, '0000', 2020, 'article', 'Wu, Xiaoxue and Zheng, Wei and Pu, Minchao and Chen, Jie and Mu, Dejun', 'Invalid bug reports complicate the software aging situation', '分析bug报告&Classification', NULL, '2020 Software Quality Journal', 'Softw. Qual. J', '28', '1', '195--220', NULL, '10.1007/s11219-019-09481-2', 'Software Aging and Rejuvenation', 'Symptoms of software aging include performance degradation and failure occurrence increasing when software systems run for a period of time. Therefore, software aging is closely related to system performance. Understanding and analyzing performance issues in the software system is critical to mastering software aging information. Instead of focusing on normal valid bug reports (VBRs), this paper advocates the usage of invalid bug reports (IBRs) to capture software aging signals. We use performance bugs that are highly related to software aging as an example to construct a binary classification model for bug report classification. We conduct a rigorous evaluation of the constructed models via different performance measures (i.e., recall, precision, F1-score, AUC). Then, the model is used to predict the performance bug reports (PBRs) in IBRs, and a manual analysis of the prediction results is conducted to identify aging-related bug reports (ABRs). The final results show that the ratio of PBRs in IBRs ranges from 4.9 to 42.18\\% for the two real opensource projects HDFS and HBase when considering five different classifiers. Among these five classifiers, Support Vector Machine (SVM) classifier can achieve the best performance. The ratios of PBRs in IBRs by using this classifier are 11.1\\% and 15.35\\% for these two datasets and the performances in terms of F1-score are 85\\% and 74\\%. Further analysis of the predicted PBRs of IBRs in the project HDFS is conducted through a manual user case study; some surprising findings revealing the relationship between IBRs, PBRs, and ABRs are presented: (1) Around 50\\% of the PBRs in IBRs are related to software aging; (2) components that undertake major tasks are more prone to aging problems; (3) more than 50\\% ARBs lead to timeout, 33\\% ARBs are caused by improper control of memory or threats, and 29\\% ARBs are caused by inappropriate management of file operation or disk usage; (4) hard to reproduce is the major reason that ARBs are usually closed as invalid because many aging-related bugs would temporarily disappear by restarting the system.', NULL);
INSERT INTO `list` VALUES (10846, '0000', 2015, 'inproceedings', 'Wu, Huaming and Wolter, Katinka', 'Software aging in mobile devices: Partial computation offloading as a solution', 'other', NULL, '2015 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)', 'ISSREW', NULL, NULL, '125--131', NULL, '10.1109/ISSREW.2015.7392057', 'Software Aging and Rejuvenation', 'Long running applications on resource-constrained mobile devices can lead to software aging, which is a critical impediment to the mobile users due to its pervasive nature. Mobile offloading that migrates computation-intensive parts of applications from mobile devices onto resource-rich cloud servers, is an effective way for enhancing the availability of mobile services as it can postpone or prevent the software aging in mobile devices. Through partitioning the execution between the device side and the cloud side, the mobile device can have the most benefit from offloading in reducing utilisation of the device and increasing its lifetime. In this paper, we propose a path-based offloading partitioning (POP) algorithm to determine which portions of the application tasks to run on mobile devices and which portions on cloud servers with different cost models in mobile environments. The evaluation results show that the partial offloading scheme can significantly improve performance and reduce energy consumption by optimally distributing tasks between mobile devices and cloud servers, and can well adapt to changes in the environment.', NULL);
INSERT INTO `list` VALUES (10847, '0000', 2018, 'article', 'Xiang, Jianwen and Weng, Caisheng and Zhao, Dongdong and Tian, Jing and Xiong, Shengwu and Li, Lin and Andrzejakb, Artur', 'A New Software Rejuvenation Model for Android', 'Model-based', NULL, '2018 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)', 'ISSREW', NULL, NULL, '293--299', NULL, '10.1109/ISSREW.2018.00021', 'Software Aging and Rejuvenation', 'Android users are sometimes troubled by slow UI responses or even application/OS crashes. These issues are typically caused by software aging, a phenomenon characterized by progressive degradation of performance and functionality observed in long-running software systems. A practical and widely used approach to combat software aging is software rejuvenation, i.e. manual or scheduled restart of an application or a device. To reduce service outages, proactive rejuvenation is preferred, which strives to balance application downtime and performance level. However, traditional rejuvenation models cannot be directly applied to Android applications or system, as they do not address user experience, such as avoiding rejuvenation during high activity phases. In this work we exploit the fact that the usage time of mobile phones is typically fragmented in daily life, with periodic switches between active and sleep modes. We propose proactive rejuvenation strategies, which consider both usage and age factors. In particular, we model the usage behavior and aging process as individual Stochastic Petri-Nets, and then compose them into Continuous Time Markov Chains. We evaluate our models via numerical experiments and demonstrate the effectiveness and advantages of the proposed rejuvenation approach.', NULL);
INSERT INTO `list` VALUES (10848, '0000', 2020, 'article', 'Xiang, Jianwen and Weng, Caisheng and Zhao, Dongdong and Andrzejak, Artur and Xiong, Shengwu and Li, Lin and Tian, Jing', 'Software Aging and Rejuvenation in Android: New Models and Metrics', 'Model-based', NULL, '2020 Software Quality Journal', 'Softw. Qual. J', '28', '1', '85--106', NULL, '10.1007/s11219-019-09475-0', 'Software Aging and Rejuvenation', 'Android users are occasionally troubled by the slow UI responses and sudden application/OS crashes. These problems are mainly caused by software aging, a phenomenon of progressive degradation of performance and dependability typically observed in long-running software systems. A countermeasure to software aging is software rejuvenation, i.e., manual or scheduled restart at different levels, such as application, OS, and device. Various software aging and rejuvenation models have been proposed for different software systems. However, these traditional models cannot be applied in the context of mobile devices, as they seldom consider the patterns of usage behavior and user experience specific to mobile phones. We address this problem based on the observations that the usage time of mobile phones is typically fragmented in daily life, with frequent and periodical switches between active and sleep modes, and that the user experience on fluent operation in the active mode is a key concern for mobile users. These insights are exploited to model the usage behavior and aging process by individual Stochastic Petri-Nets, and then to compose them into a Continuous Time Markov Chain (CTMC). Furthermore, we propose proactive rejuvenation strategies based on such CTMCs to achieve the best user experience and the least user interference, such as restarting the device when it is in sleep mode and before it enters an aged state. To consider user experience - a key concern of mobile users which is still less prominent in traditional dependability measurements – we propose new related metrics: for fluency (i.e., the probability that a phone offers a fast UI response to the users), and for the degree of overall user experience. We demonstrate the effectiveness and advantages of the proposed models and metrics via simulations as well as an empirical study.', NULL);
INSERT INTO `list` VALUES (10849, '0000', 2017, 'inproceedings', 'Xiao, Guanping and Zheng, Zheng and Yin, Beibei and Trivedi, Kishor S. and Du, Xiaoting and Cai, Kaiyuan', 'Experience Report: Fault Triggers in Linux Operating System: from Evolution Perspective', '分析bug报告&Classification', NULL, '2017 International Symposium on Software Reliability Engineering (ISSRE)', 'ISSRE', NULL, NULL, '101--111', 'IEEE', '10.1109/ISSRE.2017.21', 'Software Aging and Rejuvenation', 'Linux operating system is a complex system that is prone to suffer failures during usage, and increases difficulties of fixing bugs. Different testing strategies and fault mitigation methods can be developed and applied based on different types of bugs, which leads to the necessity to have a deep understanding of the nature of bugs in Linux. In this paper, an empirical study is carried out on 5741 bug reports of Linux kernel from an evolution perspective. A bug classification is conducted based on fault triggering conditions, followed by the analysis of the evolution of bug type proportions over versions and time, together with their comparisons across versions, products and regression bugs. Moreover, the relationship between bug type proportions and clustering coefficient, as well as the relation between bug types and time to fix are presented. This paper reveals 13 interesting findings based on the empirical results and further provides guidance for developers and users based on these findings.', NULL);
INSERT INTO `list` VALUES (10850, '0000', 2005, 'article', 'Xie, Wei and Hong, Yiguang and Trivedi, Kishor', 'Analysis of a two-level software rejuvenation policy', 'Model-based&rej', NULL, '2005 Reliability Engineering System Safety', 'Reliab. Eng. Syst. Saf', '87', '1', '13--22', NULL, '10.1016/j.ress.2004.02.011', 'Software Aging and Rejuvenation', 'A two-level rejuvenation policy for software systems with degradation process is studied. Both full restarts and partial restarts are considered in this rejuvenation strategy. A semi-Markov process model is constructed, and based on its closed-form solution we obtain the system availability as a bivariate function. Then, the rejuvenation policy is analyzed to maximize the system availability. Several different scenarios of software rejuvenation strategy are demonstrated by numerical examples.', NULL);
INSERT INTO `list` VALUES (10851, '0000', 2014, 'article', 'Xu, Jian and Li, Xuefeng and Zhong, Y. and Zhang, Hong', 'Availability Modeling and Analysis of a Single-Server Virtualized System with Rejuvenation', 'Model-based', NULL, '2014 J. Softw.', 'J. Softw.', NULL, NULL, NULL, NULL, '10.4304/JSW.9.1.129-139', 'Software Aging and Rejuvenation', 'This paper presents two stochastic reward net based availability models for a single-server virtualized system and studies the impact of two critical parameters, the VMM rejuvenation interval and the VM aging detection probability, on downtime and on the number of transaction lost by sensitivity analysis. Availability of business-critical application servers is an issue of paramount importance that has received special attention from the industry and academia in the last decade. This paper presents two stochastic reward net based availability models for a single-server virtualized system. The similarity in both models is that software rejuvenation is applied at not only virtual machine monitor (VMM) level using a time-base policy but also at virtual machines (VMs) using a prediction-based policy. The key difference is that the passive software replication and the active software replication are respectively adopted at the VM level of both models. We compare these models in terms of steady-state system availability by numerical analysis. Results show steady-state system availability with the active replication style gets a bit better than that of the passive one. Further, we study the impact of two critical parameters, the VMM rejuvenation interval and the VM aging detection probability, on downtime and on the number of transaction lost by sensitivity analysis.', NULL);
INSERT INTO `list` VALUES (10852, '0000', 2020, 'inproceedings', 'Xu, Bin and Zhao, Dongdong and Jia, Kai and Zhou, Junwei and Tian, Jing and Xiang, Jianwen', 'Cross-Project Aging-Related Bug Prediction Based on Joint Distribution Adaptation and Improved Subclass Discriminant Analysis', 'other', NULL, '2020 IEEE 31st International Symposium on Software Reliability Engineering (ISSRE)', 'ISSRE', NULL, NULL, '325--334', NULL, '10.1109/ISSRE5003.2020.00038', 'Software Aging and Rejuvenation', 'Software aging, which is caused by Aging-Related Bugs (ARBs), refers to the phenomenon of performance degradation and eventual crash in long running systems. In order to discover and remove ARBs, ARB prediction is proposed. However, due to the low presence and reproducing difficulty of ARBs, it is usually difficult to collect sufficient ARB data within a project. Therefore, cross-project ARB prediction is proposed as a solution to build the target project\'s ARB predictor by using the labeled data from the source project. A key point for cross-project ARB prediction is to reduce distribution difference between source and target project. However, existing approaches mainly focus on the marginal distribution difference while somehow overlook the conditional distribution difference, and they mainly use random oversampling to alleviate the class imbalance which may lead to overfitting. To address these problems, we propose a new crossproject ARB prediction approach based on Joint Distribution Adaptation (JDA) and Improved Subclass Discriminant Analysis (ISDA), called JDA-ISDA. The key idea of JDA-ISDA is first to use JDA to reduce the marginal distribution and conditional distribution difference jointly and then apply ISDA to alleviate the severe class imbalance problem. A set of experiments are carried out on two large open-source projects with six different machine learning (ML) classifiers. The experimental results demonstrate that compared with the state-of-the-art Transfer Learning based Aging-related bug Prediction (TLAP) and Supervised Representation Learning Approach (SRLA), JDA-ISDA is much more robust to different ML classifiers than TLAP, and the average improvement in terms of the balance value can be achieved up to 31.8\\%, and JDA-ISDA also outperforms TLAP and SRLA on average when logistic regression is chosen as the classifier for best performance prediction.', NULL);
INSERT INTO `list` VALUES (10853, '0000', 2014, 'inproceedings', 'Xu, Jian and Wu, Wang-wen and Ma, Chao-yi', 'SOM-based aging detection for Virtual Machine Monitor', 'Measurement-based（ML）', NULL, '2014 IEEE Workshop on Electronics, Computer and Applications', 'IWECA', NULL, NULL, '782--785', NULL, '10.1109/IWECA.2014.6845739', 'Software Aging and Rejuvenation', 'A virtual monitor machine (VMM) inevitably goes through software aging due to its characteristics of large and complex middleware and long-time and continuous running. The VMM aging manifests as gradually degrading performance and an increasing failure occurrence rate, due to error conditions that accrue over time and eventually lead the VMM to failure. To counteract the VMM aging, this paper proposes an aging detection and quantification algorithm for Virtual Machine Monitor, which applies Self-organizing Maps (SOM) to capture VMM behaviors from runtime measurement data and takes a neighborhood area density of a winning neuron as an aging quantification metric to detect VMM aging. Results of two experiments injecting different resource leaks on the Xen platform show that the algorithm has a high true positive rate and a low false positive rate.', NULL);
INSERT INTO `list` VALUES (10854, '0000', 2015, 'article', 'Yakhchi, Moona and Alonso, Javier and Fazeli, Mahdi and Bitaraf, Amir Akhavan and Patooqhy, Ahmad', 'Neural network based approach for time to crash prediction to cope with software aging', 'Measurement-based（ML）', NULL, '2015 J. of Syst. Eng. Electron.', 'J. of Syst. Eng. Electron.', '26', '2', '407--414', NULL, '10.1109/JSEE.2015.00047', 'Software Aging and Rejuvenation', 'Recent studies have shown that software is one of the main reasons for computer systems unavailability. A growing accumulation of software errors with time causes a phenomenon called software aging. This phenomenon can result in system performance degradation and eventually system hang/crash. To cope with software aging, software rejuvenation has been proposed. Software rejuvenation is a proactive technique which leads to removing the accumulated software errors by stopping the system, cleaning up its internal state, and resuming its normal operation. One of the main challenges of software rejuvenation is accurately predicting the time to crash due to aging factors such as memory leaks. In this paper, different machine learning techniques are compared to accurately predict the software time to crash under different aging scenarios. Finally, by comparing the accuracy of different techniques, it can be concluded that the multilayer perceptron neural network has the highest prediction accuracy among all techniques studied.', NULL);
INSERT INTO `list` VALUES (10855, '0000', 2021, 'inproceedings', 'Yakovyna, Vitaliy and Uhrynovskyi, Bohdan', 'Aging of Native and Flutter Applications in Android OS in Various Usage Scenarios', 'Measurement-based&度量', NULL, '2021 IEEE 16th International Conference on Computer Sciences and Information Technologies (CSIT)', 'CSIT', '1', NULL, '313--316', NULL, '10.1109/CSIT52700.2021.9648777', 'Software Aging and Rejuvenation', 'Android operating system and third-party applications are vulnerable to the effects of software aging. Software rejuvenation models and other approaches to counteract aging effects requires aging-related metrics to fit their needs. This paper considers aging manifestation in native Java/Kotlin and cross-platform Flutter applications. Study considers these sets of applications in two usage scenarios: with usage delays of mobile device and without delays. Study shows that Flutter applications are vulnerable to software aging. Experimental results shows that Frame Draw Time metric can fit needs of software rejuvenation models which are based on user behavior patterns. Frame Draw Time and PSS of main system processes can be considered as metrics for detecting and predicting software aging in future works.', NULL);
INSERT INTO `list` VALUES (10856, '0000', 2020, 'inproceedings', 'Yakovyna, Vitaliy and Uhrynovskyi, Bohdan', 'User-Perceived Response Metrics in Android OS for Software Aging detection', '度量', NULL, '2020 IEEE 15th International Conference on Computer Sciences and Information Technologies (CSIT)', 'CSIT', '1', NULL, '436--439', NULL, '10.1109/CSIT49958.2020.9322031', 'Software Aging and Rejuvenation', 'Empirical studies have shown that the Android platform is exposed to the software aging effects. Aging effects, such as poor performance and increased response times for systems and applications, have a negative impact on the user experience. This paper considers user-perceived response metrics: Frame Draw Time and Janky Frames. The proposed metrics are compared with Android Activity Launch Time and memory usage metrics. The expediency of using the proposed metrics in future studies of the aging phenomenon in the Android operating system is substantiated.', NULL);
INSERT INTO `list` VALUES (10857, '0000', 2011, 'inproceedings', 'Yamakita, Kazuya and Yamada, Hiroshi and Kono, Kenji', 'Phase-based reboot: Reusing operating system execution phases for cheap reboot-based recovery', 'rej', NULL, '2011 IEEE/IFIP 41st International Conference on Dependable Systems Networks (DSN)', 'DSN', NULL, NULL, '169--180', NULL, '10.1109/DSN.2011.5958216', 'Software Aging and Rejuvenation', 'Although operating systems (OSes) are crucial to achieving high availability of computer systems, modern OSes are far from bug-free. Rebooting the OS is simple, powerful, and sometimes the only remedy for kernel failures. Once we accept reboot-based recovery as a fact of life, we should try to ensure that the downtime caused by reboots is as short as possible. This paper presents “phase-based” reboots that shorten the downtime caused by reboot-based recovery. The key idea is to divide a boot sequence into phases. The phase-based reboot reuses a system state in the previous boot if the next boot reproduces the same state. A prototype of the phase-based reboot was implemented on Xen 3.4.1 running para-virtualized Linux 2.6.18. Experiments with the prototype show that it successfully recovered from kernel transient failures inserted by a fault injector, and its downtime was 34.3 to 93.6\\% shorter than that of the normal reboot-based recovery.', NULL);
INSERT INTO `list` VALUES (10858, '0000', 2016, 'article', 'Yan, Yongquan and Guo, Ping', 'A practice guide of software aging prediction in a web server based on machine learning', 'Measurement-based（ML）', NULL, '2016 China Commun.', 'China Commun.', '13', '6', '225--235', NULL, '10.1109/CC.2016.7513217', 'Software Aging and Rejuvenation', 'In the past two decades, software aging has been studied by both academic and industry communities. Many scholars focused on analytical methods or time series to model software aging process. While machine learning has been shown as a very promising technique in application to forecast software state: normal or aging. In this paper, we proposed a method which can give practice guide to forecast software aging using machine learning algorithm. Firstly, we collected data from a running commercial web server and preprocessed these data. Secondly, feature selection algorithm was applied to find a subset of model parameters set. Thirdly, time series model was used to predict values of selected parameters in advance. Fourthly, some machine learning algorithms were used to model software aging process and to predict software aging. Fifthly, we used sensitivity analysis to analyze how heavily outcomes changed following input variables change. In the last, we applied our method to an IIS web server. Through analysis of the experiment results, we find that our proposed method can predict software aging in the early stage of system development life cycle.', NULL);
INSERT INTO `list` VALUES (10859, '0000', 2011, 'inproceedings', 'Yoshimura, Takeshi and Yamada, Hiroshi and Kono, Kenji', 'Can Linux be Rejuvenated without Reboots?', 'rej', NULL, '2011 IEEE Third International Workshop on Software Aging and Rejuvenation', 'IW-SAR', NULL, NULL, '50--55', NULL, '10.1109/WoSAR.2011.12', 'Software Aging and Rejuvenation', 'Operating systems (OSes) are crucial for achieving high availability of computer systems. Even if the applications running on the operating system are highly available, a bug inside the kernel may result in a failure of the entire software stack. Rejuvenating OSes is a promising approach to prevent and recover from transient errors. Unfortunately, OS rejuvenation takes a lot of time because we do not have any method other than rebooting the entire OS. In this paper we explore the possibility of rejuvenating Linux without reboots. In our previous research, we investigated the scope of error propagation in Linux. The propagation scope is process-local if the error is confined in the process context that activated it. The scope is kernel-global if the error propagates to other processes\' contexts or global data structures. If most errors are process- local, we can rejuvenate the Linux kernel without rebooting the entire kernel because the kernel goes back to a consistent and clean state simply by killing and revoking the resources of the faulting process. Our conclusion is that Linux can be rejuvenated without reboots with high probability. Linux is coded in a defensive way and thus, most of the manifested errors (96\\%) were process-local and only one error was kernel- global.', NULL);
INSERT INTO `list` VALUES (10860, '0000', 2020, 'inproceedings', 'Yue, Jing and Wu, Xiaojun and Xue, Yunqing', 'Microservice Aging and Rejuvenation', 'Measurement-based（ML）&rej', NULL, '2020 World Conference on Computing and Communication Technologies (WCCCT)', 'WCCCT', NULL, NULL, '1--5', NULL, '10.1109/WCCCT49810.2020.9170005', 'Software Aging and Rejuvenation', 'Due to ‘aging’, not only the service rate of the software decreases with time but the software itself experiences occasional crash/hang failures. Software rejuvenation involves occasional stopping the executing software, ‘cleaning’ the ‘internal state’ and restarting. Moreover, container technology promotes the process of fair and efficient allocation of physical resources among virtual machines. However, the emergence of distributed cloud platform undoubtedly increase the flexibility and complexity of the system. In this paper, we propose a method of predicting microservice [1] aging by deep learning, and a rejuvenation policy by the CVA architecture. From the perspective of container, it can provide a technology of vertical expansion and contraction of container resources, improve the utilization of resources in the clustered environment, and improve the availability of microservice system.', NULL);
INSERT INTO `list` VALUES (10861, '0000', 2003, 'inproceedings', 'Yujuan Bao and Xiaobai Sun and Trivedi, K.S.', 'Adaptive software rejuvenation: degradation model and rejuvenation scheme', 'Hybrid', NULL, '2003 International Conference on Dependable Systems and Networks, 2003. Proceedings.', 'DSN', NULL, NULL, '241--248', 'IEEE', '10.1109/DSN.2003.1209934', 'Software Aging and Rejuvenation', 'We present a framework of adaptive estimation and rejuvenation of software system performance in the presence of aging sources. The framework speciﬁes that a degradation model not only describe an aging process but also enable the adaptation of model-based performance estimates to on-line measurements of data pertaining to the aging process. The adaptive estimation uses model-based a priori estimation and obtains a posteriori estimation based on the data measurements. With the adaptive estimation, the rejuvenation policy determines the time epochs for data collection and rejuvenation according to system dynamics. In the speciﬁc context of resource leaks previously assumed to lead to aging, we present a non-homogeneous Markov model to explicitly establish a connection between resource leaks and the failure rate. We demonstrate an increasing failure rate in the presence of resource leaks.', NULL);
INSERT INTO `list` VALUES (10862, '0000', 2002, 'article', 'Yun Liu and Trivedi, K.S. and Yue Ma and Han, J.J. and Levendel, H.', 'Modeling and analysis of software rejuvenation in cable modem termination systems', 'Model-based', NULL, '2002 13th International Symposium on Software Reliability Engineering, 2002. Proceedings.', 'ISSRE', NULL, NULL, '159--170', NULL, '10.1109/ISSRE.2002.1173239', 'Software Aging and Rejuvenation', 'In order to reduce system outages and the associated downtime cost caused by the \"software aging\" phenomenon, we propose to use software rejuvenation as a proactive system maintenance technique deployed in a CMTS (Cable Modem Termination System) cluster system. Different rejuvenation policies are studied from the perspective of cost and availability. To evaluate these policies, stochastic reward net models are developed and solved by SPNP (Stochastic Petri Net Package). Numerical results show that significant improvement in capacity-oriented availability and decrease in downtime cost can be achieved. The optimization of the rejuvenation interval in the time-based approach and the effect of the prediction coverage in the measurement-based approach are also studied in this paper.', NULL);
INSERT INTO `list` VALUES (10863, '0000', 2001, 'article', 'Yurcik, W. and Doss, D.', 'Achieving fault-tolerant software with rejuvenation and reconfiguration', 'rej', NULL, '2001 IEEE Softw.', 'IEEE Softw.', '18', '4', '48--52', NULL, '10.1109/MS.2001.936217', 'Software Aging and Rejuvenation', 'The authors present two complementary ways to deal with soft-ware aging. Their approach pro-actively reinitializes software to a known operating state, before failure occurs, or reactively reconfigures soft-ware after a failure such that service remains operational.', NULL);
INSERT INTO `list` VALUES (10864, '0000', 2017, 'article', 'Zhai, You-zhi and Li, Qiu-ying and You, Hang-chao', 'Software Health Measurement Method Based on Aging-related Bugs', 'Model-based', NULL, '2017 dtcse', 'dtcse', NULL, 'cmsam', NULL, NULL, '10.12783/dtcse/cmsam2017/16419', 'Software Aging and Rejuvenation', 'Aging-related bugs can lead to software aging, whose performance is the slow response on software system though the software does not crash. This paper aims to propose the measurement method of software health to quantitatively show the impact of aging-related bugs on software. The effect of the bugs and the elements were analyzed. The Gaussian mixture model was developed to measure the degree of software health, which provide the basis for the software failure alarming and failure prediction. Finally, the details of the method were shown by a case study on Hadoop Distributed File System.', NULL);
INSERT INTO `list` VALUES (10865, '0000', 2022, 'inproceedings', 'Zhang, Jun and Li, Shuo and He, Pan', 'A Multi-State Aperiodic Inspection Strategy Optimizing Method in Software Rejuvenation', 'Measurement-based（检查时间间隔）', NULL, '2022 International Conference on Wearables, Sports and Lifestyle Management (WSLM)', 'WSLM', NULL, NULL, '47--51', NULL, '10.1109/WSLM54683.2022.00014', 'Software Aging and Rejuvenation', 'To further reduce the maintenance cost in the process of software aging, a multi-state aperiodic inspection method in the field of software rejuvenation is proposed. In this method, the inspection target reliability (ITR) in different state intervals is used as a decision variable, and the decision parameters can be dynamically adjusted according to the system operating state to flexibly determine the optimal inspection period. By establishing a discrete maintenance cost model under the constraints of multi-state reliability, the optimal decision configuration parameters are solved using an improved genetic algorithm. The final experimental results show that the proposed method can significantly reduce system maintenance cost compared with existing single-state methods.', NULL);
INSERT INTO `list` VALUES (10866, '0000', 2008, 'inproceedings', 'Zhao, Long and Song, QinBao and Zhu, Lei', 'Common Software-Aging-Related Faults in Fault-Tolerant Systems', 'Model-based', NULL, '2008 International Conference on Computational Intelligence for Modelling Control Automation', 'CIMCA', NULL, NULL, '327--331', 'IEEE', '10.1109/CIMCA.2008.113', 'Software Aging and Rejuvenation', 'In recent years, remarkable attention has been focused on software aging phenomena, in which the performance of software systems degrades with time. Fault-tolerant software systems which provide high assurance may suffer from such phenomena. Based on the common software-aging-related faults in fault-tolerant systems, a behavior model of a double-version fault-tolerant software system is established using Markov reward model. The performance of the system such as expected service rate in steady state is evaluated and the sensitivity analysis of some parameters is performed.', NULL);
INSERT INTO `list` VALUES (10867, '0000', 2010, 'inproceedings', 'Zhao, Jing and Trivedi, Kishor S. and Wang, YanBin and Chen, XiaoYong', 'Evaluation of software performance affected by aging', 'Measurement-based（ML）', NULL, '2010 IEEE Second International Workshop on Software Aging and Rejuvenation', 'IW-SAR', NULL, NULL, '1--6', NULL, '10.1109/WOSAR.2010.5722093', 'Software Aging and Rejuvenation', 'A number of studies have reported the phenomenon of “Software aging”, characterized by progressive software performance degradation. This is mainly caused by the exhaustion of the combination of system resources. Traditionally, modeling and analysis of software aging has been restricted to a single resource aging. The combined effect of software aging due to the interaction of several resources remains to be explored. A BP network model for the evaluation of software performance affected by aging is proposed in this paper, and then a robust locally weighted regression algorithm is presented to identify the inflexion point. The shape of performance curve changes greatly at the inflexion point, which makes it easy to determine when to perform software rejuvenation. Experimental results based on actual data sets verify the proposed model effectiveness in evaluation of the software performance.', NULL);
INSERT INTO `list` VALUES (10868, '0000', 2011, 'inproceedings', 'Zhao, Jing and Trivedi, Kishor S.', 'Performance Modeling of Apache Web Server Affected by Aging', 'Hybrid', NULL, '2011 IEEE Third International Workshop on Software Aging and Rejuvenation', 'IW-SAR', NULL, NULL, '56--61', NULL, '10.1109/WoSAR.2011.13', 'Software Aging and Rejuvenation', 'A number of studies have reported the phenomenon of \"software aging\", characterized by progressive software performance degradation. Response time (RT) as a customer-affecting metric can be used to detect the onset of software aging. Alberto Avritzer et al. proposed several software aging detection and rejuvenation algorithms based on the measured variation of RT. In this paper, we extend the result by Ablerto Avritzer et al. by using a validated M/E2/1/K queueing model of Apache web server that is used to help detect aging. Simulation results show the effectiveness of these algorithms and to help set various control parameters.', NULL);
INSERT INTO `list` VALUES (10869, '0000', 2014, 'article', 'Zhao, Jing and Jin, Yuliang and Trivedi, Kishor S. and Jr., Rivalino Matias and Wang, Yanbin', 'Software Rejuvenation Scheduling Using Accelerated Life Testing', 'testing', NULL, '2014 J. Emerg. Technol. Comput. Syst.', 'J. Emerg. Technol. Comput. Syst.', '10', '1', '9:1--9:23', NULL, '10.1145/2539118', 'Software Aging and Rejuvenation', 'A number of studies have reported the phenomenon of “Software aging”, caused by resource exhaustion and characterized by progressive software performance degradation. In this article, we carry out an experimental study of software aging and rejuvenation for an on-line bookstore application, following the standard configuration of TPC-W benchmark. While real website is used for the bookstore, the clients are emulated. In order to reduce the time to application failures caused by memory leaks, we use the accelerated life testing (ALT) approach. We then select the Weibull time to failure distribution at normal level, to be used in a semi-Markov process, to compute the optimal software rejuvenation trigger interval. Since the validation of optimal rejuvenation trigger interval with emulated browsers will take an inordinate long time, we develop a simulation model to validate the ALT experimental results, and also estimate the steady-state availability to cross-validate the results of the semi-Markov availability model.', NULL);
INSERT INTO `list` VALUES (10870, '0000', 2014, 'inproceedings', 'Zhao, Jing and Wang, Yan-Bin and Ning, Gao-Rong and Wang, Cheng-Hong and Trivedi, Kishor S. and Cai, K-Y and Zhang, Zhen-Yu', 'Software Maintenance Optimization Based on Stackelberg Game Methods', 'Model-based', NULL, '2014 IEEE International Symposium on Software Reliability Engineering Workshops', 'ISSREW', NULL, NULL, '426--430', NULL, '10.1109/ISSREW.2014.38', 'Software Aging and Rejuvenation', 'Application servers (AS) of virtualized platform may suffer from software aging problem. In this paper, we first formulate the system model including three virtual machines. Two of them act as the main servers, and the third machine acts as the backup node. The motivation of our formulated model is that the relationship between the service provider and the service maintainer is collaborative as well as having different goals between them, the service provider as a leader wants to maximize his system availability, while the service maintainer wants to minimize his maintenance cost. Thus, the problem of maximizing availability and minimizing cost between the service provider and service maintainer is Stackelberg game based. Next, we assume that the AS degradation is caused by resource consumption due to memory leaks for the AS on the active VMs, and we present the system degradation states based on Markov renewal processes. We give the analytical definitions of threshold levels for Ralert at each VM, which are used to determine the optimal rejuvenation schedules. In addition, we obtain the steady-state availability expressions for the system and the mean maintenance cost. Finally, we give the Stackelberg strategy with the open-loop information and the solutions for the game theory by a numerical illustration.', NULL);
INSERT INTO `list` VALUES (10871, '0000', 2014, 'article', 'Zheng, Pengfei and Qi, Yong and Zhou, Yangfan and Chen, Pengfei and Zhan, Jianfeng and Lyu, Michael Rung-Tsong', 'An Automatic Framework for Detecting and Characterizing Performance Degradation of Software Systems', 'Measurement-based', NULL, '2014 IEEE Transactions on Reliability', 'Trans. Rel.', '63', '4', '927--943', NULL, '10.1109/TR.2014.2338255', 'Software Aging and Rejuvenation', 'Software systems that run continuously over a long time have been frequently reported encountering gradual degradation issues. That is, as time progresses, software tends to exhibit degraded performance, deflated service capacity, or deteriorated QoS. Currently, the state-of-the-art approach of Mann-Kendall Test \\& Seasonal Kendall Test \\& Sen\'s Slope Estimator \\& Seasonal Sen\'s Slope Estimator (MKSK) detects and characterizes degradation via a combination of techniques in statistical trend analysis. Nevertheless, we pinpoint some drawbacks of MKSK in this paper: 1) MKSK cannot be automated for large scale software degradation analysis, 2) MKSK estimates the degradation trend of software in an oversimplified linear way, 3) MKSK is sensitive to noise, and 4) MKSK suffers from high computational complexity. To overcome all these limitations, we propose a more advanced approach called Modified Cox-Stuart Test \\& Iterative Hodrick-Prescott Filter (CSHP). The superiority of our CSHP approach over MKSK is validated through extensive Monte Carlo simulations, as well as a real performance dataset measured from 99 real-world web servers.', NULL);
INSERT INTO `list` VALUES (10872, '0000', 2020, 'inproceedings', 'Zheng, Junjun and Okamura, Hiroyuki and Dohi, Tadashi', 'How Robust is the Optimal Software Rejuvenation Timing?', 'Model-based', NULL, '2020 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)', 'ISSREW', NULL, NULL, '336--341', NULL, '10.1109/ISSREW51248.2020.00098', 'Software Aging and Rejuvenation', 'Robustness is usually relevant for characterizing the dependence between the values of model parameters and system behavior, and can be understood as stability of system behavior under changes in model parameters. In this paper, we consider a simple software rejuvenation model and its optimal rejuvenation timing, which maximizes the steady-state availability of the system. The main contribution of this work is to provide a new perspective on the optimal software rejuvenation timing, that is, the robustness of the optimal rejuvenation timing against input factors. In particular, the degree of robustness is quantified by the first derivatives of the optimal rejuvenation timing with respect to the model parameters. The robustnesses of both optimal rejuvenation timing and system availability with the optimal rejuvenation timing are considered. A numerical example with Weibull distributed failure time is devoted to clarifying how robust the optimal rejuvenation timing is, and determine the most sensitive model parameter. As a result, the optimal rejuvenation timing seems to be more robust to the parameters regarding failure time distribution, compared with the other parameters.', NULL);
INSERT INTO `list` VALUES (10873, '0000', 2021, 'inproceedings', 'Zheng, Junjun and Okamura, Hiroyuki and Dohi, Tadashi', 'Sensitivity Analysis of Software Rejuvenation Model with Markov Regenerative Process', 'Model-based', NULL, '2021 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)', 'ISSREW', NULL, NULL, '9--16', NULL, '10.1109/ISSREW53611.2021.00038', 'Software Aging and Rejuvenation', 'This paper considers the parametric sensitivity of a software rejuvenation model for transaction systems whose system behavior is described by a quasi birth-and-death (QBD) process with Markovian arrivals, and the software rejuvenation model is represented by a Markov regenerative process (MRGP). The stationary analysis of the MRGP model is based on the embedding Markov chain (EMC) approach. Then the sensitivities of the stationary solution and the performance criteria of interest, i.e., the loss probability of transactions, with respect to all model parameters, are formulated. Finally, a numerical experiment was conducted to illustrate the critical parameters for a transaction system with software rejuvenation. The numerical results showed that the proposed approach effectively revealed critical model parameters and provided significant insights into performance optimization and parameter estimation.', NULL);
INSERT INTO `list` VALUES (10874, '0000', 2022, 'inproceedings', 'Zhou, Yancai and Zhang, Chen and Jia, Kai and Zhao, Dongdong and Xiang, Jianwen', 'A Software Aging-Related Bug Prediction Framework Based on Deep Learning and Weakly Supervised Oversampling', 'other', NULL, '2022 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)', 'ISSREW', NULL, NULL, '185--192', NULL, '10.1109/ISSREW55968.2022.00066', 'Software Aging and Rejuvenation', 'Software aging refers to the phenomenon of sys-tem performance degradation and eventual failure caused by Aging-Related Bugs (ARBs). Software aging seriously affects the reliability and availability of software systems. To discover and remove ARBs, ARBs prediction is presented, and most of them only employed static code metrics to predict those buggy codes. However, static code metrics do not capture the syntactic and semantic features of the code, which are important to building accurate prediction models. To address this problem, we design a deep neural network by combining the bidirectional long short-term memory (BLSTM) and the attention mechanism to extract context-sensitive semantic features of the code. In addition, we apply a weakly supervised oversampling (WSO) method to alleviate class imbalance problems in datasets. We named our framework ABLSTM-WSO. We conduct experiments with five classifiers on two widely used open-source projects(MySQL and Linux) and use AUC, Balance, and F1-score as the evaluation metrics. Experimental results show that ABLSTM-WSO can significantly improve the ARBs prediction performance.', NULL);
INSERT INTO `list` VALUES (10879, 'Thu, 26 Jan 2023 15:26:31 +0100', 2023, 'article', 'Carlos Ansótegui, Eduard Torres', 'A Benchmark Generator for Combinatorial Testing', NULL, NULL, '2023 CoRR', 'CoRR', 'abs/2301.08134', '', '', NULL, '10.48550/arXiv.2301.08134', 'Combinatorial Testing', 'Combinatorial Testing (CT) tools are essential to test properly a wide range of systems (train systems, Graphical User Interfaces (GUIs), autonomous driving systems, etc). While there is an active research community working on developing CT tools, paradoxically little attention has been paid to making available enough resources to test the CT tools themselves. In particular, the set of available benchmarks to asses their correctness, effectiveness and efficiency is rather limited. In this paper, we introduce a new generator of CT benchmarks that essentially borrows the structure contained in the plethora of available Combinatorial Problems from other research communities in order to create meaningful benchmarks. We additionally perform an extensive evaluation of CT tools with these new benchmarks. Thanks to this study we provide some insights on under which circumstances a particular CT tool should be used.', NULL);
INSERT INTO `list` VALUES (10880, 'Sat, 13 May 2023 01:06:26 +0200', 2023, 'article', 'Aminu Aminu Muazu, Ahmad Sobri Hashim, Aliza Sarlan, Mujaheed Abdullahi', 'SCIPOG: Seeding and constraint support in IPOG strategy for combinatorial t-way testing to generate optimum test cases', NULL, NULL, '2023 J. King Saud Univ. Comput. Inf. Sci.', 'J. King Saud Univ. Comput. Inf. Sci.', '35', '1', '185--201', NULL, '10.1016/j.jksuci.2022.11.010', 'Combinatorial Testing', 'Combinatorial t-way technique is efficient in generating test data and addressing the problem of combinatorial explosion. When constructing a test case, numerous literatures classified t-way strategies into two basic approaches as either One-test-at-a-time approach (OTAT) and One-parameter-at-a-time approach (OPAT). At least three major challenge groups can be encountered when creating test cases. The first one is provision of parameters seeding support that will improve the software quality. The second involves automatically obtaining data regarding parameter constraints and identifying interactions between system components. The last one is the execution speed and the test suite size. However, in all the existing OPAT t-way strategies, given that the system is loaded with this information, testing present-day software systems is made difficult or impossible. This study presents an effective combinatorial t-way test case generation strategy named Seeding and Constraint support in In-Parameter-Order Generalized (SCIPOG), to develop an improved paired testing approach. However, the study examines the present state-of-the-art and compares several OPAT strategies found in the literature. Moreover, experiments are discussed as part of this process to demonstrate the correctness of the implementation. When statistically analyzing the findings, two non-parametric tests—the Wilcoxon Rank and Friedman tests–were run. SCIPOG, however, produced competitive results. Finally, SCIPOG showed the efficiency of the two proposed methods, which are seeding and constraint support in IPOG strategy.\r\n\r\n', NULL);
INSERT INTO `list` VALUES (10881, 'Sun, 13 Nov 2022 17:52:36 +0100', 2022, 'article', 'Ludwig Kampel , Michael Wagner , Ilias S. Kotsireas , Dimitris E. Simos', 'A primer on the application of neural networks to covering array generation', NULL, NULL, '2022 Optim. Methods Softw', 'Optim. Methods Softw', '37', '3', '1165--1202', NULL, '10.1080/10556788.2021.1907384', 'Combinatorial Testing', 'In the past, combinatorial structures have been used only to tune parameters of neural networks. In this work, we employ neural networks in the form of Boltzmann machines and Hopfield networks for the construction of a specific class of combinatorial designs, namely covering arrays (CAs). In past works, these neural networks were successfully used to solve set cover instances. For the construction of CAs, we consider the corresponding set cover instances and use neural networks to solve such instances. We adapt existing algorithms for solving general set cover instances, which are based on Boltzmann machines and Hopfield networks and apply them for CA construction. Furthermore, for the algorithm based on Boltzmann machines, we consider newly designed versions, where we deploy structural changes of the underlying Boltzmann machine, adding a feedback loop. Additionally, one variant of this algorithm employs learning techniques based on neural networks to adjust the various connections encountered in the graph representing the considered set cover instances. Culminating in a comprehensive experimental evaluation, our work presents the first study of applications of neural networks in the field of covering array generation and related discrete structures and may act as a guideline for future investigations.', NULL);
INSERT INTO `list` VALUES (10882, 'Sun, 25 Dec 2022 14:03:47 +0100', 2023, 'article', 'Ryan E. Dougherty , Kristoffer Kleine , Michael Wagner , Charles J. Colbourn , Dimitris E. Simos', 'Algorithmic methods for covering arrays of higher index', NULL, NULL, '2023 J. Comb. Optim.', 'J. Comb. Optim.', '45', '1', '28', NULL, '10.1007/s10878-022-00947-x', 'Combinatorial Testing', 'Covering arrays are combinatorial objects used in testing large-scale systems to increase confidence in their correctness. To do so, each interaction of at most a specified number t of factors is represented in at least one test; that is, the covering array has strength t and index 1. For certain systems, the outcome of running a test may be altered by variability of the interaction effect or by measurement error of the test result. To improve the efficacy of testing, one can ensure that each interaction of t or fewer factors is represented in at least λ\r\n tests. When λ>1\r\n, this leads to covering arrays of higher index. We explore two algorithmic methods for constructing covering arrays of higher index. One is based on the in-parameter-order algorithm, and the other employs a conditional expectation paradigm. We compare these two by performing experiments on real-world benchmarks and on uniform parameter sets.', NULL);
INSERT INTO `list` VALUES (10883, 'Wed, 20 May 2020 21:33:18 +0200', 2019, 'article', 'Tetsuro Katayama , Futa Hirakoba , Yoshihiro Kita , Hisaaki Yamaba , Kentaro Aburada , Naonobu Okazaki', 'Application of Pairwise Testing into BWDM which is a Test Case Generation Tool for the VDM++ Specification', NULL, NULL, 'J. Robotics Netw. Artif. Life', 'J. Robotics Netw. Artif. Life', '6', '3', '143--147', NULL, '10.2991/jrnal.k.191202.001', 'Combinatorial Testing', 'Verification tool for Vienna Development Method (BWDM) is a test case generation tool for the VDM++ specification. The existing BWDM could cause a combinatorial explosion of the generated test cases. To reduce the number of test cases, there is Pairwise Independent Combinatorial Testing Tool (PICT): a pairwise testing tool. We apply pairwise testing into BWDM. Here, BWDM cannot call PICT library directly. Hence, we have developed PICT-wrapper. It is an interface to connect PICT and BWDM. The extended BWDM eliminate the possibility of the combinatorial explosion.', NULL);
INSERT INTO `list` VALUES (10884, 'Fri, 21 Jan 2022 16:48:15 +0100', 2019, 'article', 'R. Anbunathan , Anirban Basu', 'Combining genetic algorithm and pairwise testing for optimised test generation from UML ADs', NULL, NULL, 'IET Softw', 'IET Softw', '13', '5', '423--433', NULL, '10.1049/iet-sen.2018.5207', 'Combinatorial Testing', 'Unified modelling language (UML) activity diagram (AD) is used to represent system behaviour abstractly and is used by testers to generate test cases and test data. During the design of test cases, AD with concurrent activities may lead to a large number of paths, and it may not always be possible to test all execution paths. Research on deriving test cases from AD having concurrent activities has focused on conventional search techniques such as breadth-first search and depth-first search which has been found to be inefficient in such cases. To overcome this drawback, the authors propose a method using pairwise testing and genetic algorithm to derive a reduced number of test cases in AD with concurrent activities. Experiments conducted on various real-life concurrent systems show that the proposed technique generates a reduced number of test cases compared with existing methods.', NULL);
INSERT INTO `list` VALUES (10885, 'Fri, 17 Mar 2023 08:34:48 +0100', 2022, 'inproceedings', 'Chuan Luo , Qiyuan Zhao , Shaowei Cai , Hongyu Zhang , Chunming Hu', 'SamplingCA: effective and efficient sampling-based pairwise testing for highly configurable software systems', NULL, NULL, 'SIGSOFT', 'SIGSOFT', '', '', '1185--1197', NULL, '10.1145/3540250.3549155', 'Combinatorial Testing', 'Combinatorial interaction testing (CIT) is an effective paradigm for testing highly configurable systems, and its goal is to generate a t-wise covering array (CA) as a test suite, where t is the strength of testing. It is recognized that pairwise testing (i.e., CIT with t=2) is the most common CIT technique, and has high fault detection capability in practice. The problem of pairwise CA generation (PCAG), which is a core problem in pairwise testing, aims at generating a pairwise CA (i.e., 2-wise CA) of minimum size, subject to hard constraints. The PCAG problem is a hard combinatorial optimization problem, which urgently requires practical methods for generating pairwise CAs (PCAs) of small sizes. However, existing PCAG algorithms suffer from the severe scalability issue; that is, when solving large-scale PCAG instances, existing state-of-the-art PCAG algorithms usually cost a fairly long time to generate large PCAs, which would make the testing of highly configurable systems both ineffective and inefficient. In this paper, we propose a novel and effective sampling-based approach dubbed SamplingCA for solving the PCAG problem. SamplingCA first utilizes sampling techniques to obtain a small test suite that covers valid pairwise tuples as many as possible, and then adds a few more test cases into the test suite to ensure that all valid pairwise tuples are covered. Extensive experiments on 125 public PCAG instances show that our approach can generate much smaller PCAs than its state-of-the-art competitors, indicating the effectiveness of SamplingCA. Also, our experiments show that SamplingCA runs one to two orders of magnitude faster than its competitors, demonstrating the efficiency of SamplingCA. Our results confirm that SamplingCA is able to address the scalability issue and considerably pushes forward the state of the art in PCAG solving.', NULL);

SET FOREIGN_KEY_CHECKS = 1;
